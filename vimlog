
Searching for "bitmaps/vim.ico" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\bitmaps/vim.ico"
Searching for "C:\Program Files\Vim/vimfiles\bitmaps/vim.ico"
Searching for "C:\Program Files\Vim\vim90\bitmaps/vim.ico"
could not source "$VIM\vimrc"
sourcing "$HOME\_vimrc"
line 1: #redraw
               Error detected while processing C:\Users\chris\_vimrc:
line    1:
E488: Trailing characters: redraw: #redraw
line 2: set enc=utf-8
line 3: set fenc=utf-8
line 4: set termencoding=utf-8
line 5: set nocompatible
line 6: set autoindent
line 7: set smartindent
line 8: set tabstop=4
line 9: set shiftwidth=4
line 10: set expandtab
line 11: #set t_Co=256
line   11:
E488: Trailing characters: set t_Co=256: #set t_Co=256
line 12: syntax on
line 12: so $VIMRUNTIME\syntax\syntax.vim
line 12: sourcing "C:\Program Files\Vim\vim90\syntax\syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/synload.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/synload.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/synload.vim"
line 20: sourcing "C:\Program Files\Vim\vim90\syntax\synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Set the default highlighting colors.  Use a color scheme if specified.
line 19: if exists("colors_name")
line 20:   exe "colors " . colors_name
line 21: else
line 22:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 22: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
Searching for "colors/lists/default.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim\vim90\colors/lists/default.vim"
line 37: sourcing "C:\Program Files\Vim\vim90\colors\lists\default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2023 Apr 19
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: 
line 10: " make sure line continuation works
line 11: let s:keepcpo = &cpo
line 12: set cpo&vim
line 13: 
line 14: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b
line 804: 
line 805: let &cpo = s:keepcpo
line 806: unlet s:keepcpo
line 807: 
line 808: "vim: sw=4
finished sourcing C:\Program Files\Vim\vim90\colors\lists\default.vim
continuing in C:\Program Files\Vim\vim90\syntax\syncolor.vim
Searching for "C:\Users\chris/vimfiles/after\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\colors/lists/default.vim"
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Program Files\Vim\vim90\syntax\synload.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 23: endif
line 24: 
line 25: " Line continuation is used here, remove 'C' from 'cpoptions'
line 26: let s:cpo_save = &cpo
line 27: set cpo&vim
line 28: 
line 29: " First remove all old syntax autocommands.
line 30: au! Syntax
line 31: 
line 32: au Syntax *^I^Icall s:SynSet()
line 33: 
line 34: fun! s:SynSet()
line 64: 
line 65: 
line 66: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 67: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 72: 
line 73: 
line 74: " Source the user-specified syntax highlighting file
line 75: if exists("mysyntaxfile")
line 76:   let s:fname = expand(mysyntaxfile)
line 77:   if filereadable(s:fname)
line 78:     execute "source " . fnameescape(s:fname)
line 79:   endif
line 80: endif
line 81: 
line 82: " Restore 'cpoptions'
line 83: let &cpo = s:cpo_save
line 84: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\syntax\synload.vim
continuing in C:\Program Files\Vim\vim90\syntax\syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
Searching for "filetype.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\filetype.vim"
Searching for "C:\Program Files\Vim/vimfiles\filetype.vim"
Searching for "C:\Program Files\Vim\vim90\filetype.vim"
line 26: sourcing "C:\Program Files\Vim\vim90\filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: " Listen very carefully, I will say this only once
line 8: if exists("did_load_filetypes")
line 9:   finish
line 10: endif
line 11: let did_load_filetypes = 1
line 12: 
line 13: " Line continuation is used here, remove 'C' from 'cpoptions'
line 14: let s:cpo_save = &cpo
line 15: set cpo&vim
line 16: 
line 17: augroup filetypedetect
line 18: 
line 19: " Ignored extensions
line 20: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 23: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~\+$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 30: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 34: elseif &verbose > 0
line 35:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 36: endif
line 37: 
line 38: " Pattern used to match file names which should not be inspected.
line 39: " Currently finds compressed files.
line 40: if !exists("g:ft_ignore_pat")
line 41:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 42: endif
line 43: 
line 44: " Function used for patterns that end in a star: don't set the filetype if the
line 45: " file name matches ft_ignore_pat.
line 46: " When using this, the entry should probably be further down below with the
line 47: " other StarSetf() calls.
line 48: func s:StarSetf(ft)
line 53: 
line 54: " Vim help file
line 55: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 56: 
line 57: " Abaqus or Trasys
line 58: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 59: 
line 60: " 8th (Firth-derivative)
line 61: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 62: 
line 63: " A-A-P recipe
line 64: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 65: 
line 66: " A2ps printing utility
line 67: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 68: 
line 69: " ABAB/4
line 70: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 71: 
line 72: " ABC music notation
line 73: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 74: 
line 75: " ABEL
line 76: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 77: 
line 78: " AceDB
line 79: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 80: 
line 81: " Ada (83, 9X, 95)
line 82: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 83: if has("vms")
line 84:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 85: else
line 86:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 87: endif
line 88: 
line 89: " AHDL
line 90: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 91: 
line 92: " AIDL
line 93: au BufNewFile,BufRead *.aidl^I^I^Isetf aidl
line 94: 
line 95: " AMPL
line 96: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 97: 
line 98: " Ant
line 99: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 100: 
line 101: " Arduino
line 102: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 103: 
line 104: " Apache config file
line 105: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 106: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 107: 
line 108: " XA65 MOS6510 cross assembler
line 109: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 110: 
line 111: " Applescript
line 112: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 113: 
line 114: " Automake (must be before the *.am pattern)
line 115: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 116: 
line 117: " Applix ELF
line 118: au BufNewFile,BufRead *.am^I^I^Isetf elf
line 119: 
line 120: " ALSA configuration
line 121: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 122: 
line 123: " Arc Macro Language
line 124: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 125: 
line 126: " APT config file
line 127: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 128: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 129: " more generic pattern far down
line 130: 
line 131: " Arch Inventory file
line 132: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 133: 
line 134: " ART*Enterprise (formerly ART-IM)
line 135: au BufNewFile,BufRead *.art^I^I^Isetf art
line 136: 
line 137: " AsciiDoc
line 138: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 139: 
line 140: " ASN.1
line 141: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 142: 
line 143: " Active Server Pages (with Visual Basic Script)
line 144: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 150: 
line 151: " Active Server Pages (with Perl or Visual Basic Script)
line 152: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 160: 
line 161: " Grub (must be before pattern *.lst)
line 162: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 163: 
line 164: " Maxima, see:
line 165: " https://maxima.sourceforge.io/docs/manual/maxima_71.html#file_005ftype_005fmaxima
line 166: " Must be before the pattern *.mac.
line 167: " *.dem omitted - also used by gnuplot demos
line 168: " *.mc omitted - used by dist#ft#McSetf()
line 169: au BufNewFile,BufRead *.demo,*.dm{1,2,3,t},*.wxm,maxima-init.mac setf maxima
line 170: 
line 171: " Assembly (all kinds)
line 172: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 173: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 174: 
line 175: " Assembly - Macro (VAX)
line 176: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 177: 
line 178: " Astro
line 179: au BufNewFile,BufRead *.astro^I^I^Isetf astro
line 180: 
line 181: " Atlas
line 182: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 183: 
line 184: " Atom is based on XML
line 185: au BufNewFile,BufRead *.atom^I^I^Isetf xml
line 186: 
line 187: " Authzed
line 188: au BufNewFile,BufRead *.zed^I^I^Isetf authzed
line 189: 
line 190: " Autoit v3
line 191: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 192: 
line 193: " Autohotkey
line 194: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 195: 
line 196: " Autotest .at files are actually m4
line 197: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 198: 
line 199: " Avenue
line 200: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 201: 
line 202: " Awk
line 203: au BufNewFile,BufRead *.awk,*.gawk^I^Isetf awk
line 204: 
line 205: " B
line 206: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 207: 
line 208: " BASIC or Visual Basic
line 209: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTbas()
line 210: au BufNewFile,BufRead *.bi,*.bm^I^I^Icall dist#ft#FTbas()
line 211: 
line 212: " Bass
line 213: au BufNewFile,BufRead *.bass^I^I^Isetf bass
line 214: 
line 215: " IBasic file (similar to QBasic)
line 216: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 217: 
line 218: " FreeBasic file (similar to QBasic)
line 219: au BufNewFile,BufRead *.fb^I^I^Isetf freebasic
line 220: 
line 221: " Batch file for MSDOS. See dist#ft#FTsys for *.sys
line 222: au BufNewFile,BufRead *.bat^I^I^Isetf dosbatch
line 223: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 224: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 226: " ABB RAPID or Batch file for MSDOS.
line 227: au BufNewFile,BufRead *.sys\c^I^I^Icall dist#ft#FTsys()
line 228: 
line 229: " Batch file for 4DOS
line 230: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 231: 
line 232: " BC calculator
line 233: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 234: 
line 235: " BDF font
line 236: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 237: 
line 238: " Beancount
line 239: au BufNewFile,BufRead *.beancount^I^Isetf beancount
line 240: 
line 241: " BibTeX bibliography database file
line 242: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 243: 
line 244: " BibTeX Bibliography Style
line 245: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 246: 
line 247: " Bicep
line 248: au BufNewFile,BufRead *.bicep,*.bicepparam^I^I^Isetf bicep
line 249: 
line 250: " BIND configuration
line 251: " sudoedit uses namedXXXX.conf
line 252: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 253: 
line 254: " BIND zone
line 255: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 256: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 257: 
line 258: " Blade
line 259: au BufNewFile,BufRead *.blade.php^I^Isetf blade
line 260: 
line 261: " Blank
line 262: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 263: 
line 264: " Bitbake
line 265: au BufNewFile,BufRead *.bb,*.bbappend,*.bbclass,*/build/conf/*.conf,*/meta{-*,}/conf/*.conf^Isetf bitbake
line 266: 
line 267: " Blkid cache file
line 268: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 269: 
line 270: " BSDL
line 271: au BufNewFile,BufRead *.bsd,*.bsdl^I^I^Isetf bsdl
line 272: 
line 273: " Bazel (https://bazel.build) and Buck2 (https://buck2.build/)
line 274: autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE,WORKSPACE.bzlmod^Isetf bzl
line 275: if has("fname_case")
line 276:   " There is another check for BUILD and BUCK further below.
line 277:   autocmd BufRead,BufNewFile *.BUILD,BUILD,BUCK^I^Isetf bzl
line 278: endif
line 279: 
line 280: " Busted (Lua unit testing framework - configuration files)
line 281: au BufNewFile,BufRead .busted^I^I^Isetf lua
line 282: 
line 283: " C or lpc
line 284: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 285: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 286: 
line 287: " Cairo
line 288: au BufNewFile,BufRead *.cairo^I^I^Isetf cairo
line 289: 
line 290: " Calendar
line 291: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 292: 
line 293: " Cap'n Proto
line 294: au BufNewFile,BufRead *.capnp^I^I^Isetf capnp
line 295: 
line 296: " C#
line 297: au BufNewFile,BufRead *.cs,*.csx^I^Isetf cs
line 298: 
line 299: " CSDL
line 300: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 301: 
line 302: " Cabal
line 303: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 304: 
line 305: " Cdrdao TOC
line 306: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 307: 
line 308: " Cdrdao config
line 309: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 310: 
line 311: " Cfengine
line 312: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 313: 
line 314: " ChaiScript
line 315: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 316: 
line 317: " Chatito
line 318: au BufNewFile,BufRead *.chatito^I^I^Isetf chatito
line 319: 
line 320: " Comshare Dimension Definition Language
line 321: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 322: 
line 323: " Conary Recipe
line 324: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 325: 
line 326: " Corn config file
line 327: au BufNewFile,BufRead *.corn^I^I^Isetf corn
line 328: 
line 329: " ChainPack Object Notation (CPON)
line 330: au BufNewFile,BufRead *.cpon^I^I^Isetf cpon
line 331: 
line 332: " Controllable Regex Mutilator
line 333: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 334: 
line 335: " Cyn++
line 336: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 337: 
line 338: " Cynlib
line 339: " .cc and .cpp files can be C++ or Cynlib.
line 340: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 342: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 344: 
line 345: " Cypher query language
line 346: au BufNewFile,BufRead *.cypher^I^I^Isetf cypher
line 347: 
line 348: " C++
line 349: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 350: if has("fname_case")
line 351:   au BufNewFile,BufRead *.C,*.H setf cpp
line 352: endif
line 353: 
line 354: " C++ 20 modules (clang)
line 355: " https://clang.llvm.org/docs/StandardCPlusPlusModules.html#file-name-requirement
line 356: au BufNewFile,BufRead *.cppm,*.ccm,*.cxxm,*.c++m setf cpp
line 357: 
line 358: " .h files can be C, Ch C++, ObjC or ObjC++.
line 359: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 360: " detected automatically.
line 361: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 362: 
line 363: " Ch (CHscript)
line 364: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 365: 
line 366: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 367: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 368: 
line 369: " Cascading Style Sheets
line 370: au BufNewFile,BufRead *.css^I^I^Isetf css
line 371: 
line 372: " Century Term Command Scripts (*.cmd too)
line 373: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 374: 
line 375: " Changelog
line 376: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog^Isetf debchangelog
line 378: 
line 379: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 385: 
line 386: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 390: 
line 391: " CHILL
line 392: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 393: 
line 394: " Changes for WEB and CWEB or CHILL
line 395: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 396: 
line 397: " ChordPro
line 398: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 399: 
line 400: " Clangd
line 401: au BufNewFile,BufRead .clangd^I^I^Isetf yaml
line 402: 
line 403: " Clang-format
line 404: au BufNewFile,BufRead .clang-format^I^Isetf yaml
line 405: 
line 406: " Clang-tidy
line 407: au BufNewFile,BufRead .clang-tidy^I^Isetf yaml
line 408: 
line 409: " Clean
line 410: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 411: 
line 412: " Clever
line 413: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 414: 
line 415: " Clever or dtd
line 416: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 417: 
line 418: " Clipper, FoxPro, ABB RAPID or eviews
line 419: au BufNewFile,BufRead *.prg\c^I^I^Icall dist#ft#FTprg()
line 420: 
line 421: " Clojure
line 422: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 423: 
line 424: " Cmake
line 425: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 426: 
line 427: " Cmusrc
line 428: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 429: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 430: 
line 431: " Cobol
line 432: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 433: "   cobol or zope form controller python script? (heuristic)
line 434: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 440: 
line 441: " Coco/R
line 442: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 443: 
line 444: " Cold Fusion
line 445: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 446: 
line 447: " Configure scripts
line 448: au BufNewFile,BufRead configure.in,configure.ac setf config
line 449: 
line 450: " Cooklang
line 451: au BufNewFile,BufRead *.cook^I^I^Isetf cook
line 452: 
line 453: " Clinical Quality Language (CQL)
line 454: " .cql is also mentioned as the 'XDCC Catcher queue list' file extension.
line 455: " If support for XDCC Catcher is needed in the future, the contents of the file
line 456: " needs to be inspected.
line 457: au BufNewFile,BufRead *.cql^I^I^Isetf cqlang
line 458: 
line 459: " Crystal
line 460: au BufNewFile,BufRead *.cr^I^I^Isetf crystal
line 461: 
line 462: " CSV Files
line 463: au BufNewFile,BufRead *.csv^I^I^Isetf csv
line 464: 
line 465: " CUDA Compute Unified Device Architecture
line 466: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 467: 
line 468: " Cue
line 469: au BufNewFile,BufRead *.cue^I^I^Isetf cue
line 470: 
line 471: " Dockerfile; Podman uses the same syntax with name Containerfile
line 472: " Also see Dockerfile.* below.
line 473: au BufNewFile,BufRead Containerfile,Dockerfile,dockerfile,*.[dD]ockerfile^Isetf dockerfile
line 474: 
line 475: " WildPackets EtherPeek Decoder
line 476: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 477: 
line 478: " Enlightenment configuration files
line 479: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 480: 
line 481: " Eterm
line 482: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 483: 
line 484: " Elixir or Euphoria
line 485: au BufNewFile,BufRead *.ex call dist#ft#ExCheck()
line 486: 
line 487: " Elixir
line 488: au BufRead,BufNewFile mix.lock,*.exs setf elixir
line 489: au BufRead,BufNewFile *.eex,*.leex setf eelixir
line 490: 
line 491: " Elvish
line 492: au BufRead,BufNewFile *.elv setf elvish
line 493: 
line 494: " Euphoria 3 or 4
line 495: au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 496: if has("fname_case")
line 497:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 498: endif
line 499: 
line 500: " Lynx config files
line 501: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 502: 
line 503: " LyRiCs
line 504: au BufNewFile,BufRead *.lrc^I^I^Isetf lyrics
line 505: 
line 506: " Modula-3 configuration language (must be before *.cfg and *makefile)
line 507: au BufNewFile,BufRead *.quake,cm3.cfg^I^Isetf m3quake
line 508: au BufNewFile,BufRead m3makefile,m3overrides^Isetf m3build
line 509: 
line 510: " Quake
line 511: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 512: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 513: 
line 514: " Quake C
line 515: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 516: 
line 517: " Configure files
line 518: au BufNewFile,BufRead *.cfg\c^I^I^Icall dist#ft#FTcfg()
line 519: 
line 520: " Cucumber
line 521: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 522: 
line 523: " Communicating Sequential Processes
line 524: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 525: 
line 526: " CUPL logic description and simulation
line 527: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 528: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 529: 
line 530: " Dart
line 531: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart
line 532: 
line 533: " Debian Control
line 534: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 535: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 539: 
line 540: " Debian Copyright
line 541: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 542: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 546: 
line 547: " Debian Sources.list
line 548: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 549: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 550: au BufNewFile,BufRead */etc/apt/sources.list.d/*.sources^Isetf deb822sources
line 551: 
line 552: " Deny hosts
line 553: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 554: 
line 555: " Dhall
line 556: au BufNewFile,BufRead *.dhall^I^I^Isetf dhall
line 557: 
line 558: " dnsmasq(8) configuration files
line 559: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 560: 
line 561: " ROCKLinux package description
line 562: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 563: 
line 564: " the D language or dtrace
line 565: au BufNewFile,BufRead */dtrace/*.d^I^Isetf dtrace
line 566: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 567: 
line 568: " Desktop files
line 569: au BufNewFile,BufRead *.desktop,*.directory^Isetf desktop
line 570: 
line 571: " Dict config
line 572: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 573: 
line 574: " Dictd config
line 575: au BufNewFile,BufRead dictd*.conf^I^Isetf dictdconf
line 576: 
line 577: " DEP3 formatted patch files
line 578: au BufNewFile,BufRead */debian/patches/*^Icall dist#ft#Dep3patch()
line 579: 
line 580: " Diff files
line 581: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 582: au BufNewFile,BufRead *.patch if getline(1) =~# '^From [0-9a-f]\{40,\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 588: 
line 589: " Dircolors
line 590: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 591: 
line 592: " Diva (with Skill) or InstallShield
line 593: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 599: 
line 600: " DCL (Digital Command Language - vms) or DNS zone file
line 601: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 602: 
line 603: " DOT
line 604: au BufNewFile,BufRead *.dot,*.gv^I^Isetf dot
line 605: 
line 606: " Dune
line 607: au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace setf dune
line 608: 
line 609: " Dylan - lid files
line 610: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 611: 
line 612: " Dylan - intr files (melange)
line 613: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 614: 
line 615: " Dylan
line 616: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 617: 
line 618: " Microsoft Module Definition
line 619: au BufNewFile,BufRead *.def^I^I^Isetf def
line 620: 
line 621: " Dracula
line 622: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 623: 
line 624: " Datascript
line 625: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 626: 
line 627: " dsl: DSSSL or Structurizr
line 628: au BufNewFile,BufRead *.dsl if getline(1) =~ '^\s*<\!' |   setf dsl | else |   setf structurizr | endif
line 634: 
line 635: " DTD (Document Type Definition for XML)
line 636: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 637: 
line 638: " DTS/DSTI (device tree files)
line 639: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 640: 
line 641: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 642: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 643: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 649: 
line 650: " EditorConfig
line 651: au BufNewFile,BufRead .editorconfig^I^Isetf editorconfig
line 652: 
line 653: " Embedix Component Description
line 654: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 655: 
line 656: " Eiffel or Specman or Euphoria
line 657: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 658: 
line 659: " Elinks configuration
line 660: au BufNewFile,BufRead elinks.conf^I^Isetf elinks
line 661: 
line 662: " ERicsson LANGuage; Yaws is erlang too
line 663: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 664: 
line 665: " Elm
line 666: au BufNewFile,BufRead *.elm^I^I^Isetf elm
line 667: 
line 668: " Elm Filter Rules file
line 669: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 670: 
line 671: " Elsa - https://github.com/ucsd-progsys/elsa
line 672: au BufNewFile,BufRead *.lc^I^I^Isetf elsa
line 673: 
line 674: " EdgeDB Schema Definition Language
line 675: au BufNewFile,BufRead *.esdl^I^I^Isetf esdl
line 676: 
line 677: " ESMTP rc file
line 678: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 679: 
line 680: " ESQL-C
line 681: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 682: 
line 683: " Esterel
line 684: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 685: 
line 686: " Essbase script
line 687: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 688: 
line 689: " Exim
line 690: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 691: 
line 692: " Expect
line 693: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 694: 
line 695: " Exports
line 696: au BufNewFile,BufRead exports^I^I^Isetf exports
line 697: 
line 698: " Falcon
line 699: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 700: 
line 701: " Fantom
line 702: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 703: 
line 704: " Factor
line 705: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 706: 
line 707: " Fennel
line 708: autocmd BufRead,BufNewFile *.fnl^I^Isetf fennel
line 709: 
line 710: " Fetchmail RC file
line 711: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 712: 
line 713: " FIRRTL - Flexible Internal Representation for RTL
line 714: au BufNewFile,BufRead *.fir^I^I^Isetf firrtl
line 715: 
line 716: " Fish shell
line 717: au BufNewFile,BufRead *.fish^I^I^Isetf fish
line 718: 
line 719: " FlexWiki - disabled, because it has side effects when a .wiki file
line 720: " is not actually FlexWiki
line 721: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 722: 
line 723: " Focus Executable
line 724: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 725: 
line 726: " Focus Master file (but not for auto.master)
line 727: au BufNewFile,BufRead auto.master^I^Isetf conf
line 728: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 729: 
line 730: " Forth
line 731: au BufNewFile,BufRead *.ft,*.fth,*.4th^I^Isetf forth
line 732: 
line 733: " Reva Forth
line 734: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 735: 
line 736: " Fortran
line 737: if has("fname_case")
line 738:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^Isetf fortran
line 739: endif
line 740: au BufNewFile,BufRead *.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08^Isetf fortran
line 741: 
line 742: " Fortran or Forth
line 743: au BufNewFile,BufRead *.f^I^I^Icall dist#ft#FTf()
line 744: 
line 745: " Framescript
line 746: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 747: 
line 748: " FStab
line 749: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 750: 
line 751: " Func
line 752: au BufNewFile,BufRead *.fc^I^I^Isetf func
line 753: 
line 754: " Fusion
line 755: au BufRead,BufNewFile *.fusion^I^I^Isetf fusion
line 756: 
line 757: " F# or Forth
line 758: au BufNewFile,BufRead *.fs^I^I^Icall dist#ft#FTfs()
line 759: 
line 760: " FHIR Shorthand (FSH)
line 761: au BufNewFile,BufRead *.fsh^I^I^Isetf fsh
line 762: 
line 763: " F#
line 764: au BufNewFile,BufRead *.fsi,*.fsx^I^Isetf fsharp
line 765: 
line 766: " GDB command files
line 767: au BufNewFile,BufRead .gdbinit,gdbinit,.gdbearlyinit,gdbearlyinit,*.gdb^I^Isetf gdb
line 768: 
line 769: " GDMO
line 770: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 771: 
line 772: " GDscript
line 773: au BufNewFile,BufRead *.gd^I^I^Isetf gdscript
line 774: 
line 775: " Godot resource
line 776: au BufRead,BufNewFile *.tscn,*.tres^I^Isetf gdresource
line 777: 
line 778: " Godot shader
line 779: au BufRead,BufNewFile *.gdshader,*.shader^Isetf gdshader
line 780: 
line 781: " Gedcom
line 782: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 783: 
line 784: " Gemtext
line 785: au BufNewFile,BufRead *.gmi,*.gemini^I^Isetf gemtext
line 786: 
line 787: " Gift (Moodle)
line 788: autocmd BufRead,BufNewFile *.gift^I^Isetf gift
line 789: 
line 790: " Git
line 791: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG^Isetf gitcommit
line 792: au BufNewFile,BufRead NOTES_EDITMSG,EDIT_DESCRIPTION^I^Isetf gitcommit
line 793: au BufNewFile,BufRead *.git/config,.gitconfig,*/etc/gitconfig^Isetf gitconfig
line 794: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 795: au BufNewFile,BufRead *.git/config.worktree^I^I^Isetf gitconfig
line 796: au BufNewFile,BufRead *.git/worktrees/*/config.worktree^I^Isetf gitconfig
line 797: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 798: if exists('$XDG_CONFIG_HOME')
line 799:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 800:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/attributes^I^Isetf gitattributes
line 801:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/ignore^I^Isetf gitignore
line 802: endif
line 803: au BufNewFile,BufRead .gitattributes,*.git/info/attributes^Isetf gitattributes
line 804: au BufNewFile,BufRead */.config/git/attributes^I^I^Isetf gitattributes
line 805: au BufNewFile,BufRead */etc/gitattributes^I^I^Isetf gitattributes
line 806: au BufNewFile,BufRead .gitignore,*.git/info/exclude^I^Isetf gitignore
line 807: au BufNewFile,BufRead */.config/git/ignore^I^I^Isetf gitignore
line 808: au BufNewFile,BufRead git-rebase-todo^I^I^I^Isetf gitrebase
line 809: au BufRead,BufNewFile .gitsendemail.msg.??????^I^I^Isetf gitsendemail
line 810: au BufNewFile,BufRead *.git/* if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |   setf git | endif
line 814: 
line 815: " Gkrellmrc
line 816: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 817: 
line 818: " Gleam
line 819: au BufNewFile,BufRead *.gleam^I^I^Isetf gleam
line 820: 
line 821: " GLSL
line 822: au BufNewFile,BufRead *.glsl^I^I^Isetf glsl
line 823: 
line 824: " GN (generate ninja) files
line 825: au BufNewFile,BufRead *.gn,*.gni^I^Isetf gn
line 826: 
line 827: " GP scripts (2.0 and onward)
line 828: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 829: 
line 830: " GPG
line 831: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 832: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 833: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 834: if !empty($GNUPGHOME)
line 835:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 836:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 837: endif
line 838: 
line 839: " gnash(1) configuration files
line 840: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 841: 
line 842: " Gitolite
line 843: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 844: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 845: 
line 846: " Glimmer-flavored TypeScript and JavaScript
line 847: au BufNewFile,BufRead *.gts^I^I^Isetf typescript.glimmer
line 848: au BufNewFile,BufRead *.gjs^I^I^Isetf javascript.glimmer
line 849: 
line 850: " Gnuplot scripts
line 851: au BufNewFile,BufRead *.gpi,.gnuplot^I^Isetf gnuplot
line 852: 
line 853: " Go (Google)
line 854: au BufNewFile,BufRead *.go^I^I^Isetf go
line 855: au BufNewFile,BufRead Gopkg.lock^I^Isetf toml
line 856: au BufRead,BufNewFile go.work^I^I^Isetf gowork
line 857: 
line 858: " GrADS scripts
line 859: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 860: 
line 861: " GraphQL
line 862: au BufNewFile,BufRead *.graphql,*.graphqls,*.gql^I^I^Isetf graphql
line 863: 
line 864: " Gretl
line 865: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 866: 
line 867: " Groovy
line 868: au BufNewFile,BufRead *.gradle,*.groovy,Jenkinsfile^I^Isetf groovy
line 869: 
line 870: " GNU Server Pages
line 871: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 872: 
line 873: " Group file
line 874: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 875: 
line 876: " GTK RC
line 877: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 878: 
line 879: " GYP
line 880: au BufNewFile,BufRead *.gyp,*.gypi^I^Isetf gyp
line 881: 
line 882: " Hack
line 883: au BufRead,BufNewFile *.hack,*.hackpartial^I^I^Isetf hack
line 884: 
line 885: " Haml
line 886: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 887: 
line 888: " Hamster Classic | Playground files
line 889: au BufNewFile,BufRead *.hsm^I^I^Isetf hamster
line 890: 
line 891: " Handlebars
line 892: au BufNewFile,BufRead *.hbs^I^I^Isetf handlebars
line 893: 
line 894: " Hare
line 895: au BufNewFile,BufRead *.ha^I^I^Isetf hare
line 896: 
line 897: " Haskell
line 898: au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell
line 899: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 900: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 901: au BufNewFile,BufRead cabal.project^I^Isetf cabalproject
line 902: au BufNewFile,BufRead $HOME/.cabal/config^Isetf cabalconfig
line 903: if exists('$XDG_CONFIG_HOME')
line 904:   au BufNewFile,BufRead $XDG_CONFIG_HOME/cabal/config setf cabalconfig
line 905: endif
line 906: au BufNewFile,BufRead $HOME/.config/cabal/config setf cabalconfig
line 907: au BufNewFile,BufRead cabal.config^I^Isetf cabalconfig
line 908: au BufNewFile,BufRead *.persistentmodels^Isetf haskellpersistent
line 909: 
line 910: " Haste
line 911: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 912: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 913: 
line 914: " HCL
line 915: au BufRead,BufNewFile *.hcl^I^I^Isetf hcl
line 916: 
line 917: " Go checksum file (must be before *.sum Hercules)
line 918: au BufNewFile,BufRead go.sum,go.work.sum^Isetf gosum
line 919: 
line 920: " Hercules
line 921: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 922: 
line 923: " HEEx
line 924: au BufRead,BufNewFile *.heex^I^I^Isetf heex
line 925: 
line 926: " HEX (Intel)
line 927: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 928: 
line 929: " Hjson
line 930: au BufNewFile,BufRead *.hjson^I^I^Isetf hjson
line 931: 
line 932: " HLS Playlist (or another form of playlist)
line 933: au BufNewFile,BufRead *.m3u,*.m3u8^I^Isetf hlsplaylist
line 934: 
line 935: " Hollywood
line 936: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood
line 937: 
line 938: " Hoon
line 939: au BufRead,BufNewFile *.hoon^I^I^Isetf hoon
line 940: 
line 941: " Tilde (must be before HTML)
line 942: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 943: 
line 944: " HTML (.shtml and .stm for server side)
line 945: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 946: au BufNewFile,BufRead *.cshtml^I^I^Isetf html
line 947: 
line 948: " HTML with Ruby - eRuby
line 949: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 950: 
line 951: " HTML with M4
line 952: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 953: 
line 954: " Some template.  Used to be HTML Cheetah.
line 955: au BufNewFile,BufRead *.tmpl^I^I^Isetf template
line 956: 
line 957: " Host config
line 958: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 959: 
line 960: " Hosts access
line 961: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 962: 
line 963: " Hurl
line 964: au BufRead,BufNewFile *.hurl^I^I^Isetf hurl
line 965: 
line 966: " Hyper Builder
line 967: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 968: 
line 969: " Httest
line 970: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 971: 
line 972: " i3
line 973: au BufNewFile,BufRead */i3/config^I^Isetf i3config
line 974: au BufNewFile,BufRead */.i3/config^I^Isetf i3config
line 975: 
line 976: " sway
line 977: au BufNewFile,BufRead */sway/config^I^Isetf swayconfig
line 978: au BufNewFile,BufRead */.sway/config^I^Isetf swayconfig
line 979: 
line 980: " Icon
line 981: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 982: 
line 983: " IDL (Interface Description Language)
line 984: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 985: 
line 986: " Microsoft IDL (Interface Description Language)  Also *.idl
line 987: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 988: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 989: 
line 990: " Icewm menu
line 991: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 992: 
line 993: " Indent profile (must come before IDL *.pro!)
line 994: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 995: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 996: 
line 997: " IDL (Interactive Data Language)
line 998: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 999: 
line 1000: " Indent RC
line 1001: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 1002: 
line 1003: " Inform
line 1004: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 1005: 
line 1006: " Initng
line 1007: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 1008: 
line 1009: " Innovation Data Processing
line 1010: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c^Isetf upstreamdat
line 1011: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c^Isetf upstreamlog
line 1012: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 1013: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c^Isetf usserverlog
line 1014: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c^Isetf usw2kagtlog
line 1015: 
line 1016: " Ipfilter
line 1017: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 1018: 
line 1019: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 1020: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 1021: 
line 1022: " .INI file for MSDOS
line 1023: au BufNewFile,BufRead *.ini,*.INI^I^Isetf dosini
line 1024: 
line 1025: " SysV Inittab
line 1026: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 1027: 
line 1028: " Inno Setup
line 1029: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 1030: 
line 1031: " J
line 1032: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 1033: 
line 1034: " JAL
line 1035: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 1036: 
line 1037: " Jam
line 1038: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 1039: 
line 1040: " Janet
line 1041: au BufNewFile,BufRead *.janet^I^I^Isetf janet
line 1042: 
line 1043: " Java
line 1044: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 1045: 
line 1046: " JavaCC
line 1047: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1048: 
line 1049: " JavaScript, ECMAScript, ES module script, CommonJS script
line 1050: au BufNewFile,BufRead *.js,*.jsm,*.javascript,*.es,*.mjs,*.cjs   setf javascript
line 1051: 
line 1052: " JavaScript with React
line 1053: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact
line 1054: 
line 1055: " Java Server Pages
line 1056: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1057: 
line 1058: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1059: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1060: " Eclipse preference files use Java Properties syntax
line 1061: au BufNewFile,BufRead org.eclipse.*.prefs^Isetf jproperties
line 1062: 
line 1063: " Jess
line 1064: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1065: 
line 1066: " Jgraph
line 1067: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1068: 
line 1069: " Jovial
line 1070: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1071: 
line 1072: " Jq
line 1073: au BufNewFile,BufRead *.jq^I^I^Isetf jq
line 1074: 
line 1075: " JSON5
line 1076: au BufNewFile,BufRead *.json5^I^I^Isetf json5
line 1077: 
line 1078: " JSON Patch (RFC 6902)
line 1079: au BufNewFile,BufRead *.json-patch^I^Isetf json
line 1080: 
line 1081: " Geojson is also json
line 1082: au BufNewFile,BufRead *.geojson^I^I^Isetf json
line 1083: 
line 1084: " Jupyter Notebook is also json
line 1085: au BufNewFile,BufRead *.ipynb^I^I^Isetf json
line 1086: 
line 1087: " Other files that look like json
line 1088: au BufNewFile,BufRead .prettierrc,.firebaserc,.stylelintrc^Isetf json
line 1089: 
line 1090: " JSONC (JSON with comments)
line 1091: au BufNewFile,BufRead *.jsonc,.babelrc,.eslintrc,.jsfmtrc^Isetf jsonc
line 1092: au BufNewFile,BufRead .jshintrc,.hintrc,.swrc,[jt]sconfig*.json^Isetf jsonc
line 1093: 
line 1094: " JSON
line 1095: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 1096: 
line 1097: " JSON Lines
line 1098: au BufNewFile,BufRead *.jsonl^I^I^Isetf jsonl
line 1099: 
line 1100: " Jsonnet
line 1101: au BufNewFile,BufRead *.jsonnet,*.libsonnet^Isetf jsonnet
line 1102: 
line 1103: " Julia
line 1104: au BufNewFile,BufRead *.jl^I^I^Isetf julia
line 1105: 
line 1106: " Just
line 1107: au BufNewFile,BufRead [jJ]ustfile,.justfile,*.just setf just
line 1108: 
line 1109: " KDL
line 1110: au BufNewFile,BufRead *.kdl^I^I^Isetf kdl
line 1111: 
line 1112: " Kixtart
line 1113: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1114: 
line 1115: " Kuka Robot Language
line 1116: au BufNewFile,BufRead *.src\c^I^I^Icall dist#ft#FTsrc()
line 1117: au BufNewFile,BufRead *.dat\c^I^I^Icall dist#ft#FTdat()
line 1118: au BufNewFile,BufRead *.sub\c^I^I^Isetf krl
line 1119: 
line 1120: " Kimwitu[++]
line 1121: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1122: 
line 1123: " Kivy
line 1124: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1125: 
line 1126: " Kotlin
line 1127: au BufNewFile,BufRead *.kt,*.ktm,*.kts^I^Isetf kotlin
line 1128: 
line 1129: " KDE script
line 1130: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1131: 
line 1132: " Kconfig
line 1133: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1134: 
line 1135: " Lace (ISE)
line 1136: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1137: 
line 1138: " Larch Shared Language
line 1139: au BufNewFile,BufRead .lsl^I^I^Icall dist#ft#FTlsl()
line 1140: 
line 1141: " Latexmkrc
line 1142: au BufNewFile,BufRead .latexmkrc,latexmkrc^Isetf perl
line 1143: 
line 1144: " Latte
line 1145: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1146: 
line 1147: " Limits
line 1148: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1149: 
line 1150: " LambdaProlog or SML (see dist#ft#FTmod for *.mod)
line 1151: au BufNewFile,BufRead *.sig^I^I^Icall dist#ft#FTsig()
line 1152: 
line 1153: " LDAP LDIF
line 1154: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1155: 
line 1156: " Ld loader
line 1157: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1158: 
line 1159: " Lean
line 1160: au BufNewFile,BufRead *.lean^I^I^Isetf lean
line 1161: 
line 1162: " Ledger
line 1163: au BufRead,BufNewFile *.ldg,*.ledger,*.journal^I^I^Isetf ledger
line 1164: 
line 1165: " Less
line 1166: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1167: 
line 1168: " Lex
line 1169: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1170: 
line 1171: " Libao
line 1172: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1173: 
line 1174: " Libsensors
line 1175: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1176: 
line 1177: " LFTP
line 1178: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1179: 
line 1180: " Lifelines (or Lex for C++!)
line 1181: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1182: 
line 1183: " Lilo: Linux loader
line 1184: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1185: 
line 1186: " Lilypond
line 1187: au BufNewFile,BufRead *.ly,*.ily^I^Isetf lilypond
line 1188: 
line 1189: " Lisp (*.el = ELisp, *.cl = Common Lisp)
line 1190: " *.jl was removed, it's also used for Julia, better skip than guess wrong.
line 1191: if has("fname_case")
line 1192:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp
line 1193: else
line 1194:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,.emacs,.sawfishrc setf lisp
line 1195: endif
line 1196: 
line 1197: " SBCL implementation of Common Lisp
line 1198: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1199: 
line 1200: " Liquidsoap
line 1201: au BufNewFile,BufRead *.liq^I^I^Isetf liquidsoap
line 1202: 
line 1203: " Liquid
line 1204: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1205: 
line 1206: " Lite
line 1207: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1208: 
line 1209: " LiteStep RC files
line 1210: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1211: 
line 1212: " Livebook
line 1213: au BufNewFile,BufRead *.livemd^I^I^Isetf livebook
line 1214: 
line 1215: " Login access
line 1216: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1217: 
line 1218: " Login defs
line 1219: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1220: 
line 1221: " Logtalk
line 1222: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1223: 
line 1224: " LOTOS
line 1225: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1226: 
line 1227: " Lout (also: *.lt)
line 1228: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1229: 
line 1230: " Lua
line 1231: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1232: 
line 1233: " Luau
line 1234: au BufNewFile,BufRead *.luau^I^Isetf luau
line 1235: 
line 1236: " Luacheck
line 1237: au BufNewFile,BufRead .luacheckrc^I^Isetf lua
line 1238: 
line 1239: " Luarocks
line 1240: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 1241: 
line 1242: " Linden Scripting Language (Second Life)
line 1243: au BufNewFile,BufRead *.lsl^I^I^Icall dist#ft#FTlsl()
line 1244: 
line 1245: " Lynx style file (or LotusScript!)
line 1246: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1247: 
line 1248: " M4
line 1249: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1251: 
line 1252: " MaGic Point
line 1253: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1254: 
line 1255: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 1256: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1257: 
line 1258: " Mail aliases
line 1259: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1260: 
line 1261: " Mailcap configuration file
line 1262: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1263: 
line 1264: " Makefile
line 1265: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1266: 
line 1267: " MakeIndex
line 1268: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1269: 
line 1270: " Mallard
line 1271: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1272: 
line 1273: " Manpage
line 1274: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1275: 
line 1276: " Man config
line 1277: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1278: 
line 1279: " Maple V
line 1280: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1281: 
line 1282: " Map (UMN mapserver config file)
line 1283: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1284: 
line 1285: " Markdown
line 1286: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 1287: 
line 1288: " Mason
line 1289: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 1290: 
line 1291: " Mathematica, Matlab, Murphi, Objective C or Octave
line 1292: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 1293: 
line 1294: " Mathematica notebook
line 1295: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1296: 
line 1297: " Maya Extension Language
line 1298: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1299: 
line 1300: " Mercurial (hg) commit file
line 1301: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1302: 
line 1303: " Mercurial config (looks like generic config file)
line 1304: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1305: 
line 1306: " Mermaid
line 1307: au BufNewFile,BufRead *.mmd,*.mmdc,*.mermaid^Isetf mermaid
line 1308: 
line 1309: " Meson Build system config
line 1310: au BufNewFile,BufRead meson.build,meson.options,meson_options.txt setf meson
line 1311: au BufNewFile,BufRead *.wrap^I^I^Isetf dosini
line 1312: 
line 1313: " Messages (logs mostly)
line 1314: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1315: 
line 1316: " Metafont
line 1317: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1318: 
line 1319: " MetaPost
line 1320: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1321: au BufNewFile,BufRead *.mpxl,*.mpiv,*.mpvi^Ilet b:mp_metafun = 1 | setf mp
line 1322: 
line 1323: " MGL
line 1324: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1325: 
line 1326: " MIX - Knuth assembly
line 1327: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1328: 
line 1329: " MMIX or VMS makefile
line 1330: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 1331: 
line 1332: " Symbian meta-makefile definition (MMP)
line 1333: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1334: 
line 1335: " ABB Rapid, Modula-2, Modsim III or LambdaProlog
line 1336: au BufNewFile,BufRead *.mod\c^I^I^Icall dist#ft#FTmod()
line 1337: 
line 1338: " Modula-2  (.md removed in favor of Markdown, see dist#ft#FTmod for *.MOD)
line 1339: au BufNewFile,BufRead *.m2,*.DEF,*.mi^I^Isetf modula2
line 1340: 
line 1341: " Modula-3 (.m3, .i3, .mg, .ig)
line 1342: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1343: 
line 1344: " Larch/Modula-3
line 1345: au BufNewFile,BufRead *.lm3^I^I^Isetf modula3
line 1346: 
line 1347: " Modconf
line 1348: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1349: 
line 1350: " Monk
line 1351: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1352: 
line 1353: " MOO
line 1354: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1355: 
line 1356: " Moonscript
line 1357: au BufNewFile,BufRead *.moon^I^I^Isetf moonscript
line 1358: 
line 1359: " Move language
line 1360: au BufNewFile,BufRead *.move^I^I^Isetf move
line 1361: 
line 1362: " MPD is based on XML
line 1363: au BufNewFile,BufRead *.mpd^I^I^Isetf xml
line 1364: 
line 1365: " Mplayer config
line 1366: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1367: 
line 1368: " Motorola S record
line 1369: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1370: 
line 1371: " Mrxvtrc
line 1372: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1373: 
line 1374: " Msql
line 1375: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1376: 
line 1377: " Mysql
line 1378: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1379: 
line 1380: " Tcl Shell RC file
line 1381: au BufNewFile,BufRead tclsh.rc^I^I^Isetf tcl
line 1382: 
line 1383: " M$ Resource files
line 1384: " /etc/Muttrc.d/file.rc is muttrc
line 1385: au BufNewFile,BufRead *.rc,*.rch if expand("<afile>") !~ "/etc/Muttrc.d/" |   setf rc | endif
line 1389: 
line 1390: " Mojo
line 1391: " Mojo files use either .mojo or . as extension
line 1392: au BufNewFile,BufRead *.mojo,*.^I^Isetf mojo
line 1393: 
line 1394: " MuPAD source
line 1395: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1396: 
line 1397: " Mush
line 1398: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1399: 
line 1400: " Mutt setup file (also for Muttng)
line 1401: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1402: 
line 1403: " N1QL
line 1404: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1405: 
line 1406: " Nano
line 1407: au BufNewFile,BufRead */etc/nanorc,*.nanorc^Isetf nanorc
line 1408: 
line 1409: " Nastran input/DMAP
line 1410: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1411: 
line 1412: " Natural
line 1413: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1414: 
line 1415: " Noemutt setup file
line 1416: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1417: 
line 1418: " Netrc
line 1419: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1420: 
line 1421: " Nginx
line 1422: au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf^I^I^Isetf nginx
line 1423: 
line 1424: " Nim file
line 1425: au BufNewFile,BufRead *.nim,*.nims,*.nimble^Isetf nim
line 1426: 
line 1427: " Ninja file
line 1428: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1429: 
line 1430: " Nix
line 1431: au BufRead,BufNewFile *.nix^I^I^Isetf nix
line 1432: 
line 1433: " Norg
line 1434: au BufNewFile,BufRead *.norg^I^Isetf norg
line 1435: 
line 1436: " NPM RC file
line 1437: au BufNewFile,BufRead npmrc,.npmrc^I^Isetf dosini
line 1438: 
line 1439: " Novell netware batch files
line 1440: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1441: 
line 1442: " Nroff/Troff (*.ms and *.t are checked below)
line 1443: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1447: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1448: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1449: 
line 1450: " Nroff or Objective C++
line 1451: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1452: 
line 1453: " Not Quite C
line 1454: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1455: 
line 1456: " NSE - Nmap Script Engine - uses Lua syntax
line 1457: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1458: 
line 1459: " NSIS
line 1460: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1461: 
line 1462: " Nu
line 1463: au BufNewFile,BufRead {env,config}.nu^I^Isetf nu
line 1464: 
line 1465: " Oblivion Language and Oblivion Script Extender
line 1466: au BufNewFile,BufRead *.obl,*.obse,*.oblivion,*.obscript  setf obse
line 1467: 
line 1468: " Objdump
line 1469: au BufNewFile,BufRead *.objdump,*.cppobjdump  setf objdump
line 1470: 
line 1471: " OCaml
line 1472: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml
line 1473: 
line 1474: " Occam
line 1475: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1476: 
line 1477: " Octave
line 1478: au BufNewFile,BufRead octave.conf,.octaverc,octaverc^Isetf octave
line 1479: 
line 1480: " Odin
line 1481: au BufNewFile,BufRead *.odin^I^I^Isetf odin
line 1482: 
line 1483: " Omnimark
line 1484: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1485: 
line 1486: " OPAM
line 1487: au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam
line 1488: 
line 1489: " OpenFOAM
line 1490: au BufNewFile,BufRead [a-zA-Z0-9]*Dict\(.*\)\=,[a-zA-Z]*Properties\(.*\)\=,*Transport\(.*\),fvSchemes,fvSolution,fvConstrains,fvModels,*/constant/g,*/0\(\.orig\)\=/* call dist#ft#FTfoam()
line 1491: 
line 1492: " OpenROAD
line 1493: au BufNewFile,BufRead *.or^I^I^I^Isetf openroad
line 1494: 
line 1495: " OPL
line 1496: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^I^Isetf opl
line 1497: 
line 1498: " OpenSCAD
line 1499: au BufNewFile,BufRead *.scad^I^I^I^Isetf openscad
line 1500: 
line 1501: " Oracle config file
line 1502: au BufNewFile,BufRead *.ora^I^I^I^Isetf ora
line 1503: 
line 1504: " Org
line 1505: au BufNewFile,BufRead *.org,*.org_archive^I^Isetf org
line 1506: 
line 1507: " Packet filter conf
line 1508: au BufNewFile,BufRead pf.conf^I^I^I^Isetf pf
line 1509: 
line 1510: " ini style config files, using # comments
line 1511: au BufNewFile,BufRead */etc/pacman.conf,mpv.conf^Isetf confini
line 1512: au BufNewFile,BufRead */.aws/config,*/.aws/credentials^Isetf confini
line 1513: au BufNewFile,BufRead *.nmconnection^I^I^Isetf confini
line 1514: 
line 1515: " Pacman hooks
line 1516: au BufNewFile,BufRead *.hook if getline(1) == '[Trigger]' |   setf confini | endif
line 1520: 
line 1521: " Pam conf
line 1522: au BufNewFile,BufRead */etc/pam.conf^I^I^Isetf pamconf
line 1523: 
line 1524: " Pam environment
line 1525: au BufNewFile,BufRead pam_env.conf,.pam_environment^Isetf pamenv
line 1526: 
line 1527: " PApp
line 1528: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^I^Isetf papp
line 1529: 
line 1530: " Password file
line 1531: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1532: 
line 1533: " Pascal (also *.p, *.pp, *.inc)
line 1534: au BufNewFile,BufRead *.pas^I^I^I^Isetf pascal
line 1535: 
line 1536: " Pascal or Puppet manifest
line 1537: au BufNewFile,BufRead *.pp^I^I^I^Icall dist#ft#FTpp()
line 1538: 
line 1539: " Delphi or Lazarus program file
line 1540: au BufNewFile,BufRead *.dpr,*.lpr^I^I^Isetf pascal
line 1541: 
line 1542: " Free Pascal makefile definition file
line 1543: au BufNewFile,BufRead *.fpc^I^I^I^Isetf fpcmake
line 1544: 
line 1545: " Path of Exile item filter
line 1546: au BufNewFile,BufRead *.filter^I^I^I^Isetf poefilter
line 1547: 
line 1548: " PDF
line 1549: au BufNewFile,BufRead *.pdf^I^I^I^Isetf pdf
line 1550: 
line 1551: " PCMK - HAE - crm configure edit
line 1552: au BufNewFile,BufRead *.pcmk^I^I^I^Isetf pcmk
line 1553: 
line 1554: " PEM (Privacy-Enhanced Mail)
line 1555: au BufNewFile,BufRead *.pem,*.cer,*.crt,*.csr^I^Isetf pem
line 1556: 
line 1557: " Perl
line 1558: if has("fname_case")
line 1559:   au BufNewFile,BufRead *.pl,*.PL^I^I^Icall dist#ft#FTpl()
line 1560: else
line 1561:   au BufNewFile,BufRead *.pl^I^I^I^Icall dist#ft#FTpl()
line 1562: endif
line 1563: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^I^Isetf perl
line 1564: 
line 1565: " Perl, XPM or XPM2
line 1566: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1574: 
line 1575: " Perl POD
line 1576: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1577: 
line 1578: " Php, php3, php4, etc.
line 1579: " Also Phtml (was used for PHP 2 in the past).
line 1580: " Also .ctp for Cake template file.
line 1581: " Also .phpt for php tests.
line 1582: " Also .theme for Drupal theme files.
line 1583: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp,*.phpt,*.theme^Isetf php
line 1584: 
line 1585: " PHP config
line 1586: au BufNewFile,BufRead php.ini-*^I^I^Isetf dosini
line 1587: 
line 1588: " Pike and Cmod
line 1589: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1590: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1591: 
line 1592: " Pinfo config
line 1593: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1594: 
line 1595: " Palm Resource compiler
line 1596: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1597: 
line 1598: " Pine config
line 1599: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1600: 
line 1601: " Pip requirements
line 1602: au BufNewFile,BufRead *.pip^I^I^Isetf requirements
line 1603: au BufNewFile,BufRead requirements.txt^I^Isetf requirements
line 1604: 
line 1605: " Pipenv Pipfiles
line 1606: au BufNewFile,BufRead Pipfile^I^I^Isetf toml
line 1607: au BufNewFile,BufRead Pipfile.lock^I^Isetf json
line 1608: 
line 1609: " PL/1, PL/I
line 1610: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1611: 
line 1612: " PL/M (also: *.inp)
line 1613: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1614: 
line 1615: " PL/SQL
line 1616: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1617: 
line 1618: " PLP
line 1619: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1620: 
line 1621: " PO and PO template (GNU gettext)
line 1622: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1623: 
line 1624: " Pony
line 1625: au BufNewFile,BufRead *.pony^I^I^Isetf pony
line 1626: 
line 1627: " Postfix main config
line 1628: au BufNewFile,BufRead main.cf,main.cf.proto^Isetf pfmain
line 1629: 
line 1630: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1631: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1632: 
line 1633: " PostScript Printer Description
line 1634: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1635: 
line 1636: " Povray
line 1637: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1638: 
line 1639: " Povray configuration
line 1640: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1641: 
line 1642: " Povray, Pascal, PHP or assembly
line 1643: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1644: 
line 1645: " PowerShell
line 1646: au BufNewFile,BufRead^I*.ps1,*.psd1,*.psm1,*.pssc^Isetf ps1
line 1647: au BufNewFile,BufRead^I*.ps1xml^I^I^Isetf ps1xml
line 1648: au BufNewFile,BufRead^I*.cdxml,*.psc1^I^I^Isetf xml
line 1649: 
line 1650: " Printcap and Termcap
line 1651: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1653: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1655: 
line 1656: " Prisma
line 1657: au BufRead,BufNewFile *.prisma^I^I^Isetf prisma
line 1658: 
line 1659: " PCCTS / ANTLR
line 1660: "au BufNewFile,BufRead *.g^I^I^Isetf antlr
line 1661: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1662: 
line 1663: " PPWizard
line 1664: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1665: 
line 1666: " Pug
line 1667: au BufRead,BufNewFile *.pug^I^I^Isetf pug
line 1668: 
line 1669: " Puppet
line 1670: au BufNewFile,BufRead Puppetfile^I^Isetf ruby
line 1671: 
line 1672: " Embedded Puppet
line 1673: au BufNewFile,BufRead *.epp^I^I^Isetf epuppet
line 1674: 
line 1675: " Obj 3D file format
line 1676: " TODO: is there a way to avoid MS-Windows Object files?
line 1677: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1678: 
line 1679: " Oracle Pro*C/C++
line 1680: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1681: 
line 1682: " Privoxy actions file
line 1683: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1684: 
line 1685: " Procmail
line 1686: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1687: 
line 1688: " Progress or CWEB
line 1689: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1690: 
line 1691: " Progress or assembly or Swig
line 1692: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTi()
line 1693: 
line 1694: " Progress or Pascal
line 1695: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1696: 
line 1697: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1698: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1699: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1703: 
line 1704: " Prolog
line 1705: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1706: 
line 1707: " Promela
line 1708: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1709: 
line 1710: " Property Specification Language (PSL)
line 1711: au BufNewFile,BufRead *.psl^I^I^Isetf psl
line 1712: 
line 1713: " Google protocol buffers
line 1714: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1715: au BufNewFile,BufRead *.pbtxt^I^I^Isetf pbtxt
line 1716: 
line 1717: " Poke
line 1718: au BufNewFile,BufRead *.pk^I^I^Isetf poke
line 1719: 
line 1720: " Protocols
line 1721: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1722: 
line 1723: " PyPA manifest files
line 1724: au BufNewFile,BufRead MANIFEST.in^I^Isetf pymanifest
line 1725: 
line 1726: " Pyret
line 1727: au BufNewFile,BufRead *.arr^I^I^Isetf pyret
line 1728: 
line 1729: " Pyrex
line 1730: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1731: 
line 1732: " Python, Python Shell Startup and Python Stub Files
line 1733: " Quixote (Python-based web framework)
line 1734: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python
line 1735: au BufNewFile,BufRead *.ptl,*.pyi,SConstruct^I^I   setf python
line 1736: 
line 1737: " QL
line 1738: au BufRead,BufNewFile *.ql,*.qll^I^Isetf ql
line 1739: 
line 1740: " QML
line 1741: au BufRead,BufNewFile *.qml,*.qbs^I^I^Isetf qml
line 1742: 
line 1743: " QMLdir
line 1744: au BufRead,BufNewFile qmldir^I^I^Isetf qmldir
line 1745: 
line 1746: " Quarto
line 1747: au BufRead,BufNewFile *.qmd^I^I^Isetf quarto
line 1748: 
line 1749: " Racket (formerly detected as "scheme")
line 1750: au BufNewFile,BufRead *.rkt,*.rktd,*.rktl^Isetf racket
line 1751: 
line 1752: " Radiance
line 1753: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1754: 
line 1755: " Raku (formerly Perl6)
line 1756: au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku
line 1757: 
line 1758: " Ratpoison config/command files
line 1759: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1760: 
line 1761: " RCS file
line 1762: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1763: 
line 1764: " Readline
line 1765: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1766: 
line 1767: " Registry for MS-Windows
line 1768: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1770: 
line 1771: " Renderman Interface Bytestream
line 1772: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1773: 
line 1774: " Rego Policy Language
line 1775: au BufNewFile,BufRead *.rego^I^I^Isetf rego
line 1776: 
line 1777: " Rexx
line 1778: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1779: 
line 1780: " R Help file
line 1781: if has("fname_case")
line 1782:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1783: else
line 1784:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1785: endif
line 1786: 
line 1787: " R noweb file
line 1788: if has("fname_case")
line 1789:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1790: else
line 1791:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1792: endif
line 1793: 
line 1794: " R Markdown file
line 1795: if has("fname_case")
line 1796:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1797: else
line 1798:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1799: endif
line 1800: 
line 1801: " R profile file
line 1802: au BufNewFile,BufRead .Rprofile,Rprofile,Rprofile.site^Isetf r
line 1803: 
line 1804: " RSS looks like XML
line 1805: au BufNewFile,BufRead *.rss^I^I^I^Isetf xml
line 1806: 
line 1807: " R reStructuredText file
line 1808: if has("fname_case")
line 1809:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1810: else
line 1811:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1812: endif
line 1813: 
line 1814: " Rexx, Rebol or R
line 1815: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1816: 
line 1817: " Remind
line 1818: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1819: 
line 1820: " ReScript
line 1821: au BufNewFile,BufRead *.res,*.resi^I^I^Isetf rescript
line 1822: 
line 1823: " Resolv.conf
line 1824: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1825: 
line 1826: " Relax NG Compact
line 1827: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1828: 
line 1829: " Relax NG XML
line 1830: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1831: 
line 1832: " ILE RPG
line 1833: au BufNewFile,BufRead *.rpgle,*.rpgleinc^Isetf rpgle
line 1834: 
line 1835: " RPL/2
line 1836: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1837: 
line 1838: " Robot Framework
line 1839: au BufNewFile,BufRead *.robot,*.resource^Isetf robot
line 1840: 
line 1841: " Robots.txt
line 1842: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1843: 
line 1844: " RON (Rusty Object Notation)
line 1845: au BufNewFile,BufRead *.ron^I^I^Isetf ron
line 1846: 
line 1847: " MikroTik RouterOS script
line 1848: au BufRead,BufNewFile *.rsc^I^I^Isetf routeros
line 1849: 
line 1850: " Rpcgen
line 1851: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1852: 
line 1853: " reStructuredText Documentation Format
line 1854: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1855: 
line 1856: " RTF
line 1857: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1858: 
line 1859: " Interactive Ruby shell
line 1860: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1861: 
line 1862: " Ruby
line 1863: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1864: 
line 1865: " RubyGems
line 1866: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1867: 
line 1868: " RBS (Ruby Signature)
line 1869: au BufNewFile,BufRead *.rbs^I^I^Isetf rbs
line 1870: 
line 1871: " Rackup
line 1872: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1873: 
line 1874: " Bundler
line 1875: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1876: 
line 1877: " Ruby on Rails
line 1878: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1879: 
line 1880: " Rantfile and Rakefile is like Ruby
line 1881: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1882: 
line 1883: " Rust
line 1884: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1885: au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials^Isetf toml
line 1886: 
line 1887: " S-lang (or shader language, or SmallLisp)
line 1888: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1889: 
line 1890: " Sage
line 1891: au BufNewFile,BufRead *.sage^I^I^Isetf sage
line 1892: 
line 1893: " Samba config
line 1894: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1895: 
line 1896: " SAS script
line 1897: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1898: 
line 1899: " Sass
line 1900: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1901: 
line 1902: " Sather
line 1903: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1904: 
line 1905: " Scala
line 1906: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1907: 
line 1908: " SBT - Scala Build Tool
line 1909: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1910: 
line 1911: " SuperCollider
line 1912: au BufNewFile,BufRead *.sc^I^I^Icall dist#ft#FTsc()
line 1913: 
line 1914: au BufNewFile,BufRead *.quark^I^I^Isetf supercollider
line 1915: 
line 1916: " scdoc
line 1917: au BufNewFile,BufRead *.scd^I^I^Icall dist#ft#FTscd()
line 1918: 
line 1919: " Scilab
line 1920: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1921: 
line 1922: 
line 1923: " SCSS
line 1924: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1925: 
line 1926: " SD: Streaming Descriptors
line 1927: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1928: 
line 1929: " SDL
line 1930: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1931: 
line 1932: " sed
line 1933: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1934: 
line 1935: " SubRip
line 1936: au BufNewFile,BufRead *.srt^I^I^Isetf srt
line 1937: 
line 1938: " SubStation Alpha
line 1939: au BufNewFile,BufRead *.ass,*.ssa^I^Isetf ssa
line 1940: 
line 1941: " svelte
line 1942: au BufNewFile,BufRead *.svelte^I^I^Isetf svelte
line 1943: 
line 1944: " Sieve (RFC 3028, 5228)
line 1945: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1946: 
line 1947: " Sendmail
line 1948: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1949: 
line 1950: " Sendmail .mc files are actually m4.  Could also be MS Message text file or
line 1951: " Maxima.
line 1952: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1953: 
line 1954: " Services
line 1955: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1956: 
line 1957: " Service Location config
line 1958: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1959: 
line 1960: " Service Location registration
line 1961: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1962: 
line 1963: " Service Location SPI
line 1964: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1965: 
line 1966: " Setserial config
line 1967: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1968: 
line 1969: " SGML
line 1970: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1980: 
line 1981: " SGMLDECL
line 1982: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1986: 
line 1987: " SGML catalog file
line 1988: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1989: 
line 1990: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1991: " Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually
line 1992: " bash scripts.
line 1993: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 1994: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")
line 1995: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1996: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1997: 
line 1998: " Shell script (Arch Linux) or PHP file (Drupal)
line 1999: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 2005: 
line 2006: " tcsh scripts (patterns ending in a star further below)
line 2007: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 2008: 
line 2009: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 2010: " (patterns ending in a start further below)
line 2011: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 2012: 
line 2013: " Zig and Zig Object Notation (ZON)
line 2014: au BufNewFile,BufRead *.zig,*.zon^I^Isetf zig
line 2015: 
line 2016: " Zserio
line 2017: au BufNewFile,BufRead *.zs^I^I^Isetf zserio
line 2018: 
line 2019: " Z-Shell script (patterns ending in a star further below)
line 2020: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 2021: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
line 2022: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 2023: 
line 2024: " Scheme ("racket" patterns are now separate, see above)
line 2025: au BufNewFile,BufRead *.scm,*.ss,*.sld^I^Isetf scheme
line 2026: 
line 2027: " Screen RC
line 2028: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 2029: 
line 2030: " Sexplib
line 2031: au BufNewFile,BufRead *.sexp setf sexplib
line 2032: 
line 2033: " Simula
line 2034: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 2035: 
line 2036: " SINDA
line 2037: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 2038: 
line 2039: " SiSU
line 2040: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 2041: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 2042: 
line 2043: " SKILL
line 2044: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 2045: 
line 2046: " Cadence
line 2047: au BufNewFile,BufRead *.cdc^I^I^Isetf cdc
line 2048: 
line 2049: " SLRN
line 2050: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 2051: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 2052: 
line 2053: " Smali
line 2054: au BufNewFile,BufRead *.smali^I^I^Isetf smali
line 2055: 
line 2056: " Smalltalk
line 2057: au BufNewFile,BufRead *.st^I^I^Isetf st
line 2058: 
line 2059: " Smalltalk (and Rexx, TeX, and Visual Basic)
line 2060: au BufNewFile,BufRead *.cls^I^I^Icall dist#ft#FTcls()
line 2061: 
line 2062: " Smarty templates
line 2063: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 2064: 
line 2065: " SMIL or XML
line 2066: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2072: 
line 2073: " SMIL or SNMP MIB file
line 2074: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2080: 
line 2081: " SMITH
line 2082: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2083: 
line 2084: " Smithy
line 2085: au BufNewFile,BufRead *.smithy^I^I^Isetf smithy
line 2086: 
line 2087: " Snobol4 and spitbol
line 2088: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2089: 
line 2090: " SNMP MIB files
line 2091: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2092: 
line 2093: " Snort Configuration
line 2094: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2095: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 2096: 
line 2097: " Solidity
line 2098: au BufRead,BufNewFile *.sol^I^I^Isetf solidity
line 2099: 
line 2100: " SPARQL queries
line 2101: au BufNewFile,BufRead *.rq,*.sparql^I^Isetf sparql
line 2102: 
line 2103: " Spec (Linux RPM)
line 2104: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2105: 
line 2106: " Speedup (AspenTech plant simulator)
line 2107: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2108: 
line 2109: " Slice
line 2110: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2111: 
line 2112: " Microsoft Visual Studio Solution
line 2113: au BufNewFile,BufRead *.sln^I^I^Isetf solution
line 2114: au BufNewFile,BufRead *.slnf^I^I^Isetf json
line 2115: 
line 2116: " Spice
line 2117: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2118: 
line 2119: " Spyce
line 2120: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2121: 
line 2122: " Squid
line 2123: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2124: 
line 2125: " SQL for Oracle Designer
line 2126: au BufNewFile,BufRead *.tyb,*.tyc,*.pkb,*.pks^Isetf sql
line 2127: 
line 2128: " *.typ can be either SQL or Typst files
line 2129: au BufNewFile,BufRead *.typ^I^I^Icall dist#ft#FTtyp()
line 2130: 
line 2131: " SQL
line 2132: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 2133: 
line 2134: " SQLJ
line 2135: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2136: 
line 2137: " PRQL
line 2138: au BufNewFile,BufRead *.prql^I^I^Isetf prql
line 2139: 
line 2140: " SQR
line 2141: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2142: 
line 2143: " Squirrel
line 2144: au BufNewFile,BufRead *.nut^I^I^Isetf squirrel
line 2145: 
line 2146: " OpenSSH configuration
line 2147: au BufNewFile,BufRead ssh_config,*/.ssh/config,*/.ssh/*.conf^Isetf sshconfig
line 2148: au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf^I^Isetf sshconfig
line 2149: 
line 2150: " OpenSSH server configuration
line 2151: au BufNewFile,BufRead sshd_config^I^I^Isetf sshdconfig
line 2152: au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf^Isetf sshdconfig
line 2153: 
line 2154: " Starlark
line 2155: au BufNewFile,BufRead *.ipd,*.star,*.starlark^Isetf starlark
line 2156: 
line 2157: " OpenVPN configuration
line 2158: au BufNewFile,BufRead *.ovpn^I^I^Isetf openvpn
line 2159: au BufNewFile,BufRead */openvpn/*/*.conf^Isetf openvpn
line 2160: 
line 2161: " Stata
line 2162: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 2163: " Also *.class, but not when it's a Java bytecode file
line 2164: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 2166: 
line 2167: " SMCL
line 2168: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2169: 
line 2170: " Stored Procedures
line 2171: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2172: 
line 2173: " Standard ML
line 2174: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2175: 
line 2176: " Sratus VOS command macro
line 2177: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2178: 
line 2179: " Swift
line 2180: au BufNewFile,BufRead *.swift^I^I^Isetf swift
line 2181: au BufNewFile,BufRead *.swift.gyb^I^Isetf swiftgyb
line 2182: 
line 2183: " Swift Intermediate Language or SILE
line 2184: au BufNewFile,BufRead *.sil^I^I^Icall dist#ft#FTsil()
line 2185: 
line 2186: " Swig
line 2187: au BufNewFile,BufRead *.swg,*.swig setf swig
line 2188: 
line 2189: " Sysctl
line 2190: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2191: 
line 2192: " Systemd unit files
line 2193: au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}^Isetf systemd
line 2194: " Systemd overrides
line 2195: au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf^Isetf systemd
line 2196: au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf^Isetf systemd
line 2197: au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf^Isetf systemd
line 2198: " Systemd temp files
line 2199: au BufNewFile,BufRead */etc/systemd/system/*.d/.#*^Isetf systemd
line 2200: au BufNewFile,BufRead */etc/systemd/system/.#*^I^Isetf systemd
line 2201: au BufNewFile,BufRead */.config/systemd/user/*.d/.#*^Isetf systemd
line 2202: au BufNewFile,BufRead */.config/systemd/user/.#*^Isetf systemd
line 2203: 
line 2204: " Synopsys Design Constraints
line 2205: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2206: 
line 2207: " Sudoers
line 2208: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2209: 
line 2210: " SVG (Scalable Vector Graphics)
line 2211: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2212: 
line 2213: " Surface
line 2214: au BufRead,BufNewFile *.sface^I^I^Isetf surface
line 2215: 
line 2216: " LLVM TableGen
line 2217: au BufNewFile,BufRead *.td^I^I^Isetf tablegen
line 2218: 
line 2219: " Tads (or Nroff or Perl test file)
line 2220: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 2222: 
line 2223: " Tags
line 2224: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2225: 
line 2226: " TAK
line 2227: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2228: 
line 2229: " Unx Tal
line 2230: au BufNewFile,BufRead *.tal^I^I^Isetf tal
line 2231: 
line 2232: " Task
line 2233: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2234: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2235: 
line 2236: " Tcl (JACL too)
line 2237: au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc^Isetf tcl
line 2238: 
line 2239: " Teal
line 2240: au BufRead,BufNewFile *.tl^I^I^Isetf teal
line 2241: 
line 2242: " TealInfo
line 2243: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2244: 
line 2245: " Telix Salt
line 2246: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2247: 
line 2248: " Tera Term Language or Turtle
line 2249: au BufRead,BufNewFile *.ttl if getline(1) =~ '^@\?\(prefix\|base\)' |   setf turtle | else |   setf teraterm | endif
line 2255: 
line 2256: " Terminfo
line 2257: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2258: 
line 2259: " Terraform variables
line 2260: au BufRead,BufNewFile *.tfvars^I^I^Isetf terraform-vars
line 2261: 
line 2262: " TeX
line 2263: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2264: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 2265: 
line 2266: " ConTeXt
line 2267: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context
line 2268: 
line 2269: " Texinfo
line 2270: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2271: 
line 2272: " TeX configuration
line 2273: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2274: 
line 2275: " Thrift (Apache)
line 2276: au BufNewFile,BufRead *.thrift^I^I^Isetf thrift
line 2277: 
line 2278: " Tidy config
line 2279: au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf^Isetf tidy
line 2280: 
line 2281: " TF mud client
line 2282: au BufNewFile,BufRead .tfrc,tfrc^I^Isetf tf
line 2283: 
line 2284: " TF mud client or terraform
line 2285: au BufNewFile,BufRead *.tf^I^I^Icall dist#ft#FTtf()
line 2286: 
line 2287: " TLA+
line 2288: au BufNewFile,BufRead *.tla^I^I^Isetf tla
line 2289: 
line 2290: " tmux configuration
line 2291: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 2292: 
line 2293: " TOML
line 2294: au BufNewFile,BufRead *.toml^I^I^Isetf toml
line 2295: 
line 2296: " TPP - Text Presentation Program
line 2297: au BufNewFile,BufRead *.tpp^I^I^Isetf tpp
line 2298: 
line 2299: " TRACE32 Script Language
line 2300: au BufNewFile,BufRead *.cmm,*.t32^I^Isetf trace32
line 2301: 
line 2302: " Treetop
line 2303: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2304: 
line 2305: " Trustees
line 2306: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2307: 
line 2308: " TSS - Geometry
line 2309: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2310: 
line 2311: " TSS - Optics
line 2312: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2313: 
line 2314: " TSS - Command Line (temporary)
line 2315: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2316: 
line 2317: " TSV Files
line 2318: au BufNewFile,BufRead *.tsv^I^I^Isetf tsv
line 2319: 
line 2320: " TWIG files
line 2321: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2322: 
line 2323: " TypeScript or Qt translation file (which is XML)
line 2324: au BufNewFile,BufReadPost *.ts if getline(1) =~ '<?xml' |   setf xml | else |   setf typescript | endif
line 2330: 
line 2331: " TypeScript module and common
line 2332: au BufNewFile,BufRead *.mts,*.cts^I^Isetf typescript
line 2333: 
line 2334: " TypeScript with React
line 2335: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact
line 2336: 
line 2337: " Motif UIT/UIL files
line 2338: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2339: 
line 2340: " Udev conf
line 2341: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2342: 
line 2343: " Udev permissions
line 2344: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2345: "
line 2346: " Udev symlinks config
line 2347: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2348: 
line 2349: " Ungrammar, AKA Un-grammar
line 2350: au BufNewFile,BufRead *.ungram^I^I^Isetf ungrammar
line 2351: 
line 2352: " UnrealScript
line 2353: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2354: 
line 2355: " Updatedb
line 2356: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2357: 
line 2358: " Upstart (init(8)) config files
line 2359: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2360: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2361: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2362: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 2363: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2364: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2365: 
line 2366: " URL shortcut
line 2367: au BufNewFile,BufRead *.url^I^I^Isetf urlshortcut
line 2368: 
line 2369: " V
line 2370: au BufNewFile,BufRead *.vsh,*.vv^I^I^Isetf v
line 2371: 
line 2372: " Vala
line 2373: au BufNewFile,BufRead *.vala^I^I^Isetf vala
line 2374: 
line 2375: " VDF
line 2376: au BufNewFile,BufRead *.vdf^I^I^Isetf vdf
line 2377: 
line 2378: " VDM
line 2379: au BufRead,BufNewFile *.vdmpp,*.vpp^I^Isetf vdmpp
line 2380: au BufRead,BufNewFile *.vdmrt^I^I^Isetf vdmrt
line 2381: au BufRead,BufNewFile *.vdmsl,*.vdm^I^Isetf vdmsl
line 2382: 
line 2383: " Vera
line 2384: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2385: 
line 2386: " Vagrant (uses Ruby syntax)
line 2387: au BufNewFile,BufRead Vagrantfile^I^Isetf ruby
line 2388: 
line 2389: " Verilog HDL, V or Coq
line 2390: au BufNewFile,BufRead *.v^I^I^Icall dist#ft#FTv()
line 2391: 
line 2392: " Verilog-AMS HDL
line 2393: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2394: 
line 2395: " SystemVerilog
line 2396: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2397: 
line 2398: " VHS tape
line 2399: " .tape is also used by TapeCalc, which we do not support ATM.  If TapeCalc
line 2400: " support is needed the contents of the file needs to be inspected.
line 2401: au BufNewFile,BufRead *.tape^I^I^Isetf vhs
line 2402: 
line 2403: " VHDL
line 2404: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl
line 2405: 
line 2406: " Vim script
line 2407: au BufNewFile,BufRead *.vim,.exrc,_exrc^I^Isetf vim
line 2408: 
line 2409: " Viminfo file
line 2410: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2411: 
line 2412: " Virata Config Script File or Drupal module
line 2413: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2419: 
line 2420: " Visual Basic (see also *.bas *.cls)
line 2421: 
line 2422: " Visual Basic or FORM
line 2423: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTfrm()
line 2424: 
line 2425: " Visual Basic
line 2426: " user control, ActiveX document form, active designer, property page
line 2427: au BufNewFile,BufRead *.ctl,*.dob,*.dsr,*.pag^Isetf vb
line 2428: 
line 2429: " Visual Basic or Vimball Archiver
line 2430: au BufNewFile,BufRead *.vba^I^I^Icall dist#ft#FTvba()
line 2431: 
line 2432: " Visual Basic Project
line 2433: au BufNewFile,BufRead *.vbp^I^I^Isetf dosini
line 2434: 
line 2435: " VBScript (close to Visual Basic)
line 2436: au BufNewFile,BufRead *.vbs^I^I^Isetf vb
line 2437: 
line 2438: " Visual Basic .NET (close to Visual Basic)
line 2439: au BufNewFile,BufRead *.vb^I^I^Isetf vb
line 2440: 
line 2441: " Visual Studio Macro
line 2442: au BufNewFile,BufRead *.dsm^I^I^Isetf vb
line 2443: 
line 2444: " SaxBasic (close to Visual Basic)
line 2445: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2446: 
line 2447: " Vgrindefs file
line 2448: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2449: 
line 2450: " VRML V1.0c
line 2451: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2452: 
line 2453: " Vroom (vim testing and executable documentation)
line 2454: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2455: 
line 2456: " Vue.js Single File Component
line 2457: au BufNewFile,BufRead *.vue^I^I^Isetf vue
line 2458: 
line 2459: " WebAssembly
line 2460: au BufNewFile,BufRead *.wat,*.wast^I^Isetf wat
line 2461: 
line 2462: " WebAssembly Interface Type (WIT)
line 2463: au BufNewFile,BufRead *.wit^I^I^Isetf wit
line 2464: 
line 2465: " Webmacro
line 2466: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2467: 
line 2468: " Wget config
line 2469: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2470: 
line 2471: " Wget2 config
line 2472: au BufNewFile,BufRead .wget2rc,wget2rc^I^Isetf wget2
line 2473: 
line 2474: " WebGPU Shading Language (WGSL)
line 2475: au BufNewFile,BufRead *.wgsl^I^I^Isetf wgsl
line 2476: 
line 2477: " Website MetaLanguage
line 2478: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2479: 
line 2480: " Winbatch
line 2481: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2482: 
line 2483: " WSML
line 2484: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2485: 
line 2486: " WPL
line 2487: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 2488: 
line 2489: " WvDial
line 2490: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2491: 
line 2492: " CVS RC file
line 2493: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2494: 
line 2495: " CVS commit file
line 2496: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2497: 
line 2498: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2499: " lines in a WEB file).
line 2500: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2506: 
line 2507: " Windows Scripting Host and Windows Script Component
line 2508: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2509: 
line 2510: " XHTML
line 2511: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2512: 
line 2513: " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
line 2514: " it work better, but that breaks setting 'filetype' manually)
line 2515: au BufNewFile,BufRead *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2521: au BufNewFile,BufRead *.xpm2^I^I^Isetf xpm2
line 2522: 
line 2523: " XFree86 config
line 2524: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2529: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2532: 
line 2533: " Xorg config
line 2534: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2535: 
line 2536: " Xinetd conf
line 2537: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2538: 
line 2539: " XS Perl extension interface language
line 2540: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2541: 
line 2542: " X compose file
line 2543: au BufNewFile,BufRead .XCompose,Compose^Isetf xcompose
line 2544: 
line 2545: " X resources file
line 2546: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2547: 
line 2548: " Xmath
line 2549: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2550: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 2552: 
line 2553: " XML  specific variants: docbk and xbl
line 2554: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 2555: 
line 2556: " XMI (holding UML models) is also XML
line 2557: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2558: 
line 2559: " CSPROJ files are Visual Studio.NET's XML-based C# project config files
line 2560: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2561: 
line 2562: " FSPROJ files are Visual Studio.NET's XML-based F# project config files
line 2563: au BufNewFile,BufRead *.fsproj,*.fsproj.user^Isetf xml
line 2564: 
line 2565: " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
line 2566: au BufNewFile,BufRead *.vbproj,*.vbproj.user^Isetf xml
line 2567: 
line 2568: " Unison Language
line 2569: au BufNewFile,BufRead *.u,*.uu^I^I^I^Isetf unison
line 2570: 
line 2571: " Qt Linguist translation source and Qt User Interface Files are XML
line 2572: " However, for .ts TypeScript is more common.
line 2573: au BufNewFile,BufRead *.ui^I^I^Isetf xml
line 2574: 
line 2575: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2576: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2577: 
line 2578: " Xdg menus
line 2579: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2580: 
line 2581: " ATI graphics driver configuration
line 2582: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2583: 
line 2584: " Web Services Description Language (WSDL)
line 2585: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 2586: 
line 2587: " Workflow Description Language (WDL)
line 2588: au BufNewFile,BufRead *.wdl^I^I^Isetf wdl
line 2589: 
line 2590: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2591: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2592: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2593: 
line 2594: " XML User Interface Language
line 2595: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2596: 
line 2597: " X11 xmodmap (also see below)
line 2598: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2599: 
line 2600: " Xquery
line 2601: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2602: 
line 2603: " XSD
line 2604: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2605: 
line 2606: " Xslt
line 2607: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2608: 
line 2609: " Yacc
line 2610: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2611: 
line 2612: " Yacc or racc
line 2613: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 2614: 
line 2615: " Yaml
line 2616: au BufNewFile,BufRead *.yaml,*.yml,*.eyaml^I^Isetf yaml
line 2617: 
line 2618: " Raml
line 2619: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 2620: 
line 2621: " yum conf (close enough to dosini)
line 2622: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2623: 
line 2624: " YANG
line 2625: au BufRead,BufNewFile *.yang^I^I^Isetf yang
line 2626: 
line 2627: " Yuck
line 2628: au BufNewFile,BufRead *.yuck^I^I^Isetf yuck
line 2629: 
line 2630: " Zimbu
line 2631: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2632: " Zimbu Templates
line 2633: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 2634: 
line 2635: " Zope
line 2636: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2637: "   cpt (zope form controller page template)
line 2638: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 2639: "   zsql (zope sql method)
line 2640: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 2641: 
line 2642: " Z80 assembler asz80
line 2643: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2644: 
line 2645: augroup END
line 2646: 
line 2647: 
line 2648: " Source the user-specified filetype file, for backwards compatibility with
line 2649: " Vim 5.x.
line 2650: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2651:   execute "source " . myfiletypefile
line 2652: endif
line 2653: 
line 2654: 
line 2655: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2656: " when there are no matching file name extensions.
line 2657: " Don't do this for compressed files.
line 2658: augroup filetypedetect
line 2659: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2662: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2663: 
line 2664: 
line 2665: " Plain text files, needs to be far down to not override others.  This avoids
line 2666: " the "conf" type being used if there is a line starting with '#'.
line 2667: " But before patterns matching everything in a directory.
line 2668: au BufNewFile,BufRead *.text,README,LICENSE,COPYING,AUTHORS^Isetf text
line 2669: 
line 2670: 
line 2671: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2672: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2673: " script file.
line 2674: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2675: " like are used.
line 2676: 
line 2677: " More Apache style config files
line 2678: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 2679: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 2680: 
line 2681: " More Apache config files
line 2682: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2683: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2684: 
line 2685: " APT config file
line 2686: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} call s:StarSetf('aptconf')
line 2687: 
line 2688: " Asterisk config file
line 2689: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2690: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2691: 
line 2692: " Bazaar version control
line 2693: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2694: 
line 2695: " Bazel and Buck2 build file
line 2696: if !has("fname_case")
line 2697:   au BufNewFile,BufRead *.BUILD,BUILD,BUCK^Isetf bzl
line 2698: endif
line 2699: 
line 2700: " BIND zone
line 2701: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2702: 
line 2703: au BufNewFile,BufRead cabal.project.*^I^Icall s:StarSetf('cabalproject')
line 2704: 
line 2705: " Calendar
line 2706: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2709: 
line 2710: " Changelog
line 2711: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2717: 
line 2718: " Crontab
line 2719: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2720: 
line 2721: " dnsmasq(8) configuration
line 2722: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2723: 
line 2724: " Dockerfile
line 2725: au BufNewFile,BufRead Dockerfile.*,Containerfile.*^Icall s:StarSetf('dockerfile')
line 2726: 
line 2727: " Dracula
line 2728: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2729: 
line 2730: " Fvwm
line 2731: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2732: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2734: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2740: 
line 2741: " Gedcom
line 2742: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2743: 
line 2744: " Git
line 2745: au BufNewFile,BufRead */.gitconfig.d/*,*/etc/gitconfig.d/*^Icall s:StarSetf('gitconfig')
line 2746: 
line 2747: " Gitolite
line 2748: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 2749: 
line 2750: " GTK RC
line 2751: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2752: 
line 2753: " Jam
line 2754: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2755: 
line 2756: " Jargon
line 2757: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2761: 
line 2762: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 2763: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 2764: 
line 2765: " Kconfig
line 2766: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2767: 
line 2768: " Lilo: Linux loader
line 2769: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2770: 
line 2771: " Libsensors
line 2772: au BufNewFile,BufRead */etc/sensors.d/[^.]*^Icall s:StarSetf('sensors')
line 2773: 
line 2774: " Logcheck
line 2775: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2776: 
line 2777: " Makefile
line 2778: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2779: 
line 2780: " Ruby Makefile
line 2781: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2782: 
line 2783: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2784: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2785: 
line 2786: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2787: 
line 2788: " Modconf
line 2789: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2793: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2794: 
line 2795: " Mutt setup files (must be before catch *.rc)
line 2796: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 2797: 
line 2798: " Mutt setup file
line 2799: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2800: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2801: 
line 2802: " Neomutt setup file
line 2803: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2804: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2805: 
line 2806: " Nroff macros
line 2807: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2808: 
line 2809: " OpenBSD hostname.if
line 2810: au BufNewFile,BufRead */etc/hostname.*^I^Icall s:StarSetf('config')
line 2811: 
line 2812: " Pam conf
line 2813: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2814: 
line 2815: " Printcap and Termcap
line 2816: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2820: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2824: 
line 2825: " ReDIF
line 2826: " Only used when the .rdf file was not detected to be XML.
line 2827: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2828: 
line 2829: " Remind
line 2830: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2831: 
line 2832: " SGML catalog file
line 2833: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 2834: 
line 2835: " avoid doc files being recognized a shell files
line 2836: au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text
line 2837: 
line 2838: " Shell scripts ending in a star
line 2839: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
line 2840: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 2841: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 2842: 
line 2843: " Sudoers
line 2844: au BufNewFile,BufRead */etc/sudoers.d/*^I^Icall s:StarSetf('sudoers')
line 2845: 
line 2846: " tcsh scripts ending in a star
line 2847: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 2848: 
line 2849: " csh scripts ending in a star
line 2850: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 2851: 
line 2852: " tmux configuration with arbitrary extension
line 2853: au BufNewFile,BufRead {.,}tmux*.conf*^I^Isetf tmux
line 2854: 
line 2855: " Universal Scene Description
line 2856: au BufNewFile,BufRead *.usda,*.usd^I^Isetf usd
line 2857: 
line 2858: " VHDL
line 2859: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2860: 
line 2861: " Vim script
line 2862: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2863: 
line 2864: " Subversion commit file
line 2865: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2866: 
line 2867: " X resources file
line 2868: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2869: 
line 2870: " XFree86 config
line 2871: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2873: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2878: 
line 2879: " XKB
line 2880: au BufNewFile,BufRead */usr/share/X11/xkb/{compat,geometry,keycodes,symbols,types}/*^Icall s:StarSetf('xkb')
line 2881: 
line 2882: " X11 xmodmap
line 2883: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2884: 
line 2885: " Xinetd conf
line 2886: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2887: 
line 2888: " yum conf (close enough to dosini)
line 2889: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2890: 
line 2891: " Z-Shell script ending in a star
line 2892: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2893: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2894: 
line 2895: 
line 2896: " Help files match *.txt but should have a last line that is a modeline.
line 2897: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2901: 
line 2902: " Blueprint markup files
line 2903: au BufNewFile,BufRead *.blp^I^I^Isetf blueprint
line 2904: 
line 2905: " Use the filetype detect plugins.  They may overrule any of the previously
line 2906: " detected filetypes.
line 2907: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\ftdetect/*.vim"
Searching for "C:\Program Files\Vim/vimfiles\ftdetect/*.vim"
Searching for "C:\Program Files\Vim\vim90\ftdetect/*.vim"
Searching for "C:\Users\chris/vimfiles/after\ftdetect/*.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2908: 
line 2909: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2910: " and started another one. Let's make sure it has ended to get to a consistent
line 2911: " state.
line 2912: augroup END
line 2913: 
line 2914: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2915: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2923: 
line 2924: 
line 2925: " If the GUI is already running, may still need to install the Syntax menu.
line 2926: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2927: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2929:   source <sfile>:p:h/menu.vim
line 2930: endif
line 2931: 
line 2932: " Function called for testing all functions defined here.  These are
line 2933: " script-local, thus need to be executed here.
line 2934: " Returns a string with error messages (hopefully empty).
line 2935: func TestFiletypeFuncs(testlist)
line 2946: 
line 2947: " Restore 'cpoptions'
line 2948: let &cpo = s:cpo_save
line 2949: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\filetype.vim
continuing in C:\Program Files\Vim\vim90\syntax\syntax.vim
Searching for "C:\Users\chris/vimfiles/after\filetype.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\filetype.vim"
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")
line 35: augroup END
line 36: 
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Searching for "scripts.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\scripts.vim"
Searching for "C:\Program Files\Vim/vimfiles\scripts.vim"
Searching for "C:\Program Files\Vim\vim90\scripts.vim"
line 0: sourcing "C:\Program Files\Vim\vim90\scripts.vim"
line 1: " Vim support file to detect file types in scripts
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 27
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: " This file is called by an autocommand for every file that has just been
line 8: " loaded into a buffer.  It checks if the type of file can be recognized by
line 9: " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
line 10: 
line 11: 
line 12: " Bail out when a FileType autocommand has already set the filetype.
line 13: if did_filetype()
line 14:   finish
line 15: endif
line 16: 
line 17: " Load the user defined scripts file first
line 18: " Only do this when the FileType autocommand has not been triggered yet
line 19: if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
line 20:   execute "source " . myscriptsfile
line 21:   if did_filetype()
line 22:     finish
line 23:   endif
line 24: endif
line 25: 
line 26: " The main code is in a compiled function for speed.
line 27: call dist#script#DetectFiletype()
Searching for "autoload/dist/script.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\autoload/dist/script.vim"
Searching for "C:\Program Files\Vim/vimfiles\autoload/dist/script.vim"
Searching for "C:\Program Files\Vim\vim90\autoload/dist/script.vim"
line 27: sourcing "C:\Program Files\Vim\vim90\autoload\dist\script.vim"
line 1: vim9script
line 2: 
line 3: # Vim function for detecting a filetype from the file contents.
line 4: # Invoked from "scripts.vim" in 'runtimepath'
line 5: #
line 6: # Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 7: # Last Change:^I2023 Aug 10
line 8: # Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 9: 
line 10: export def DetectFiletype()
line 20: 
line 21: # Called for a script that has "#!" in the first line.
line 22: def DetectFromHashBang(firstline: string)
line 62: 
line 63: # Returns the filetype name associated with program "name".
line 64: # "line1" is the #! line at the top of the file.  Use the same as "name" if
line 65: # not available.
line 66: # Returns an empty string when not recognized.
line 67: export def Exe2filetype(name: string, line1: string): string
line 232: 
line 233: 
line 234: # Called for a script that does not have "#!" in the first line.
line 235: def DetectFromText(line1: string)
finished sourcing C:\Program Files\Vim\vim90\autoload\dist\script.vim
continuing in C:\Program Files\Vim\vim90\scripts.vim
finished sourcing C:\Program Files\Vim\vim90\scripts.vim
continuing in BufRead Autocommands for "*"
Searching for "C:\Users\chris/vimfiles/after\scripts.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\scripts.vim"
Executing:  endif
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif

Executing: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif
Executing:    setf FALLBACK conf | endif
Executing:  endif
line 45: endif
finished sourcing C:\Program Files\Vim\vim90\syntax\syntax.vim
continuing in C:\Users\chris\_vimrc
line 13: set termguicolors on
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 13: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\_vimrc
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line   13:
E518: Unknown option: on
line 14: colorscheme abbott
Searching for "colors/lists/default.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim\vim90\colors/lists/default.vim"
line 14: sourcing "C:\Program Files\Vim\vim90\colors\lists\default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2023 Apr 19
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: 
line 10: " make sure line continuation works
line 11: let s:keepcpo = &cpo
line 12: set cpo&vim
line 13: 
line 14: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b
line 804: 
line 805: let &cpo = s:keepcpo
line 806: unlet s:keepcpo
line 807: 
line 808: "vim: sw=4
finished sourcing C:\Program Files\Vim\vim90\colors\lists\default.vim
continuing in C:\Users\chris\_vimrc
Searching for "C:\Users\chris/vimfiles/after\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\colors/lists/default.vim"
Searching for "colors/abbott.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/abbott.vim"
line 14: sourcing "C:\Users\chris\vimfiles\colors\abbott.vim"
line 1: " abbott.vim <https://github.com/bcat/abbott.vim>
line 2: " A warm, dark color scheme for prose and code, with pastels and pretty greens.
line 3: "
line 4: " Copyright 2011-2013, 2015, 2017, 2020-2021 Jonathan Rascher
line 5: "
line 6: " Permission to use, copy, modify, and/or distribute this software for any
line 7: " purpose with or without fee is hereby granted, provided that the above
line 8: " copyright notice and this permission notice appear in all copies.
line 9: "
line 10: " THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
line 11: " REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
line 12: " AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
line 13: " INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
line 14: " LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
line 15: " OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
line 16: " PERFORMANCE OF THIS SOFTWARE.
line 17: 
line 18: " Define 16 colors that map reasonably well onto the standard ANSI color
line 19: " palette. Indeed, the terminal emulator can be configured to use these colors
line 20: " instead of its standard palette without issues.
line 21: "
line 22: " Approximations for 256-color terminals were chosen with the colors.sh script.
line 23: " Unfortunately, the XTerm 256-color palette doesn't contain many shades of
line 24: " brown, so we approximate bistre (ANSI 0) and cocoa (ANSI 8) using gray
line 25: " instead. Additionally, we use a slightly brighter approximation for cinnabar
line 26: " and French pink because the closest approximations look too reddish and too
line 27: " dull, respectively.
line 28: 
line 29: " ANSI black (0), bright black (8):
line 30: let s:bistre = {'rgb': '#231c14', 'term256': '234', 'term16': '0'}
line 31: let s:cocoa = {'rgb': '#745d42', 'term256': '241', 'term16': '8'}
line 32: 
line 33: " ANSI red (1), bright red (9):
line 34: let s:crimson = {'rgb': '#d80450', 'term256': '161', 'term16': '1'}
line 35: let s:cinnabar = {'rgb': '#f63f05', 'term256': '202', 'term16': '9'}
line 36: 
line 37: " ANSI green (2), bright green (10):
line 38: let s:forest_green = {'rgb': '#24a507', 'term256': '34', 'term16': '2'}
line 39: let s:chartreuse = {'rgb': '#a0ea00', 'term256': '154', 'term16': '10'}
line 40: 
line 41: " ANSI yellow (3), bright yellow (11):
line 42: let s:marigold = {'rgb': '#fbb32f', 'term256': '214', 'term16': '3'}
line 43: let s:lemon_meringue = {'rgb': '#fbec5d', 'term256': '227', 'term16': '11'}
line 44: 
line 45: " ANSI blue (4), bright blue (12):
line 46: let s:cornflower_blue = {'rgb': '#3f91f1', 'term256': '33', 'term16': '4'}
line 47: let s:periwinkle_blue = {'rgb': '#8ccdf0', 'term256': '117', 'term16': '12'}
line 48: 
line 49: " ANSI magenta (5), bright magenta (13):
line 50: let s:french_pink = {'rgb': '#ec6c99', 'term256': '204', 'term16': '5'}
line 51: let s:lavender = {'rgb': '#e6a2f3', 'term256': '219', 'term16': '13'}
line 52: 
line 53: " ANSI cyan (6), bright cyan (14):
line 54: let s:zomp = {'rgb': '#39a78d', 'term256': '36', 'term16': '6'}
line 55: let s:seafoam_green = {'rgb': '#00ff7f', 'term256': '48', 'term16': '14'}
line 56: 
line 57: " ANSI white (7), bright white (15):
line 58: let s:pastel_chartreuse = {'rgb': '#d8ff84', 'term256': '192', 'term16': '7'}
line 59: let s:vanilla_cream = {'rgb': '#fef3b4', 'term256': '229', 'term16': '15'}
line 60: 
line 61: " Additionally, define an extra shade of brown for use in highlighted lines and
line 62: " columns, as well as a dark green for visual selection background. For
line 63: " 256-color terminals, we map these colors to shades of gray like bistre and
line 64: " cocoa. For 16-color terminals, since we don't have any extra colors, we map
line 65: " these both to the same color as cocoa. That doesn't give a ton of contrast,
line 66: " but it's the best we can do.
line 67: 
line 68: let s:chocolate = {'rgb': '#3c3022', 'term256': '236', 'term16': '8'}
line 69: let s:dark_olive = {'rgb': '#273900', 'term256': '238', 'term16': '8'}
line 70: 
line 71: " This color scheme offers some additional features that are disabled by default
line 72: " because they may not interact well with all terminals or with other Vim color
line 73: " schemes. These features can be enabled if the user likes to live dangerously.
line 74: 
line 75: " If requested by the user, restrain ourselves to only the 16 standard ANSI
line 76: " terminal colors even if Vim thinks the terminal supports 256 colors. This
line 77: " allows the user to configure their terminal emulator to use the 16 colors
line 78: " defined above for its ANSI palette, allowing exact color matches rather than
line 79: " 256-color approximations even in terminals that don't support true color.
line 80: if !exists('g:abbott_force_16_colors')
line 81:   let g:abbott_force_16_colors = 0
line 82: endif
line 83: 
line 84: " If requested by the user, use our standard 16-color palette for the embedded
line 85: " terminal. We don't do this by default because unlike the highlight groups
line 86: " above, this isn't automatically cleared when another color scheme is selected.
line 87: if !exists('g:abbott_set_term_ansi_colors')
line 88:   let g:abbott_set_term_ansi_colors = 0
line 89: endif
line 90: 
line 91: " By default, the foreground text color will be replaced by the underline color
line 92: " in the terminal since if the terminal does not support setting the underline
line 93: " color separately, that color will be completely invisible.
line 94: if !exists('g:abbott_term_set_underline_color')
line 95:   let g:abbott_term_set_underline_color = 0
line 96: endif
line 97: 
line 98: " By default, Italics in the terminal are disabled since the default terminfo
line 99: " for GNU Screen renders italics as reverse video, and since other terminals
line 100: " like hterm may show artifacts when rendering italics.
line 101: if !exists('g:abbott_term_use_italics')
line 102:   let g:abbott_term_use_italics = 0
line 103: endif
line 104: 
line 105: " By default, underlined text will be used in the terminal in place of
line 106: " undercurl, because some terminfo entries cause Vim to think the terminal
line 107: " supports undercurl when it really does not
line 108: " (https://github.com/vim/vim/issues/3471).
line 109: if !exists('g:abbott_term_use_undercurl')
line 110:   let g:abbott_term_use_undercurl = 0
line 111: endif
line 112: 
line 113: " Returns the appropriate color index for the current terminal. We currently
line 114: " only have special support for the 256-color XTerm palette. All other terminals
line 115: " get the standard 16-color ANSI palette.
line 116: "
line 117: " We could add support for the 88-color XTerm palette or legacy
line 118: " XTerm-incompatible 256-color palettes, but it doesn't seem worth the effort.
line 119: "
line 120: " Direct color (a.k.a. true color or 24-bit color) is handled differently: if
line 121: " the termguicolors option is set, Vim uses guifg/guibg/guisp, and
line 122: " ctermfg/ctermbg/ctermul are ignored.
line 123: function! s:TermColor(color)
line 127: 
line 128: " Returns whether Vim supports the ctermul highlight parameter.
line 129: function! s:HasTermUnderlineColor()
line 132: 
line 133: " Highlights {group} according to the configuration given in {style}. The style
line 134: " dictionary may have color constant values with keys 'fg', 'bg', and 'sp' to
line 135: " set the highlight group's foreground, background, and underline colors,
line 136: " respectively. Additionally, the 'attrs' key, if present, should map to a list
line 137: " of terminal attributes.
line 138: function! s:H(group, style)
line 183: 
line 184: " Mark abbott.vim as a dark theme.
line 185: set background=dark
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 185: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 186: 
line 187: " Reset existing syntax highlights to their default settings.
line 188: highlight clear
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 188: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 189: if exists('g:syntax_on')
line 190:   syntax reset
line 190: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 190: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi! link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi! link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi! link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi! link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi! link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi! link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi! link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi! link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi! link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi! link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi! link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi! link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi! link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi! link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi! link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi! link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi! link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi! link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi! link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi! link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi! link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi! link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi! link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi! link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 191: endif
line 192: 
line 193: " Declare the name of this color scheme.
line 194: let g:colors_name = 'abbott'
line 195: 
line 196: " Set default foreground and background colors.
line 197: call s:H('Normal', {'fg': s:pastel_chartreuse, 'bg': s:bistre})
calling <SNR>9_H('Normal', {'bg': {'term16': '0', 'rgb': '#231c14...', 'rgb': '#d8ff84', 'term256': '192'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '7', 'rgb': '#d8ff84', 'term256': '192'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '192'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Normal term=NONE ctermfg= 192 ctermbg=234 ctermul=NONE cterm=NONE guifg=#d8ff84 guibg=#231c14 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 198: 
line 199: " Set up highlights for basic syntax groups.
line 200: call s:H('Comment', {'fg': s:marigold, 'attrs': ['italic']})
calling <SNR>9_H('Comment', {'fg': {'term16': '3', 'rgb': '#fbb32f', 'term256': '214'}, 'attrs': ['italic']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Comment term=NONE ctermfg= 214 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbb32f guibg=NONE guisp=NONE gui=italic
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 201: call s:H('Constant', {'fg': s:cinnabar})
calling <SNR>9_H('Constant', {'fg': {'term16': '9', 'rgb': '#f63f05', 'term256': '202'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '9', 'rgb': '#f63f05', 'term256': '202'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '202'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Constant term=NONE ctermfg= 202 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#f63f05 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 202: call s:H('String', {'fg': s:lavender})
calling <SNR>9_H('String', {'fg': {'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight String term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#e6a2f3 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 203: call s:H('Character', {'fg': s:lavender})
calling <SNR>9_H('Character', {'fg': {'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Character term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#e6a2f3 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 204: call s:H('Identifier', {'fg': s:periwinkle_blue})
calling <SNR>9_H('Identifier', {'fg': {'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Identifier term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#8ccdf0 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 205: call s:H('Function', {'fg': s:cornflower_blue})
calling <SNR>9_H('Function', {'fg': {'term16': '4', 'rgb': '#3f91f1', 'term256': '33'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Function term=NONE ctermfg= 33 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#3f91f1 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 206: call s:H('Statement', {'fg': s:crimson, 'attrs': ['bold']})
calling <SNR>9_H('Statement', {'fg': {'term16': '1', 'rgb': '#d80450', 'term256': '161'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Statement term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=bold guifg=#d80450 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 207: call s:H('Operator', {'attrs': ['bold']})
calling <SNR>9_H('Operator', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Operator term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 208: call s:H('PreProc', {'fg': s:french_pink})
calling <SNR>9_H('PreProc', {'fg': {'term16': '5', 'rgb': '#ec6c99', 'term256': '204'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PreProc term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#ec6c99 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 209: call s:H('Type', {'fg': s:forest_green})
calling <SNR>9_H('Type', {'fg': {'term16': '2', 'rgb': '#24a507', 'term256': '34'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '2', 'rgb': '#24a507', 'term256': '34'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '34'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Type term=NONE ctermfg= 34 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#24a507 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 210: call s:H('Special', {'fg': s:vanilla_cream})
calling <SNR>9_H('Special', {'fg': {'term16': '15', 'rgb': '#fef3b4', 'term256': '229'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Special term=NONE ctermfg= 229 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fef3b4 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 211: call s:H('Tag', {'fg': s:lavender, 'attrs': ['underline']})
calling <SNR>9_H('Tag', {'fg': {'term16': '13', 'rgb': '#e6a2f...rm256': '219'}, 'attrs': ['underline']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Tag term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=underline guifg=#e6a2f3 guibg=NONE guisp=NONE gui=underline
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 212: call s:H('Underlined', {'fg': s:lavender, 'attrs': ['underline']})
calling <SNR>9_H('Underlined', {'fg': {'term16': '13', 'rgb': '#e6a2f...rm256': '219'}, 'attrs': ['underline']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Underlined term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=underline guifg=#e6a2f3 guibg=NONE guisp=NONE gui=underline
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 213: call s:H('Ignore', {'fg': s:cocoa})
calling <SNR>9_H('Ignore', {'fg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Ignore term=NONE ctermfg= 241 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#745d42 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 214: call s:H('Error', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('Error', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Error term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 215: call s:H('Todo', {'fg': s:bistre, 'bg': s:marigold})
calling <SNR>9_H('Todo', {'bg': {'term16': '3', 'rgb': '#fbb32f...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Todo term=NONE ctermfg= 234 ctermbg=214 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#fbb32f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 216: 
line 217: " Set up highlights for various UI elements.
line 218: call s:H('ErrorMsg', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('ErrorMsg', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ErrorMsg term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 219: call s:H('FoldColumn', {'fg': s:marigold})
calling <SNR>9_H('FoldColumn', {'fg': {'term16': '3', 'rgb': '#fbb32f', 'term256': '214'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight FoldColumn term=NONE ctermfg= 214 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbb32f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 220: call s:H('Folded', {'fg': s:cinnabar})
calling <SNR>9_H('Folded', {'fg': {'term16': '9', 'rgb': '#f63f05', 'term256': '202'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '9', 'rgb': '#f63f05', 'term256': '202'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '202'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Folded term=NONE ctermfg= 202 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#f63f05 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 221: call s:H('LineNr', {'fg': s:lemon_meringue})
calling <SNR>9_H('LineNr', {'fg': {'term16': '11', 'rgb': '#fbec5d', 'term256': '227'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '11', 'rgb': '#fbec5d', 'term256': '227'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '227'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight LineNr term=NONE ctermfg= 227 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbec5d guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 222: call s:H('ModeMsg', {'attrs': ['bold']})
calling <SNR>9_H('ModeMsg', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ModeMsg term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 223: call s:H('MoreMsg', {'fg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('MoreMsg', {'fg': {'term16': '4', 'rgb': '#3f91f1', 'term256': '33'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight MoreMsg term=NONE ctermfg= 33 ctermbg=NONE ctermul=NONE cterm=bold guifg=#3f91f1 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 224: call s:H('Pmenu', {'fg': s:vanilla_cream, 'bg': s:cocoa})
calling <SNR>9_H('Pmenu', {'bg': {'term16': '8', 'rgb': '#745d42...', 'rgb': '#fef3b4', 'term256': '229'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Pmenu term=NONE ctermfg= 229 ctermbg=241 ctermul=NONE cterm=NONE guifg=#fef3b4 guibg=#745d42 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 225: call s:H('PmenuSel', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('PmenuSel', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuSel term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 226: call s:H('PmenuSbar', {'bg': s:cocoa})
calling <SNR>9_H('PmenuSbar', {'bg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuSbar term=NONE ctermfg= NONE ctermbg=241 ctermul=NONE cterm=NONE guifg=NONE guibg=#745d42 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 227: call s:H('PmenuThumb', {'bg': s:bistre})
calling <SNR>9_H('PmenuThumb', {'bg': {'term16': '0', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuThumb term=NONE ctermfg= NONE ctermbg=234 ctermul=NONE cterm=NONE guifg=NONE guibg=#231c14 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 228: call s:H('Question', {'fg': s:french_pink, 'attrs': ['bold']})
calling <SNR>9_H('Question', {'fg': {'term16': '5', 'rgb': '#ec6c99', 'term256': '204'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Question term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=bold guifg=#ec6c99 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 229: call s:H('QuickFixLine', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('QuickFixLine', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight QuickFixLine term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 231: call s:H('SignColumn', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('SignColumn', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SignColumn term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 232: call s:H('StatusLine', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('StatusLine', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLine term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 234: call s:H('StatusLineNC', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('StatusLineNC', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineNC term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 235: call s:H('StatusLineTerm', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('StatusLineTerm', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineTerm term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 237: call s:H('StatusLineTermNC', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('StatusLineTermNC', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineTermNC term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 238: call s:H('TabLine', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('TabLine', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLine term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 239: call s:H('TabLineFill', {'bg': s:zomp})
calling <SNR>9_H('TabLineFill', {'bg': {'term16': '6', 'rgb': '#39a78d', 'term256': '36'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLineFill term=NONE ctermfg= NONE ctermbg=36 ctermul=NONE cterm=NONE guifg=NONE guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 240: call s:H('TabLineSel', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('TabLineSel', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLineSel term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 242: call s:H('Title', {'fg': s:crimson, 'attrs': ['bold']})
calling <SNR>9_H('Title', {'fg': {'term16': '1', 'rgb': '#d80450', 'term256': '161'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Title term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=bold guifg=#d80450 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 243: call s:H('WarningMsg', {'fg': s:bistre, 'bg': s:french_pink})
calling <SNR>9_H('WarningMsg', {'bg': {'term16': '5', 'rgb': '#ec6c99...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight WarningMsg term=NONE ctermfg= 234 ctermbg=204 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#ec6c99 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 244: call s:H('WildMenu', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('WildMenu', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight WildMenu term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 245: call s:H('VertSplit', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('VertSplit', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight VertSplit term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 246: 
line 247: " Use an eye-catching shade of green for the blinking cursor.
line 248: call s:H('Cursor', {'fg': s:bistre, 'bg': s:chartreuse})
calling <SNR>9_H('Cursor', {'bg': {'term16': '10', 'rgb': '#a0ea0...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '10', 'rgb': '#a0ea00', 'term256': '154'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '154'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Cursor term=NONE ctermfg= 234 ctermbg=154 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#a0ea00 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 249: call s:H('CursorIM', {'fg': s:bistre, 'bg': s:seafoam_green})
calling <SNR>9_H('CursorIM', {'bg': {'term16': '14', 'rgb': '#00ff7...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorIM term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#00ff7f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 250: 
line 251: " Bold the current line and column; highlight the current line number.
line 252: call s:H('CursorLine', {'bg': s:chocolate})
calling <SNR>9_H('CursorLine', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorLine term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 253: call s:H('CursorLineNr', {'bg': s:chocolate, 'attrs': ['bold']})
calling <SNR>9_H('CursorLineNr', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorLineNr term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=bold guifg=NONE guibg=#3c3022 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 254: call s:H('CursorColumn', {'bg': s:chocolate})
calling <SNR>9_H('CursorColumn', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorColumn term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 255: 
line 256: " Lighten the background of the right margin.
line 257: call s:H('ColorColumn', {'bg': s:chocolate})
calling <SNR>9_H('ColorColumn', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ColorColumn term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 258: 
line 259: " Highlight matched delimiters in a way that's clearly distinguishable from
line 260: " unmatched delimiter/statement/preprocessor highlighting.
line 261: call s:H('MatchParen', {'fg': s:bistre, 'bg': s:cocoa, 'attrs': ['bold']})
calling <SNR>9_H('MatchParen', {'bg': {'term16': '8', 'rgb': '#745d42..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight MatchParen term=NONE ctermfg= 234 ctermbg=241 ctermul=NONE cterm=bold guifg=#231c14 guibg=#745d42 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 262: 
line 263: " Set up highlights for imaginary '~' and '@' characters, and for special keys.
line 264: call s:H('EndOfBuffer', {'fg': s:cocoa})
calling <SNR>9_H('EndOfBuffer', {'fg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight EndOfBuffer term=NONE ctermfg= 241 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#745d42 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 265: call s:H('NonText', {'fg': s:seafoam_green})
calling <SNR>9_H('NonText', {'fg': {'term16': '14', 'rgb': '#00ff7f', 'term256': '48'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight NonText term=NONE ctermfg= 48 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#00ff7f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 266: call s:H('SpecialKey', {'fg': s:seafoam_green})
calling <SNR>9_H('SpecialKey', {'fg': {'term16': '14', 'rgb': '#00ff7f', 'term256': '48'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpecialKey term=NONE ctermfg= 48 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#00ff7f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 267: 
line 268: " Set a dark green background for visual mode.
line 269: call s:H('Visual', {'bg': s:dark_olive})
calling <SNR>9_H('Visual', {'bg': {'term16': '8', 'rgb': '#273900', 'term256': '238'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#273900', 'term256': '238'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '238'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Visual term=NONE ctermfg= NONE ctermbg=238 ctermul=NONE cterm=NONE guifg=NONE guibg=#273900 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 270: call s:H('VisualNOS', {'bg': s:dark_olive})
calling <SNR>9_H('VisualNOS', {'bg': {'term16': '8', 'rgb': '#273900', 'term256': '238'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#273900', 'term256': '238'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '238'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight VisualNOS term=NONE ctermfg= NONE ctermbg=238 ctermul=NONE cterm=NONE guifg=NONE guibg=#273900 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 271: 
line 272: " Use cold highlights for incremental searching and warm highlights for final
line 273: " search results.
line 274: call s:H('IncSearch', {'fg': s:bistre, 'bg': s:seafoam_green})
calling <SNR>9_H('IncSearch', {'bg': {'term16': '14', 'rgb': '#00ff7...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight IncSearch term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#00ff7f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 275: call s:H('Search', {'fg': s:bistre, 'bg': s:vanilla_cream})
calling <SNR>9_H('Search', {'bg': {'term16': '15', 'rgb': '#fef3b...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Search term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 276: 
line 277: " Set up spell-checking in an unobtrusive way.
line 278: call s:H('SpellBad', {'sp': s:crimson, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellBad', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#d80450', 'term256': '161'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellBad term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#d80450 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 279: call s:H('SpellCap', {'sp': s:periwinkle_blue, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellCap', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellCap term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#8ccdf0 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 280: call s:H('SpellLocal', {'sp': s:lemon_meringue, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellLocal', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#fbec5d', 'term256': '227'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '11', 'rgb': '#fbec5d', 'term256': '227'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '227'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellLocal term=NONE ctermfg= 227 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#fbec5d gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 281: call s:H('SpellRare', {'sp': s:french_pink, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellRare', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#ec6c99', 'term256': '204'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellRare term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#ec6c99 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 282: 
line 283: " Don't do anything special for concealed tokens.
line 284: call s:H('Conceal', {})
calling <SNR>9_H('Conceal', {})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Conceal term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=NONE guifg=NONE guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 285: 
line 286: " Set highlights for directory listings.
line 287: call s:H('Directory', {'fg': s:periwinkle_blue})
calling <SNR>9_H('Directory', {'fg': {'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Directory term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#8ccdf0 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 288: 
line 289: " Use readable diff highlights. :)
line 290: call s:H('DiffAdd', {'fg': s:bistre, 'bg': s:chartreuse, 'attrs': ['bold']})
calling <SNR>9_H('DiffAdd', {'bg': {'term16': '10', 'rgb': '#a0ea0..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '10', 'rgb': '#a0ea00', 'term256': '154'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '154'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffAdd term=NONE ctermfg= 234 ctermbg=154 ctermul=NONE cterm=bold guifg=#231c14 guibg=#a0ea00 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 291: call s:H('DiffChange', {'fg': s:bistre, 'bg': s:french_pink})
calling <SNR>9_H('DiffChange', {'bg': {'term16': '5', 'rgb': '#ec6c99...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffChange term=NONE ctermfg= 234 ctermbg=204 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#ec6c99 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 292: call s:H('DiffDelete', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('DiffDelete', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffDelete term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 293: call s:H('DiffText', {'fg': s:bistre, 'bg': s:seafoam_green, 'attrs': ['bold']})
calling <SNR>9_H('DiffText', {'bg': {'term16': '14', 'rgb': '#00ff7..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffText term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=bold guifg=#231c14 guibg=#00ff7f guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 294: 
line 295: " Set up custom highlights for better-whitespace.vim.
line 296: call s:H('ExtraWhitespace', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('ExtraWhitespace', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ExtraWhitespace term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 297: 
line 298: " Set up custom highlights for diff.vim
line 299: highlight link diffAdded DiffAdd
line 300: highlight link diffRemoved DiffDelete
line 301: 
line 302: " Set up custom highlights for gitcommit.vim.
line 303: call s:H('gitcommitSummary', {'attrs': ['bold']})
calling <SNR>9_H('gitcommitSummary', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight gitcommitSummary term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 304: highlight link gitcommitOverflow Error
line 305: 
line 306: " Set up custom highlights for tex.vim.
line 307: highlight link texStatement PreProc
line 308: 
line 309: " Set up the embedded terminal.
line 310: if g:abbott_set_term_ansi_colors
line 311:   let g:terminal_ansi_colors = [ s:bistre.rgb, s:crimson.rgb, s:forest_green.rgb, s:marigold.rgb, s:cornflower_blue.rgb, s:french_pink.rgb, s:zomp.rgb, s:pastel_chartreuse.rgb, s:cocoa.rgb, s:cinnabar.rgb, s:chartreuse.rgb, s:lemon_meringue.rgb, s:periwinkle_blue.rgb, s:lavender.rgb, s:seafoam_green.rgb, s:vanilla_cream.rgb, ]
line 329: endif
finished sourcing C:\Users\chris\vimfiles\colors\abbott.vim
continuing in C:\Users\chris\_vimrc
line 15: set showmatch
line 16: set ft=nasm
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 17: set shortmess=at
line 18: set cmdheight=2
line 19: 
finished sourcing $HOME\_vimrc
Searching for "pack/*/start/*" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim\vim90\pack/*/start/*"
Searching for "C:\Users\chris/vimfiles/after\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles/after\pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\plugin/**/*.vim"
Searching for "C:\Program Files\Vim/vimfiles\plugin/**/*.vim"
Searching for "C:\Program Files\Vim\vim90\plugin/**/*.vim"
sourcing "C:\Program Files\Vim\vim90\plugin\getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: sil! com    -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing C:\Program Files\Vim\vim90\plugin\getscriptPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   " Use "gzip -d", gunzip isn't always available.
line 24:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 25:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 26:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 27:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 28:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 35:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 36:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 37:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 39:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 40:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 42:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 43:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 44:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 45:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 46:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 47:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 48:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 49:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 52:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 53:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 54:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 55:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 56:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 57:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 58:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 59:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 60:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 61: augroup END
finished sourcing C:\Program Files\Vim\vim90\plugin\gzip.vim
sourcing "C:\Program Files\Vim\vim90\plugin\logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\logiPat.vim
sourcing "C:\Program Files\Vim\vim90\plugin\manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2022 Oct 17
line 4: 
line 5: if exists('g:loaded_manpager_plugin')
line 6:   finish
line 7: endif
line 8: let g:loaded_manpager_plugin = 1
line 9: 
line 10: " Set up the current buffer (likely read from stdin) as a manpage
line 11: command MANPAGER call s:ManPager()
line 12: 
line 13: function s:ManPager()
finished sourcing C:\Program Files\Vim\vim90\plugin\manpager.vim
sourcing "C:\Program Files\Vim\vim90\plugin\matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Oct 20
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: if exists("g:loaded_matchparen") || &cp
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: let s:has_matchaddpos = exists('*matchaddpos')
line 22: 
line 23: augroup matchparen
line 24:   " Replace all matchparen autocommands
line 25:   autocmd! CursorMoved,CursorMovedI,WinEnter,BufWinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 26:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 27:   if exists('##TextChanged')
line 28:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 29:     autocmd! TextChangedP * call s:Remove_Matches()
line 30:   endif
line 31: augroup END
line 32: 
line 33: " Skip the rest if it was already done.
line 34: if exists("*s:Highlight_Matching_Pair")
line 35:   finish
line 36: endif
line 37: 
line 38: let s:cpo_save = &cpo
line 39: set cpo-=C
line 40: 
line 41: " The function that is invoked (very often) to define a ":match" highlighting
line 42: " for any matching paren.
line 43: func s:Highlight_Matching_Pair()
line 204: 
line 205: func s:Remove_Matches()
line 213: 
line 214: " Define commands that will disable and enable the plugin.
line 215: command DoMatchParen call s:DoMatchParen()
line 216: command NoMatchParen call s:NoMatchParen()
line 217: 
line 218: func s:NoMatchParen()
line 225: 
line 226: func s:DoMatchParen()
line 232: 
line 233: let &cpo = s:cpo_save
line 234: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\plugin\matchparen.vim
sourcing "C:\Program Files\Vim\vim90\plugin\netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 09, 2021
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v173"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 85:  endif
line 86:  if maparg('gx','x') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    xmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 149: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 150: "             them, which checks if they're directories and will create a directory
line 151: "             listing when appropriate.
line 152: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 153: "             has already been called.
line 154: fun! s:VimEnter(dirname)
line 174: 
line 175: " ---------------------------------------------------------------------
line 176: " NetrwStatusLine: {{{1
line 177: fun! NetrwStatusLine()
line 188: 
line 189: " ------------------------------------------------------------------------
line 190: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 191: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 192: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 193: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 194: fun! NetUserPass(...)
line 218: 
line 219: " ------------------------------------------------------------------------
line 220: " Modelines And Restoration: {{{1
line 221: let &cpo= s:keepcpo
line 222: unlet s:keepcpo
line 223: " vim:ts=8 fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\netrwPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing C:\Program Files\Vim\vim90\plugin\rrhelper.vim
sourcing "C:\Program Files\Vim\vim90\plugin\spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of spell files
line 10: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 11:   finish
line 12: endif
line 13: let loaded_spellfile_plugin = 1
line 14: 
line 15: " The function is in the autoload directory.
line 16: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing C:\Program Files\Vim\vim90\plugin\spellfile.vim
sourcing "C:\Program Files\Vim\vim90\plugin\tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzs^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: " Restoration And Modelines: {{{1
line 54: " vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing C:\Program Files\Vim\vim90\plugin\tarPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2023 Sep 07
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim9.0_v2'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   9.0_v2  (this version): - Warn if using deprecated g:use_xhtml option
line 16: "                           - Change default g:html_use_input_for_pc to "none"
line 17: "                             instead of "fallback". All modern browsers support
line 18: "                             the "user-select: none" and "content:" CSS
line 19: "                             properties so the older method relying on extra
line 20: "                             markup and unspecified browser/app clipboard
line 21: "                             handling is only needed in rare special cases.
line 22: "                           - Fix SourceForge issue #33: generate diff filler
line 23: "                             correctly when new lines have been added to or
line 24: "                             removed from end of buffer.
line 25: "                           - Fix SourceForge issue #32/Vim Github issue #8547:
line 26: "                             use translated highlight ID for styling the
line 27: "                             special-use group names (e.g. LineNr) used
line 28: "                             directly by name in the 2html processing.
line 29: "                           - Fix SourceForge issue #26, refactoring to use
line 30: "                             :let-heredoc style string assignment and
line 31: "                             additional fixes for ".." vs. "." style string
line 32: "                             concatenation. Requires Vim v8.1.1354 or higher.
line 33: "   9.0_v1  (Vim 9.0.1275): - Implement g:html_no_doc and g:html_no_modeline
line 34: "                             for diff mode. Add tests.
line 35: "           (Vim 9.0.1122): NOTE: no version string update for this version!
line 36: "                           - Bugfix for variable name in g:html_no_doc
line 37: "           (Vim 9.0.0819): NOTE: no version string update for this version!
line 38: "                           - Add options g:html_no_doc, g:html_no_lines,
line 39: "                             and g:html_no_modeline (partially included in Vim
line 40: "                             runtime prior to version string update).
line 41: "                           - Updates for new Vim9 string append style (i.e. use
line 42: "                             ".." instead of "."). Requires Vim version
line 43: "                             8.1.1114 or higher.
line 44: "
line 45: "   8.1 updates: {{{
line 46: "   8.1_v2  (Vim 8.1.2312): - Fix SourceForge issue #19: fix calculation of tab
line 47: "                             stop position to use in expanding a tab, when that
line 48: "                             tab occurs after a syntax match which in turn
line 49: "                             comes after previously expanded tabs.
line 50: "                           - Set eventignore while splitting a window for the
line 51: "                             destination file to ignore FileType events;
line 52: "                             speeds up processing when the destination file
line 53: "                             already exists and HTML highlight takes too long.
line 54: "                           - Fix SourceForge issue #20: progress bar could not be
line 55: "                             seen when DiffDelete background color matched
line 56: "                             StatusLine background color. Added TOhtmlProgress
line 57: "                             highlight group for manual user override, but
line 58: "                             calculate it to be visible compared to StatusLine
line 59: "                             by default.
line 60: "                           - Fix SourceForge issue #1: Remove workaround for old
line 61: "                             browsers which don't support 'ch' CSS unit, since
line 62: "                             all modern browsers, including IE>=9, support it.
line 63: "                           - Fix SourceForge issue #10: support termguicolors
line 64: "                           - Fix SourceForge issue #21: default to using
line 65: "                             generated content instead of <input> tags for
line 66: "                             uncopyable text, so that text is correctly
line 67: "                             prevented from being copied in chrome. Use
line 68: "                             g:html_use_input_for_pc option to control the
line 69: "                             method used.
line 70: "                           - Switch to HTML5 to allow using vnu as a validator
line 71: "                             in unit test.
line 72: "                           - Fix fallback sizing of <input> tags for browsers
line 73: "                             without "ch" support.
line 74: "                           - Fix cursor on unselectable diff filler text.
line 75: "   8.1_v1  (Vim 8.1.0528): - Fix SourceForge issue #6: Don't generate empty
line 76: "                             script tag.
line 77: "                           - Fix SourceForge issue #5: javascript should
line 78: "                             declare variables with "var".
line 79: "                           - Fix SourceForge issue #13: errors thrown sourcing
line 80: "                             2html.vim directly when plugins not loaded.
line 81: "                           - Fix SourceForge issue #16: support 'vartabstop'.
line 82: "}}}
line 83: "
line 84: "   7.4 updates: {{{
line 85: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 86: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 87: "                           take a list so it is easier to specfiy fallback
line 88: "                           fonts in the generated CSS.
line 89: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 90: "^I^I^I    also for version-specific modelines like "vim>703:".
line 91: "}}}
line 92: "
line 93: "   7.3 updates: {{{
line 94: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 95: "^I^I^I    g:html_line_ids=0. Allow customizing
line 96: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 97: "^I^I^I    g:html_id_expr evaluated when the buffer conversion
line 98: "^I^I^I    is started.
line 99: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 100: "^I^I^I    insert modeline to set it to manual.
line 101: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 102: "^I^I^I    duplicate of one buffer instead of including both.
line 103: "^I^I^I    Add anchors to each line so you can put '#L123'
line 104: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 105: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 106: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 107: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 108: "^I^I^I    Allow TOhtml to chain together with other commands
line 109: "^I^I^I    using |.
line 110: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 111: "^I^I^I    highlight groups make up the start-of-modeline text.
line 112: "^I^I^I    Improve render time of page with uncopyable regions
line 113: "^I^I^I    by not using one-input-per-char. Change name of
line 114: "^I^I^I    uncopyable option from html_unselectable to
line 115: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 116: "^I^I^I    default to inserting invalid markup for uncopyable
line 117: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 118: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 119: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 120: "^I^I^I    eliminate post-processing substitute commands in
line 121: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 122: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 123: "^I^I^I    speed improvements. Fix modeline mangling in
line 124: "^I^I^I    generated output so it works for text in the first
line 125: "^I^I^I    column. Fix missing line number and fold column in
line 126: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 127: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 128: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 129: "^I^I^I    the new default foldtext added in v11, as the patch
line 130: "^I^I^I    adding it has not yet been included in Vim.
line 131: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 132: "^I^I^I    Brabandt in
line 133: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 134: "^I^I^I    This patch has not yet been included in Vim, thus
line 135: "^I^I^I    these changes are removed in the next version.
line 136: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 137: "^I^I^I    multiple nested folds with dynamic folding on.
line 138: "^I^I^I    Also fix problem with foldtext in this situation.
line 139: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 140: "^I^I^I    and without html_no_pre, default value same as
line 141: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 142: "^I^I^I    'fileencoding' for converted document encoding if
line 143: "^I^I^I    'buftype' indicates a special buffer which isn't
line 144: "^I^I^I    written.
line 145: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 146: "^I^I^I    characters in generated output (Andy Spencer).
line 147: "^I^I^I    Escape text that looks like a modeline so Vim
line 148: "^I^I^I    doesn't use anything in the converted HTML as a
line 149: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 150: "^I^I^I    before the conversion range. Remove fold column when
line 151: "^I^I^I    there are no folds.
line 152: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 153: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 154: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 155: "^I^I^I    supported by all major browsers according to
line 156: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 157: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 158: "^I^I^I    HTML encoding to Vim encoding detection be
line 159: "^I^I^I    case-insensitive for built-in pairs.
line 160: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 161: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 162: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 163: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 164: "^I^I^I    file matches its indicated charset. Add charsets for
line 165: "^I^I^I    all of Vim's natively supported encodings.
line 166: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 167: "^I^I^I    user settings interfering with diff mode generation,
line 168: "^I^I^I    trailing whitespace (e.g. line number column) when
line 169: "^I^I^I    using html_no_pre, and bugs when using
line 170: "^I^I^I    html_hover_unfold.
line 171: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 172: "^I^I^I    folds in diff mode when first line was folded.
line 173: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 174: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 175: "^I^I^I    default to true when not set to anything. Use strict
line 176: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 177: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 178: "^I^I^I    when using this option. Add meta tag for settings.
line 179: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 180: "^I^I^I    diff colors and the normal syntax colors
line 181: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 182: "}}}
line 183: "}}}
line 184: 
line 185: " TODO: {{{
line 186: "   * Check the issue tracker:
line 187: "     https://sourceforge.net/p/vim-tohtml/issues/search/?q=%21status%3Aclosed
line 188: "   * Options for generating the CSS in external style sheets. New :TOcss
line 189: "     command to convert the current color scheme into a (mostly) generic CSS
line 190: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 191: "     by Erik Falor
line 192: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 193: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 194: "     term) to use for the styling. Suggestion by "nacitar".
line 195: "   * Add way to override or specify which RGB colors map to the color numbers
line 196: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 197: "   * Disable filetype detection until after all processing is done.
line 198: "   * Add option for not generating the hyperlink on stuff that looks like a
line 199: "     URL? Or just color the link to fit with the colorscheme (and only special
line 200: "     when hovering)?
line 201: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 202: "     regions is turned on. Possible solution: Add normal text line numbers with
line 203: "     display:none, set to display:inline for print style sheets, and hide
line 204: "     <input> elements for print, to allow Opera printing multiple pages (and
line 205: "     other uncopyable areas?). May need to make the new text invisible to IE
line 206: "     with conditional comments to prevent copying it, IE for some reason likes
line 207: "     to copy hidden text. Other browsers too?
line 208: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 209: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 210: "     on Windows). Perhaps it is font related?
line 211: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 212: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 213: "     on diff lines though.
line 214: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 215: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 216: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 217: "     accepted to modify it.
line 218: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 219: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 220: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 221: "     does not show the whole diff filler as it is supposed to?
line 222: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 223: "     invalid content. Can/should anything be done about this? Maybe a separate
line 224: "     plugin to correct 'isprint' based on encoding?
line 225: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 226: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 227: "   * Font auto-detection similar to
line 228: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 229: "     platforms.
line 230: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 231: "^I- listchars support
line 232: "^I- full-line background highlight
line 233: "^I- other?
line 234: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 235: "     free with full-line background highlight above).
line 236: "   * Restore open/closed folds and cursor position after processing each file
line 237: "     with option not to restore for speed increase.
line 238: "   * Add extra meta info (generation time, etc.)?
line 239: "   * Tidy up so we can use strict doctype in even more situations
line 240: "   * Implementation detail: add threshold for writing the lines to the html
line 241: "     buffer before we're done (5000 or so lines should do it)
line 242: "   * TODO comments for code cleanup scattered throughout
line 243: "}}}
line 244: 
line 245: " Define the :TOhtml command when:
line 246: " - 'compatible' is not set
line 247: " - this plugin or user override was not already loaded
line 248: " - user commands are available. {{{
line 249: if !&cp && !exists(":TOhtml") && has("user_commands")
line 250:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 251: endif "}}}
line 252: 
line 253: " Make sure any patches will probably use consistent indent
line 254: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\tohtml.vim
sourcing "C:\Program Files\Vim\vim90\plugin\vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0, "Source this file to extract it! (:so %)")|endif | endif
line 35:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif | endif
line 41:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 42:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 43: augroup END
line 44: 
line 45: " =====================================================================
line 46: " Restoration And Modelines: {{{1
line 47: " vim: fdm=marker
line 48: let &cpo= s:keepcpo
line 49: unlet s:keepcpo
line 50: 
line 51: " vim: ts=4:
finished sourcing C:\Program Files\Vim\vim90\plugin\vimballPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v33"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing C:\Program Files\Vim\vim90\plugin\zipPlugin.vim
Searching for "pack/*/start/*" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim\vim90\pack/*/start/*"
Searching for "C:\Users\chris/vimfiles/after\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles/after\pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles/after\plugin/**/*.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading viminfo file "C:\Users\chris\_viminfo" info oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>15_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>15_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>15_Remove_Matches returning #0

continuing in <SNR>15_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
<SNR>15_Highlight_Matching_Pair returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
<SNR>16_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
calling <SNR>16_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   if has('nvim') || v:version < 802
line 3:   " Johann Hchtl: reported that the call range... line causes an E488: Trailing characters
line 4:   "                error with neovim. I suspect its because neovim hasn't updated with recent
line 5:   "                vim patches. As is, this code will have problems with popup terminals
line 6:   "                instantiated before the VimEnter event runs.
line 7:   " Ingo Karkat  : E488 also in Vim 8.1.1602
line 8:   let curwin       = winnr()
line 9:   let s:vimentered = 1
line 10:   windo call s:LocalBrowse(expand("%:p"))
line 11:   exe curwin."wincmd w"
line 12:  else
line 13:   " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
line 14:   " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
line 15:   let s:vimentered = 1
line 16:   call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
calling <lambda>1(0, 1)

line 1: call expand("%:p")->s:LocalBrowse()
calling <SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>16_LocalBrowse returning #0

continuing in <lambda>1

<lambda>1 returning '^@line 1: call expand("%:p")->s:Local...urning #0^@^@continuing in <lambda>1^@'

continuing in <SNR>16_VimEnter

line 17:  endif
line 18: "  call Dret("s:VimEnter")
<SNR>16_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>15_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>15_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>15_Remove_Matches returning #0

continuing in <SNR>15_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
<SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"


Executing: q!
Writing viminfo file "C:\Users\chris\_viminfo"
Searching for "bitmaps/vim.ico" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\bitmaps/vim.ico"
Searching for "C:\Program Files\Vim/vimfiles\bitmaps/vim.ico"
Searching for "C:\Program Files\Vim\vim90\bitmaps/vim.ico"
could not source "$VIM\vimrc"
sourcing "$HOME\_vimrc"
line 1: set enc=utf-8
line 2: set fenc=utf-8
line 3: set termencoding=utf-8
line 4: set nocompatible
line 5: set autoindent
line 6: set smartindent
line 7: set tabstop=4
line 8: set shiftwidth=4
line 9: set expandtab
line 10: set t_Co=256
line 11: syntax on
line 11: so $VIMRUNTIME\syntax\syntax.vim
line 11: sourcing "C:\Program Files\Vim\vim90\syntax\syntax.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file is used for ":syntax on".
line 7: " It installs the autocommands and starts highlighting for all buffers.
line 8: 
line 9: if !has("syntax")
line 10:   finish
line 11: endif
line 12: 
line 13: " If Syntax highlighting appears to be on already, turn it off first, so that
line 14: " any leftovers are cleared.
line 15: if exists("syntax_on") || exists("syntax_manual")
line 16:   so <sfile>:p:h/nosyntax.vim
line 17: endif
line 18: 
line 19: " Load the Syntax autocommands and set the default methods for highlighting.
line 20: runtime syntax/synload.vim
Searching for "syntax/synload.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/synload.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/synload.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/synload.vim"
line 20: sourcing "C:\Program Files\Vim\vim90\syntax\synload.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up for syntax highlighting.
line 7: " It is loaded from "syntax.vim" and "manual.vim".
line 8: " 1. Set the default highlight groups.
line 9: " 2. Install Syntax autocommands for all the available syntax files.
line 10: 
line 11: if !has("syntax")
line 12:   finish
line 13: endif
line 14: 
line 15: " let others know that syntax has been switched on
line 16: let syntax_on = 1
line 17: 
line 18: " Set the default highlighting colors.  Use a color scheme if specified.
line 19: if exists("colors_name")
line 20:   exe "colors " . colors_name
line 21: else
line 22:   runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 22: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
Searching for "colors/lists/default.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim\vim90\colors/lists/default.vim"
line 37: sourcing "C:\Program Files\Vim\vim90\colors\lists\default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2023 Apr 19
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: 
line 10: " make sure line continuation works
line 11: let s:keepcpo = &cpo
line 12: set cpo&vim
line 13: 
line 14: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b
line 804: 
line 805: let &cpo = s:keepcpo
line 806: unlet s:keepcpo
line 807: 
line 808: "vim: sw=4
finished sourcing C:\Program Files\Vim\vim90\colors\lists\default.vim
continuing in C:\Program Files\Vim\vim90\syntax\syncolor.vim
Searching for "C:\Users\chris/vimfiles/after\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\colors/lists/default.vim"
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Program Files\Vim\vim90\syntax\synload.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 23: endif
line 24: 
line 25: " Line continuation is used here, remove 'C' from 'cpoptions'
line 26: let s:cpo_save = &cpo
line 27: set cpo&vim
line 28: 
line 29: " First remove all old syntax autocommands.
line 30: au! Syntax
line 31: 
line 32: au Syntax *^I^Icall s:SynSet()
line 33: 
line 34: fun! s:SynSet()
line 64: 
line 65: 
line 66: " Handle adding doxygen to other languages (C, C++, C#, IDL, java, php, DataScript)
line 67: au Syntax c,cpp,cs,idl,java,php,datascript if (exists('b:load_doxygen_syntax') && b:load_doxygen_syntax)^I|| (exists('g:load_doxygen_syntax') && g:load_doxygen_syntax)   | runtime! syntax/doxygen.vim | endif
line 72: 
line 73: 
line 74: " Source the user-specified syntax highlighting file
line 75: if exists("mysyntaxfile")
line 76:   let s:fname = expand(mysyntaxfile)
line 77:   if filereadable(s:fname)
line 78:     execute "source " . fnameescape(s:fname)
line 79:   endif
line 80: endif
line 81: 
line 82: " Restore 'cpoptions'
line 83: let &cpo = s:cpo_save
line 84: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\syntax\synload.vim
continuing in C:\Program Files\Vim\vim90\syntax\syntax.vim
line 21: 
line 22: " Load the FileType autocommands if not done yet.
line 23: if exists("did_load_filetypes")
line 24:   let s:did_ft = 1
line 25: else
line 26:   filetype on
Searching for "filetype.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\filetype.vim"
Searching for "C:\Program Files\Vim/vimfiles\filetype.vim"
Searching for "C:\Program Files\Vim\vim90\filetype.vim"
line 26: sourcing "C:\Program Files\Vim\vim90\filetype.vim"
line 1: " Vim support file to detect file types
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 10
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: " Listen very carefully, I will say this only once
line 8: if exists("did_load_filetypes")
line 9:   finish
line 10: endif
line 11: let did_load_filetypes = 1
line 12: 
line 13: " Line continuation is used here, remove 'C' from 'cpoptions'
line 14: let s:cpo_save = &cpo
line 15: set cpo&vim
line 16: 
line 17: augroup filetypedetect
line 18: 
line 19: " Ignored extensions
line 20: if exists("*fnameescape")
line 21: au BufNewFile,BufRead ?\+.orig,?\+.bak,?\+.old,?\+.new,?\+.dpkg-dist,?\+.dpkg-old,?\+.dpkg-new,?\+.dpkg-bak,?\+.rpmsave,?\+.rpmnew,?\+.pacsave,?\+.pacnew exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r"))
line 23: au BufNewFile,BufRead *~ let s:name = expand("<afile>") | let s:short = substitute(s:name, '\~\+$', '', '') | if s:name != s:short && s:short != "" |   exe "doau filetypedetect BufRead " . fnameescape(s:short) | endif | unlet! s:name s:short
line 30: au BufNewFile,BufRead ?\+.in if expand("<afile>:t") != "configure.in" |   exe "doau filetypedetect BufRead " . fnameescape(expand("<afile>:r")) | endif
line 34: elseif &verbose > 0
line 35:   echomsg "Warning: some filetypes will not be recognized because this version of Vim does not have fnameescape()"
line 36: endif
line 37: 
line 38: " Pattern used to match file names which should not be inspected.
line 39: " Currently finds compressed files.
line 40: if !exists("g:ft_ignore_pat")
line 41:   let g:ft_ignore_pat = '\.\(Z\|gz\|bz2\|zip\|tgz\)$'
line 42: endif
line 43: 
line 44: " Function used for patterns that end in a star: don't set the filetype if the
line 45: " file name matches ft_ignore_pat.
line 46: " When using this, the entry should probably be further down below with the
line 47: " other StarSetf() calls.
line 48: func s:StarSetf(ft)
line 53: 
line 54: " Vim help file
line 55: au BufNewFile,BufRead $VIMRUNTIME/doc/*.txt^Isetf help
line 56: 
line 57: " Abaqus or Trasys
line 58: au BufNewFile,BufRead *.inp^I^I^Icall dist#ft#Check_inp()
line 59: 
line 60: " 8th (Firth-derivative)
line 61: au BufNewFile,BufRead *.8th^I^I^Isetf 8th
line 62: 
line 63: " A-A-P recipe
line 64: au BufNewFile,BufRead *.aap^I^I^Isetf aap
line 65: 
line 66: " A2ps printing utility
line 67: au BufNewFile,BufRead */etc/a2ps.cfg,*/etc/a2ps/*.cfg,a2psrc,.a2psrc setf a2ps
line 68: 
line 69: " ABAB/4
line 70: au BufNewFile,BufRead *.abap^I^I^Isetf abap
line 71: 
line 72: " ABC music notation
line 73: au BufNewFile,BufRead *.abc^I^I^Isetf abc
line 74: 
line 75: " ABEL
line 76: au BufNewFile,BufRead *.abl^I^I^Isetf abel
line 77: 
line 78: " AceDB
line 79: au BufNewFile,BufRead *.wrm^I^I^Isetf acedb
line 80: 
line 81: " Ada (83, 9X, 95)
line 82: au BufNewFile,BufRead *.adb,*.ads,*.ada^I^Isetf ada
line 83: if has("vms")
line 84:   au BufNewFile,BufRead *.gpr,*.ada_m,*.adc^Isetf ada
line 85: else
line 86:   au BufNewFile,BufRead *.gpr^I^I^Isetf ada
line 87: endif
line 88: 
line 89: " AHDL
line 90: au BufNewFile,BufRead *.tdf^I^I^Isetf ahdl
line 91: 
line 92: " AIDL
line 93: au BufNewFile,BufRead *.aidl^I^I^Isetf aidl
line 94: 
line 95: " AMPL
line 96: au BufNewFile,BufRead *.run^I^I^Isetf ampl
line 97: 
line 98: " Ant
line 99: au BufNewFile,BufRead build.xml^I^I^Isetf ant
line 100: 
line 101: " Arduino
line 102: au BufNewFile,BufRead *.ino,*.pde^I^Isetf arduino
line 103: 
line 104: " Apache config file
line 105: au BufNewFile,BufRead .htaccess,*/etc/httpd/*.conf^I^Isetf apache
line 106: au BufNewFile,BufRead */etc/apache2/sites-*/*.com^I^Isetf apache
line 107: 
line 108: " XA65 MOS6510 cross assembler
line 109: au BufNewFile,BufRead *.a65^I^I^Isetf a65
line 110: 
line 111: " Applescript
line 112: au BufNewFile,BufRead *.scpt^I^I^Isetf applescript
line 113: 
line 114: " Automake (must be before the *.am pattern)
line 115: au BufNewFile,BufRead [mM]akefile.am,GNUmakefile.am^Isetf automake
line 116: 
line 117: " Applix ELF
line 118: au BufNewFile,BufRead *.am^I^I^Isetf elf
line 119: 
line 120: " ALSA configuration
line 121: au BufNewFile,BufRead .asoundrc,*/usr/share/alsa/alsa.conf,*/etc/asound.conf setf alsaconf
line 122: 
line 123: " Arc Macro Language
line 124: au BufNewFile,BufRead *.aml^I^I^Isetf aml
line 125: 
line 126: " APT config file
line 127: au BufNewFile,BufRead apt.conf^I^I       setf aptconf
line 128: au BufNewFile,BufRead */.aptitude/config       setf aptconf
line 129: " more generic pattern far down
line 130: 
line 131: " Arch Inventory file
line 132: au BufNewFile,BufRead .arch-inventory,=tagging-method^Isetf arch
line 133: 
line 134: " ART*Enterprise (formerly ART-IM)
line 135: au BufNewFile,BufRead *.art^I^I^Isetf art
line 136: 
line 137: " AsciiDoc
line 138: au BufNewFile,BufRead *.asciidoc,*.adoc^I^Isetf asciidoc
line 139: 
line 140: " ASN.1
line 141: au BufNewFile,BufRead *.asn,*.asn1^I^Isetf asn
line 142: 
line 143: " Active Server Pages (with Visual Basic Script)
line 144: au BufNewFile,BufRead *.asa if exists("g:filetype_asa") |   exe "setf " . g:filetype_asa | else |   setf aspvbs | endif
line 150: 
line 151: " Active Server Pages (with Perl or Visual Basic Script)
line 152: au BufNewFile,BufRead *.asp if exists("g:filetype_asp") |   exe "setf " . g:filetype_asp | elseif getline(1) . getline(2) . getline(3) =~? "perlscript" |   setf aspperl | else |   setf aspvbs | endif
line 160: 
line 161: " Grub (must be before pattern *.lst)
line 162: au BufNewFile,BufRead */boot/grub/menu.lst,*/boot/grub/grub.conf,*/etc/grub.conf setf grub
line 163: 
line 164: " Maxima, see:
line 165: " https://maxima.sourceforge.io/docs/manual/maxima_71.html#file_005ftype_005fmaxima
line 166: " Must be before the pattern *.mac.
line 167: " *.dem omitted - also used by gnuplot demos
line 168: " *.mc omitted - used by dist#ft#McSetf()
line 169: au BufNewFile,BufRead *.demo,*.dm{1,2,3,t},*.wxm,maxima-init.mac setf maxima
line 170: 
line 171: " Assembly (all kinds)
line 172: " *.lst is not pure assembly, it has two extra columns (address, byte codes)
line 173: au BufNewFile,BufRead *.asm,*.[sS],*.[aA],*.mac,*.lst^Icall dist#ft#FTasm()
line 174: 
line 175: " Assembly - Macro (VAX)
line 176: au BufNewFile,BufRead *.mar^I^I^Isetf vmasm
line 177: 
line 178: " Astro
line 179: au BufNewFile,BufRead *.astro^I^I^Isetf astro
line 180: 
line 181: " Atlas
line 182: au BufNewFile,BufRead *.atl,*.as^I^Isetf atlas
line 183: 
line 184: " Atom is based on XML
line 185: au BufNewFile,BufRead *.atom^I^I^Isetf xml
line 186: 
line 187: " Authzed
line 188: au BufNewFile,BufRead *.zed^I^I^Isetf authzed
line 189: 
line 190: " Autoit v3
line 191: au BufNewFile,BufRead *.au3^I^I^Isetf autoit
line 192: 
line 193: " Autohotkey
line 194: au BufNewFile,BufRead *.ahk^I^I^Isetf autohotkey
line 195: 
line 196: " Autotest .at files are actually m4
line 197: au BufNewFile,BufRead *.at^I^I^Isetf m4
line 198: 
line 199: " Avenue
line 200: au BufNewFile,BufRead *.ave^I^I^Isetf ave
line 201: 
line 202: " Awk
line 203: au BufNewFile,BufRead *.awk,*.gawk^I^Isetf awk
line 204: 
line 205: " B
line 206: au BufNewFile,BufRead *.mch,*.ref,*.imp^I^Isetf b
line 207: 
line 208: " BASIC or Visual Basic
line 209: au BufNewFile,BufRead *.bas^I^I^Icall dist#ft#FTbas()
line 210: au BufNewFile,BufRead *.bi,*.bm^I^I^Icall dist#ft#FTbas()
line 211: 
line 212: " Bass
line 213: au BufNewFile,BufRead *.bass^I^I^Isetf bass
line 214: 
line 215: " IBasic file (similar to QBasic)
line 216: au BufNewFile,BufRead *.iba,*.ibi^I^Isetf ibasic
line 217: 
line 218: " FreeBasic file (similar to QBasic)
line 219: au BufNewFile,BufRead *.fb^I^I^Isetf freebasic
line 220: 
line 221: " Batch file for MSDOS. See dist#ft#FTsys for *.sys
line 222: au BufNewFile,BufRead *.bat^I^I^Isetf dosbatch
line 223: " *.cmd is close to a Batch file, but on OS/2 Rexx files also use *.cmd.
line 224: au BufNewFile,BufRead *.cmd if getline(1) =~ '^/\*' | setf rexx | else | setf dosbatch | endif
line 226: " ABB RAPID or Batch file for MSDOS.
line 227: au BufNewFile,BufRead *.sys\c^I^I^Icall dist#ft#FTsys()
line 228: 
line 229: " Batch file for 4DOS
line 230: au BufNewFile,BufRead *.btm^I^I^Icall dist#ft#FTbtm()
line 231: 
line 232: " BC calculator
line 233: au BufNewFile,BufRead *.bc^I^I^Isetf bc
line 234: 
line 235: " BDF font
line 236: au BufNewFile,BufRead *.bdf^I^I^Isetf bdf
line 237: 
line 238: " Beancount
line 239: au BufNewFile,BufRead *.beancount^I^Isetf beancount
line 240: 
line 241: " BibTeX bibliography database file
line 242: au BufNewFile,BufRead *.bib^I^I^Isetf bib
line 243: 
line 244: " BibTeX Bibliography Style
line 245: au BufNewFile,BufRead *.bst^I^I^Isetf bst
line 246: 
line 247: " Bicep
line 248: au BufNewFile,BufRead *.bicep,*.bicepparam^I^I^Isetf bicep
line 249: 
line 250: " BIND configuration
line 251: " sudoedit uses namedXXXX.conf
line 252: au BufNewFile,BufRead named*.conf,rndc*.conf,rndc*.key^Isetf named
line 253: 
line 254: " BIND zone
line 255: au BufNewFile,BufRead named.root^I^Isetf bindzone
line 256: au BufNewFile,BufRead *.db^I^I^Icall dist#ft#BindzoneCheck('')
line 257: 
line 258: " Blade
line 259: au BufNewFile,BufRead *.blade.php^I^Isetf blade
line 260: 
line 261: " Blank
line 262: au BufNewFile,BufRead *.bl^I^I^Isetf blank
line 263: 
line 264: " Bitbake
line 265: au BufNewFile,BufRead *.bb,*.bbappend,*.bbclass,*/build/conf/*.conf,*/meta{-*,}/conf/*.conf^Isetf bitbake
line 266: 
line 267: " Blkid cache file
line 268: au BufNewFile,BufRead */etc/blkid.tab,*/etc/blkid.tab.old   setf xml
line 269: 
line 270: " BSDL
line 271: au BufNewFile,BufRead *.bsd,*.bsdl^I^I^Isetf bsdl
line 272: 
line 273: " Bazel (https://bazel.build) and Buck2 (https://buck2.build/)
line 274: autocmd BufRead,BufNewFile *.bzl,*.bazel,WORKSPACE,WORKSPACE.bzlmod^Isetf bzl
line 275: if has("fname_case")
line 276:   " There is another check for BUILD and BUCK further below.
line 277:   autocmd BufRead,BufNewFile *.BUILD,BUILD,BUCK^I^Isetf bzl
line 278: endif
line 279: 
line 280: " Busted (Lua unit testing framework - configuration files)
line 281: au BufNewFile,BufRead .busted^I^I^Isetf lua
line 282: 
line 283: " C or lpc
line 284: au BufNewFile,BufRead *.c^I^I^Icall dist#ft#FTlpc()
line 285: au BufNewFile,BufRead *.lpc,*.ulpc^I^Isetf lpc
line 286: 
line 287: " Cairo
line 288: au BufNewFile,BufRead *.cairo^I^I^Isetf cairo
line 289: 
line 290: " Calendar
line 291: au BufNewFile,BufRead calendar^I^I^Isetf calendar
line 292: 
line 293: " Cap'n Proto
line 294: au BufNewFile,BufRead *.capnp^I^I^Isetf capnp
line 295: 
line 296: " C#
line 297: au BufNewFile,BufRead *.cs,*.csx^I^Isetf cs
line 298: 
line 299: " CSDL
line 300: au BufNewFile,BufRead *.csdl^I^I^Isetf csdl
line 301: 
line 302: " Cabal
line 303: au BufNewFile,BufRead *.cabal^I^I^Isetf cabal
line 304: 
line 305: " Cdrdao TOC
line 306: au BufNewFile,BufRead *.toc^I^I^Isetf cdrtoc
line 307: 
line 308: " Cdrdao config
line 309: au BufNewFile,BufRead */etc/cdrdao.conf,*/etc/defaults/cdrdao,*/etc/default/cdrdao,.cdrdao^Isetf cdrdaoconf
line 310: 
line 311: " Cfengine
line 312: au BufNewFile,BufRead cfengine.conf^I^Isetf cfengine
line 313: 
line 314: " ChaiScript
line 315: au BufRead,BufNewFile *.chai^I^I^Isetf chaiscript
line 316: 
line 317: " Chatito
line 318: au BufNewFile,BufRead *.chatito^I^I^Isetf chatito
line 319: 
line 320: " Comshare Dimension Definition Language
line 321: au BufNewFile,BufRead *.cdl^I^I^Isetf cdl
line 322: 
line 323: " Conary Recipe
line 324: au BufNewFile,BufRead *.recipe^I^I^Isetf conaryrecipe
line 325: 
line 326: " Corn config file
line 327: au BufNewFile,BufRead *.corn^I^I^Isetf corn
line 328: 
line 329: " ChainPack Object Notation (CPON)
line 330: au BufNewFile,BufRead *.cpon^I^I^Isetf cpon
line 331: 
line 332: " Controllable Regex Mutilator
line 333: au BufNewFile,BufRead *.crm^I^I^Isetf crm
line 334: 
line 335: " Cyn++
line 336: au BufNewFile,BufRead *.cyn^I^I^Isetf cynpp
line 337: 
line 338: " Cynlib
line 339: " .cc and .cpp files can be C++ or Cynlib.
line 340: au BufNewFile,BufRead *.cc if exists("cynlib_syntax_for_cc")|setf cynlib|else|setf cpp|endif
line 342: au BufNewFile,BufRead *.cpp if exists("cynlib_syntax_for_cpp")|setf cynlib|else|setf cpp|endif
line 344: 
line 345: " Cypher query language
line 346: au BufNewFile,BufRead *.cypher^I^I^Isetf cypher
line 347: 
line 348: " C++
line 349: au BufNewFile,BufRead *.cxx,*.c++,*.hh,*.hxx,*.hpp,*.ipp,*.moc,*.tcc,*.inl setf cpp
line 350: if has("fname_case")
line 351:   au BufNewFile,BufRead *.C,*.H setf cpp
line 352: endif
line 353: 
line 354: " C++ 20 modules (clang)
line 355: " https://clang.llvm.org/docs/StandardCPlusPlusModules.html#file-name-requirement
line 356: au BufNewFile,BufRead *.cppm,*.ccm,*.cxxm,*.c++m setf cpp
line 357: 
line 358: " .h files can be C, Ch C++, ObjC or ObjC++.
line 359: " Set c_syntax_for_h if you want C, ch_syntax_for_h if you want Ch. ObjC is
line 360: " detected automatically.
line 361: au BufNewFile,BufRead *.h^I^I^Icall dist#ft#FTheader()
line 362: 
line 363: " Ch (CHscript)
line 364: au BufNewFile,BufRead *.chf^I^I^Isetf ch
line 365: 
line 366: " TLH files are C++ headers generated by Visual C++'s #import from typelibs
line 367: au BufNewFile,BufRead *.tlh^I^I^Isetf cpp
line 368: 
line 369: " Cascading Style Sheets
line 370: au BufNewFile,BufRead *.css^I^I^Isetf css
line 371: 
line 372: " Century Term Command Scripts (*.cmd too)
line 373: au BufNewFile,BufRead *.con^I^I^Isetf cterm
line 374: 
line 375: " Changelog
line 376: au BufNewFile,BufRead changelog.Debian,changelog.dch,NEWS.Debian,NEWS.dch,*/debian/changelog^Isetf debchangelog
line 378: 
line 379: au BufNewFile,BufRead [cC]hange[lL]og  if getline(1) =~ '; urgency='|   setf debchangelog| else|   setf changelog| endif
line 385: 
line 386: au BufNewFile,BufRead NEWS  if getline(1) =~ '; urgency='|   setf debchangelog| endif
line 390: 
line 391: " CHILL
line 392: au BufNewFile,BufRead *..ch^I^I^Isetf chill
line 393: 
line 394: " Changes for WEB and CWEB or CHILL
line 395: au BufNewFile,BufRead *.ch^I^I^Icall dist#ft#FTchange()
line 396: 
line 397: " ChordPro
line 398: au BufNewFile,BufRead *.chopro,*.crd,*.cho,*.crdpro,*.chordpro^Isetf chordpro
line 399: 
line 400: " Clangd
line 401: au BufNewFile,BufRead .clangd^I^I^Isetf yaml
line 402: 
line 403: " Clang-format
line 404: au BufNewFile,BufRead .clang-format^I^Isetf yaml
line 405: 
line 406: " Clang-tidy
line 407: au BufNewFile,BufRead .clang-tidy^I^Isetf yaml
line 408: 
line 409: " Clean
line 410: au BufNewFile,BufRead *.dcl,*.icl^I^Isetf clean
line 411: 
line 412: " Clever
line 413: au BufNewFile,BufRead *.eni^I^I^Isetf cl
line 414: 
line 415: " Clever or dtd
line 416: au BufNewFile,BufRead *.ent^I^I^Icall dist#ft#FTent()
line 417: 
line 418: " Clipper, FoxPro, ABB RAPID or eviews
line 419: au BufNewFile,BufRead *.prg\c^I^I^Icall dist#ft#FTprg()
line 420: 
line 421: " Clojure
line 422: au BufNewFile,BufRead *.clj,*.cljs,*.cljx,*.cljc^I^Isetf clojure
line 423: 
line 424: " Cmake
line 425: au BufNewFile,BufRead CMakeLists.txt,*.cmake,*.cmake.in^I^Isetf cmake
line 426: 
line 427: " Cmusrc
line 428: au BufNewFile,BufRead */.cmus/{autosave,rc,command-history,*.theme} setf cmusrc
line 429: au BufNewFile,BufRead */cmus/{rc,*.theme}^I^I^Isetf cmusrc
line 430: 
line 431: " Cobol
line 432: au BufNewFile,BufRead *.cbl,*.cob,*.lib^Isetf cobol
line 433: "   cobol or zope form controller python script? (heuristic)
line 434: au BufNewFile,BufRead *.cpy if getline(1) =~ '^##' |   setf python | else |   setf cobol | endif
line 440: 
line 441: " Coco/R
line 442: au BufNewFile,BufRead *.atg^I^I^Isetf coco
line 443: 
line 444: " Cold Fusion
line 445: au BufNewFile,BufRead *.cfm,*.cfi,*.cfc^I^Isetf cf
line 446: 
line 447: " Configure scripts
line 448: au BufNewFile,BufRead configure.in,configure.ac setf config
line 449: 
line 450: " Cooklang
line 451: au BufNewFile,BufRead *.cook^I^I^Isetf cook
line 452: 
line 453: " Clinical Quality Language (CQL)
line 454: " .cql is also mentioned as the 'XDCC Catcher queue list' file extension.
line 455: " If support for XDCC Catcher is needed in the future, the contents of the file
line 456: " needs to be inspected.
line 457: au BufNewFile,BufRead *.cql^I^I^Isetf cqlang
line 458: 
line 459: " Crystal
line 460: au BufNewFile,BufRead *.cr^I^I^Isetf crystal
line 461: 
line 462: " CSV Files
line 463: au BufNewFile,BufRead *.csv^I^I^Isetf csv
line 464: 
line 465: " CUDA Compute Unified Device Architecture
line 466: au BufNewFile,BufRead *.cu,*.cuh^I^Isetf cuda
line 467: 
line 468: " Cue
line 469: au BufNewFile,BufRead *.cue^I^I^Isetf cue
line 470: 
line 471: " Dockerfile; Podman uses the same syntax with name Containerfile
line 472: " Also see Dockerfile.* below.
line 473: au BufNewFile,BufRead Containerfile,Dockerfile,dockerfile,*.[dD]ockerfile^Isetf dockerfile
line 474: 
line 475: " WildPackets EtherPeek Decoder
line 476: au BufNewFile,BufRead *.dcd^I^I^Isetf dcd
line 477: 
line 478: " Enlightenment configuration files
line 479: au BufNewFile,BufRead *enlightenment/*.cfg^Isetf c
line 480: 
line 481: " Eterm
line 482: au BufNewFile,BufRead *Eterm/*.cfg^I^Isetf eterm
line 483: 
line 484: " Elixir or Euphoria
line 485: au BufNewFile,BufRead *.ex call dist#ft#ExCheck()
line 486: 
line 487: " Elixir
line 488: au BufRead,BufNewFile mix.lock,*.exs setf elixir
line 489: au BufRead,BufNewFile *.eex,*.leex setf eelixir
line 490: 
line 491: " Elvish
line 492: au BufRead,BufNewFile *.elv setf elvish
line 493: 
line 494: " Euphoria 3 or 4
line 495: au BufNewFile,BufRead *.eu,*.ew,*.exu,*.exw  call dist#ft#EuphoriaCheck()
line 496: if has("fname_case")
line 497:    au BufNewFile,BufRead *.EU,*.EW,*.EX,*.EXU,*.EXW  call dist#ft#EuphoriaCheck()
line 498: endif
line 499: 
line 500: " Lynx config files
line 501: au BufNewFile,BufRead lynx.cfg^I^I^Isetf lynx
line 502: 
line 503: " LyRiCs
line 504: au BufNewFile,BufRead *.lrc^I^I^Isetf lyrics
line 505: 
line 506: " Modula-3 configuration language (must be before *.cfg and *makefile)
line 507: au BufNewFile,BufRead *.quake,cm3.cfg^I^Isetf m3quake
line 508: au BufNewFile,BufRead m3makefile,m3overrides^Isetf m3build
line 509: 
line 510: " Quake
line 511: au BufNewFile,BufRead *baseq[2-3]/*.cfg,*id1/*.cfg^Isetf quake
line 512: au BufNewFile,BufRead *quake[1-3]/*.cfg^I^I^Isetf quake
line 513: 
line 514: " Quake C
line 515: au BufNewFile,BufRead *.qc^I^I^Isetf c
line 516: 
line 517: " Configure files
line 518: au BufNewFile,BufRead *.cfg\c^I^I^Icall dist#ft#FTcfg()
line 519: 
line 520: " Cucumber
line 521: au BufNewFile,BufRead *.feature^I^I^Isetf cucumber
line 522: 
line 523: " Communicating Sequential Processes
line 524: au BufNewFile,BufRead *.csp,*.fdr^I^Isetf csp
line 525: 
line 526: " CUPL logic description and simulation
line 527: au BufNewFile,BufRead *.pld^I^I^Isetf cupl
line 528: au BufNewFile,BufRead *.si^I^I^Isetf cuplsim
line 529: 
line 530: " Dart
line 531: au BufRead,BufNewfile *.dart,*.drt^I^Isetf dart
line 532: 
line 533: " Debian Control
line 534: au BufNewFile,BufRead */debian/control^I^Isetf debcontrol
line 535: au BufNewFile,BufRead control  if getline(1) =~ '^Source:'|   setf debcontrol| endif
line 539: 
line 540: " Debian Copyright
line 541: au BufNewFile,BufRead */debian/copyright^Isetf debcopyright
line 542: au BufNewFile,BufRead copyright  if getline(1) =~ '^Format:'|   setf debcopyright| endif
line 546: 
line 547: " Debian Sources.list
line 548: au BufNewFile,BufRead */etc/apt/sources.list^I^Isetf debsources
line 549: au BufNewFile,BufRead */etc/apt/sources.list.d/*.list^Isetf debsources
line 550: au BufNewFile,BufRead */etc/apt/sources.list.d/*.sources^Isetf deb822sources
line 551: 
line 552: " Deny hosts
line 553: au BufNewFile,BufRead denyhosts.conf^I^Isetf denyhosts
line 554: 
line 555: " Dhall
line 556: au BufNewFile,BufRead *.dhall^I^I^Isetf dhall
line 557: 
line 558: " dnsmasq(8) configuration files
line 559: au BufNewFile,BufRead */etc/dnsmasq.conf^Isetf dnsmasq
line 560: 
line 561: " ROCKLinux package description
line 562: au BufNewFile,BufRead *.desc^I^I^Isetf desc
line 563: 
line 564: " the D language or dtrace
line 565: au BufNewFile,BufRead */dtrace/*.d^I^Isetf dtrace
line 566: au BufNewFile,BufRead *.d^I^I^Icall dist#ft#DtraceCheck()
line 567: 
line 568: " Desktop files
line 569: au BufNewFile,BufRead *.desktop,*.directory^Isetf desktop
line 570: 
line 571: " Dict config
line 572: au BufNewFile,BufRead dict.conf,.dictrc^I^Isetf dictconf
line 573: 
line 574: " Dictd config
line 575: au BufNewFile,BufRead dictd*.conf^I^Isetf dictdconf
line 576: 
line 577: " DEP3 formatted patch files
line 578: au BufNewFile,BufRead */debian/patches/*^Icall dist#ft#Dep3patch()
line 579: 
line 580: " Diff files
line 581: au BufNewFile,BufRead *.diff,*.rej^I^Isetf diff
line 582: au BufNewFile,BufRead *.patch if getline(1) =~# '^From [0-9a-f]\{40,\} Mon Sep 17 00:00:00 2001$' |   setf gitsendemail | else |   setf diff | endif
line 588: 
line 589: " Dircolors
line 590: au BufNewFile,BufRead .dir_colors,.dircolors,*/etc/DIR_COLORS^Isetf dircolors
line 591: 
line 592: " Diva (with Skill) or InstallShield
line 593: au BufNewFile,BufRead *.rul if getline(1).getline(2).getline(3).getline(4).getline(5).getline(6) =~? 'InstallShield' |   setf ishd | else |   setf diva | endif
line 599: 
line 600: " DCL (Digital Command Language - vms) or DNS zone file
line 601: au BufNewFile,BufRead *.com^I^I^Icall dist#ft#BindzoneCheck('dcl')
line 602: 
line 603: " DOT
line 604: au BufNewFile,BufRead *.dot,*.gv^I^Isetf dot
line 605: 
line 606: " Dune
line 607: au BufNewFile,BufRead jbuild,dune,dune-project,dune-workspace setf dune
line 608: 
line 609: " Dylan - lid files
line 610: au BufNewFile,BufRead *.lid^I^I^Isetf dylanlid
line 611: 
line 612: " Dylan - intr files (melange)
line 613: au BufNewFile,BufRead *.intr^I^I^Isetf dylanintr
line 614: 
line 615: " Dylan
line 616: au BufNewFile,BufRead *.dylan^I^I^Isetf dylan
line 617: 
line 618: " Microsoft Module Definition
line 619: au BufNewFile,BufRead *.def^I^I^Isetf def
line 620: 
line 621: " Dracula
line 622: au BufNewFile,BufRead *.drac,*.drc,*lvs,*lpe^Isetf dracula
line 623: 
line 624: " Datascript
line 625: au BufNewFile,BufRead *.ds^I^I^Isetf datascript
line 626: 
line 627: " dsl: DSSSL or Structurizr
line 628: au BufNewFile,BufRead *.dsl if getline(1) =~ '^\s*<\!' |   setf dsl | else |   setf structurizr | endif
line 634: 
line 635: " DTD (Document Type Definition for XML)
line 636: au BufNewFile,BufRead *.dtd^I^I^Isetf dtd
line 637: 
line 638: " DTS/DSTI (device tree files)
line 639: au BufNewFile,BufRead *.dts,*.dtsi^I^Isetf dts
line 640: 
line 641: " EDIF (*.edf,*.edif,*.edn,*.edo) or edn
line 642: au BufNewFile,BufRead *.ed\(f\|if\|o\)^I^Isetf edif
line 643: au BufNewFile,BufRead *.edn if getline(1) =~ '^\s*(\s*edif\>' |   setf edif | else |   setf clojure | endif
line 649: 
line 650: " EditorConfig
line 651: au BufNewFile,BufRead .editorconfig^I^Isetf editorconfig
line 652: 
line 653: " Embedix Component Description
line 654: au BufNewFile,BufRead *.ecd^I^I^Isetf ecd
line 655: 
line 656: " Eiffel or Specman or Euphoria
line 657: au BufNewFile,BufRead *.e,*.E^I^I^Icall dist#ft#FTe()
line 658: 
line 659: " Elinks configuration
line 660: au BufNewFile,BufRead elinks.conf^I^Isetf elinks
line 661: 
line 662: " ERicsson LANGuage; Yaws is erlang too
line 663: au BufNewFile,BufRead *.erl,*.hrl,*.yaws^Isetf erlang
line 664: 
line 665: " Elm
line 666: au BufNewFile,BufRead *.elm^I^I^Isetf elm
line 667: 
line 668: " Elm Filter Rules file
line 669: au BufNewFile,BufRead filter-rules^I^Isetf elmfilt
line 670: 
line 671: " Elsa - https://github.com/ucsd-progsys/elsa
line 672: au BufNewFile,BufRead *.lc^I^I^Isetf elsa
line 673: 
line 674: " EdgeDB Schema Definition Language
line 675: au BufNewFile,BufRead *.esdl^I^I^Isetf esdl
line 676: 
line 677: " ESMTP rc file
line 678: au BufNewFile,BufRead *esmtprc^I^I^Isetf esmtprc
line 679: 
line 680: " ESQL-C
line 681: au BufNewFile,BufRead *.ec,*.EC^I^I^Isetf esqlc
line 682: 
line 683: " Esterel
line 684: au BufNewFile,BufRead *.strl^I^I^Isetf esterel
line 685: 
line 686: " Essbase script
line 687: au BufNewFile,BufRead *.csc^I^I^Isetf csc
line 688: 
line 689: " Exim
line 690: au BufNewFile,BufRead exim.conf^I^I^Isetf exim
line 691: 
line 692: " Expect
line 693: au BufNewFile,BufRead *.exp^I^I^Isetf expect
line 694: 
line 695: " Exports
line 696: au BufNewFile,BufRead exports^I^I^Isetf exports
line 697: 
line 698: " Falcon
line 699: au BufNewFile,BufRead *.fal^I^I^Isetf falcon
line 700: 
line 701: " Fantom
line 702: au BufNewFile,BufRead *.fan,*.fwt^I^Isetf fan
line 703: 
line 704: " Factor
line 705: au BufNewFile,BufRead *.factor^I^I^Isetf factor
line 706: 
line 707: " Fennel
line 708: autocmd BufRead,BufNewFile *.fnl^I^Isetf fennel
line 709: 
line 710: " Fetchmail RC file
line 711: au BufNewFile,BufRead .fetchmailrc^I^Isetf fetchmail
line 712: 
line 713: " FIRRTL - Flexible Internal Representation for RTL
line 714: au BufNewFile,BufRead *.fir^I^I^Isetf firrtl
line 715: 
line 716: " Fish shell
line 717: au BufNewFile,BufRead *.fish^I^I^Isetf fish
line 718: 
line 719: " FlexWiki - disabled, because it has side effects when a .wiki file
line 720: " is not actually FlexWiki
line 721: "au BufNewFile,BufRead *.wiki^I^I^Isetf flexwiki
line 722: 
line 723: " Focus Executable
line 724: au BufNewFile,BufRead *.fex,*.focexec^I^Isetf focexec
line 725: 
line 726: " Focus Master file (but not for auto.master)
line 727: au BufNewFile,BufRead auto.master^I^Isetf conf
line 728: au BufNewFile,BufRead *.mas,*.master^I^Isetf master
line 729: 
line 730: " Forth
line 731: au BufNewFile,BufRead *.ft,*.fth,*.4th^I^Isetf forth
line 732: 
line 733: " Reva Forth
line 734: au BufNewFile,BufRead *.frt^I^I^Isetf reva
line 735: 
line 736: " Fortran
line 737: if has("fname_case")
line 738:   au BufNewFile,BufRead *.F,*.FOR,*.FPP,*.FTN,*.F77,*.F90,*.F95,*.F03,*.F08^Isetf fortran
line 739: endif
line 740: au BufNewFile,BufRead *.for,*.fortran,*.fpp,*.ftn,*.f77,*.f90,*.f95,*.f03,*.f08^Isetf fortran
line 741: 
line 742: " Fortran or Forth
line 743: au BufNewFile,BufRead *.f^I^I^Icall dist#ft#FTf()
line 744: 
line 745: " Framescript
line 746: au BufNewFile,BufRead *.fsl^I^I^Isetf framescript
line 747: 
line 748: " FStab
line 749: au BufNewFile,BufRead fstab,mtab^I^Isetf fstab
line 750: 
line 751: " Func
line 752: au BufNewFile,BufRead *.fc^I^I^Isetf func
line 753: 
line 754: " Fusion
line 755: au BufRead,BufNewFile *.fusion^I^I^Isetf fusion
line 756: 
line 757: " F# or Forth
line 758: au BufNewFile,BufRead *.fs^I^I^Icall dist#ft#FTfs()
line 759: 
line 760: " FHIR Shorthand (FSH)
line 761: au BufNewFile,BufRead *.fsh^I^I^Isetf fsh
line 762: 
line 763: " F#
line 764: au BufNewFile,BufRead *.fsi,*.fsx^I^Isetf fsharp
line 765: 
line 766: " GDB command files
line 767: au BufNewFile,BufRead .gdbinit,gdbinit,.gdbearlyinit,gdbearlyinit,*.gdb^I^Isetf gdb
line 768: 
line 769: " GDMO
line 770: au BufNewFile,BufRead *.mo,*.gdmo^I^Isetf gdmo
line 771: 
line 772: " GDscript
line 773: au BufNewFile,BufRead *.gd^I^I^Isetf gdscript
line 774: 
line 775: " Godot resource
line 776: au BufRead,BufNewFile *.tscn,*.tres^I^Isetf gdresource
line 777: 
line 778: " Godot shader
line 779: au BufRead,BufNewFile *.gdshader,*.shader^Isetf gdshader
line 780: 
line 781: " Gedcom
line 782: au BufNewFile,BufRead *.ged,lltxxxxx.txt^Isetf gedcom
line 783: 
line 784: " Gemtext
line 785: au BufNewFile,BufRead *.gmi,*.gemini^I^Isetf gemtext
line 786: 
line 787: " Gift (Moodle)
line 788: autocmd BufRead,BufNewFile *.gift^I^Isetf gift
line 789: 
line 790: " Git
line 791: au BufNewFile,BufRead COMMIT_EDITMSG,MERGE_MSG,TAG_EDITMSG^Isetf gitcommit
line 792: au BufNewFile,BufRead NOTES_EDITMSG,EDIT_DESCRIPTION^I^Isetf gitcommit
line 793: au BufNewFile,BufRead *.git/config,.gitconfig,*/etc/gitconfig^Isetf gitconfig
line 794: au BufNewFile,BufRead */.config/git/config^I^I^Isetf gitconfig
line 795: au BufNewFile,BufRead *.git/config.worktree^I^I^Isetf gitconfig
line 796: au BufNewFile,BufRead *.git/worktrees/*/config.worktree^I^Isetf gitconfig
line 797: au BufNewFile,BufRead .gitmodules,*.git/modules/*/config^Isetf gitconfig
line 798: if exists('$XDG_CONFIG_HOME')
line 799:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/config^I^Isetf gitconfig
line 800:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/attributes^I^Isetf gitattributes
line 801:   au BufNewFile,BufRead $XDG_CONFIG_HOME/git/ignore^I^Isetf gitignore
line 802: endif
line 803: au BufNewFile,BufRead .gitattributes,*.git/info/attributes^Isetf gitattributes
line 804: au BufNewFile,BufRead */.config/git/attributes^I^I^Isetf gitattributes
line 805: au BufNewFile,BufRead */etc/gitattributes^I^I^Isetf gitattributes
line 806: au BufNewFile,BufRead .gitignore,*.git/info/exclude^I^Isetf gitignore
line 807: au BufNewFile,BufRead */.config/git/ignore^I^I^Isetf gitignore
line 808: au BufNewFile,BufRead git-rebase-todo^I^I^I^Isetf gitrebase
line 809: au BufRead,BufNewFile .gitsendemail.msg.??????^I^I^Isetf gitsendemail
line 810: au BufNewFile,BufRead *.git/* if getline(1) =~# '^\x\{40,\}\>\|^ref: ' |   setf git | endif
line 814: 
line 815: " Gkrellmrc
line 816: au BufNewFile,BufRead gkrellmrc,gkrellmrc_?^Isetf gkrellmrc
line 817: 
line 818: " Gleam
line 819: au BufNewFile,BufRead *.gleam^I^I^Isetf gleam
line 820: 
line 821: " GLSL
line 822: au BufNewFile,BufRead *.glsl^I^I^Isetf glsl
line 823: 
line 824: " GN (generate ninja) files
line 825: au BufNewFile,BufRead *.gn,*.gni^I^Isetf gn
line 826: 
line 827: " GP scripts (2.0 and onward)
line 828: au BufNewFile,BufRead *.gp,.gprc^I^Isetf gp
line 829: 
line 830: " GPG
line 831: au BufNewFile,BufRead */.gnupg/options^I^Isetf gpg
line 832: au BufNewFile,BufRead */.gnupg/gpg.conf^I^Isetf gpg
line 833: au BufNewFile,BufRead */usr/*/gnupg/options.skel setf gpg
line 834: if !empty($GNUPGHOME)
line 835:   au BufNewFile,BufRead $GNUPGHOME/options^Isetf gpg
line 836:   au BufNewFile,BufRead $GNUPGHOME/gpg.conf^Isetf gpg
line 837: endif
line 838: 
line 839: " gnash(1) configuration files
line 840: au BufNewFile,BufRead gnashrc,.gnashrc,gnashpluginrc,.gnashpluginrc setf gnash
line 841: 
line 842: " Gitolite
line 843: au BufNewFile,BufRead gitolite.conf^I^Isetf gitolite
line 844: au BufNewFile,BufRead {,.}gitolite.rc,example.gitolite.rc^Isetf perl
line 845: 
line 846: " Glimmer-flavored TypeScript and JavaScript
line 847: au BufNewFile,BufRead *.gts^I^I^Isetf typescript.glimmer
line 848: au BufNewFile,BufRead *.gjs^I^I^Isetf javascript.glimmer
line 849: 
line 850: " Gnuplot scripts
line 851: au BufNewFile,BufRead *.gpi,.gnuplot^I^Isetf gnuplot
line 852: 
line 853: " Go (Google)
line 854: au BufNewFile,BufRead *.go^I^I^Isetf go
line 855: au BufNewFile,BufRead Gopkg.lock^I^Isetf toml
line 856: au BufRead,BufNewFile go.work^I^I^Isetf gowork
line 857: 
line 858: " GrADS scripts
line 859: au BufNewFile,BufRead *.gs^I^I^Isetf grads
line 860: 
line 861: " GraphQL
line 862: au BufNewFile,BufRead *.graphql,*.graphqls,*.gql^I^I^Isetf graphql
line 863: 
line 864: " Gretl
line 865: au BufNewFile,BufRead *.gretl^I^I^Isetf gretl
line 866: 
line 867: " Groovy
line 868: au BufNewFile,BufRead *.gradle,*.groovy,Jenkinsfile^I^Isetf groovy
line 869: 
line 870: " GNU Server Pages
line 871: au BufNewFile,BufRead *.gsp^I^I^Isetf gsp
line 872: 
line 873: " Group file
line 874: au BufNewFile,BufRead */etc/group,*/etc/group-,*/etc/group.edit,*/etc/gshadow,*/etc/gshadow-,*/etc/gshadow.edit,*/var/backups/group.bak,*/var/backups/gshadow.bak  setf group
line 875: 
line 876: " GTK RC
line 877: au BufNewFile,BufRead .gtkrc,gtkrc^I^Isetf gtkrc
line 878: 
line 879: " GYP
line 880: au BufNewFile,BufRead *.gyp,*.gypi^I^Isetf gyp
line 881: 
line 882: " Hack
line 883: au BufRead,BufNewFile *.hack,*.hackpartial^I^I^Isetf hack
line 884: 
line 885: " Haml
line 886: au BufNewFile,BufRead *.haml^I^I^Isetf haml
line 887: 
line 888: " Hamster Classic | Playground files
line 889: au BufNewFile,BufRead *.hsm^I^I^Isetf hamster
line 890: 
line 891: " Handlebars
line 892: au BufNewFile,BufRead *.hbs^I^I^Isetf handlebars
line 893: 
line 894: " Hare
line 895: au BufNewFile,BufRead *.ha^I^I^Isetf hare
line 896: 
line 897: " Haskell
line 898: au BufNewFile,BufRead *.hs,*.hsc,*.hs-boot,*.hsig setf haskell
line 899: au BufNewFile,BufRead *.lhs^I^I^Isetf lhaskell
line 900: au BufNewFile,BufRead *.chs^I^I^Isetf chaskell
line 901: au BufNewFile,BufRead cabal.project^I^Isetf cabalproject
line 902: au BufNewFile,BufRead $HOME/.cabal/config^Isetf cabalconfig
line 903: if exists('$XDG_CONFIG_HOME')
line 904:   au BufNewFile,BufRead $XDG_CONFIG_HOME/cabal/config setf cabalconfig
line 905: endif
line 906: au BufNewFile,BufRead $HOME/.config/cabal/config setf cabalconfig
line 907: au BufNewFile,BufRead cabal.config^I^Isetf cabalconfig
line 908: au BufNewFile,BufRead *.persistentmodels^Isetf haskellpersistent
line 909: 
line 910: " Haste
line 911: au BufNewFile,BufRead *.ht^I^I^Isetf haste
line 912: au BufNewFile,BufRead *.htpp^I^I^Isetf hastepreproc
line 913: 
line 914: " HCL
line 915: au BufRead,BufNewFile *.hcl^I^I^Isetf hcl
line 916: 
line 917: " Go checksum file (must be before *.sum Hercules)
line 918: au BufNewFile,BufRead go.sum,go.work.sum^Isetf gosum
line 919: 
line 920: " Hercules
line 921: au BufNewFile,BufRead *.vc,*.ev,*.sum,*.errsum^Isetf hercules
line 922: 
line 923: " HEEx
line 924: au BufRead,BufNewFile *.heex^I^I^Isetf heex
line 925: 
line 926: " HEX (Intel)
line 927: au BufNewFile,BufRead *.hex,*.h32^I^Isetf hex
line 928: 
line 929: " Hjson
line 930: au BufNewFile,BufRead *.hjson^I^I^Isetf hjson
line 931: 
line 932: " HLS Playlist (or another form of playlist)
line 933: au BufNewFile,BufRead *.m3u,*.m3u8^I^Isetf hlsplaylist
line 934: 
line 935: " Hollywood
line 936: au BufRead,BufNewFile *.hws^I^I^Isetf hollywood
line 937: 
line 938: " Hoon
line 939: au BufRead,BufNewFile *.hoon^I^I^Isetf hoon
line 940: 
line 941: " Tilde (must be before HTML)
line 942: au BufNewFile,BufRead *.t.html^I^I^Isetf tilde
line 943: 
line 944: " HTML (.shtml and .stm for server side)
line 945: au BufNewFile,BufRead *.html,*.htm,*.shtml,*.stm  call dist#ft#FThtml()
line 946: au BufNewFile,BufRead *.cshtml^I^I^Isetf html
line 947: 
line 948: " HTML with Ruby - eRuby
line 949: au BufNewFile,BufRead *.erb,*.rhtml^I^Isetf eruby
line 950: 
line 951: " HTML with M4
line 952: au BufNewFile,BufRead *.html.m4^I^I^Isetf htmlm4
line 953: 
line 954: " Some template.  Used to be HTML Cheetah.
line 955: au BufNewFile,BufRead *.tmpl^I^I^Isetf template
line 956: 
line 957: " Host config
line 958: au BufNewFile,BufRead */etc/host.conf^I^Isetf hostconf
line 959: 
line 960: " Hosts access
line 961: au BufNewFile,BufRead */etc/hosts.allow,*/etc/hosts.deny  setf hostsaccess
line 962: 
line 963: " Hurl
line 964: au BufRead,BufNewFile *.hurl^I^I^Isetf hurl
line 965: 
line 966: " Hyper Builder
line 967: au BufNewFile,BufRead *.hb^I^I^Isetf hb
line 968: 
line 969: " Httest
line 970: au BufNewFile,BufRead *.htt,*.htb^I^Isetf httest
line 971: 
line 972: " i3
line 973: au BufNewFile,BufRead */i3/config^I^Isetf i3config
line 974: au BufNewFile,BufRead */.i3/config^I^Isetf i3config
line 975: 
line 976: " sway
line 977: au BufNewFile,BufRead */sway/config^I^Isetf swayconfig
line 978: au BufNewFile,BufRead */.sway/config^I^Isetf swayconfig
line 979: 
line 980: " Icon
line 981: au BufNewFile,BufRead *.icn^I^I^Isetf icon
line 982: 
line 983: " IDL (Interface Description Language)
line 984: au BufNewFile,BufRead *.idl^I^I^Icall dist#ft#FTidl()
line 985: 
line 986: " Microsoft IDL (Interface Description Language)  Also *.idl
line 987: " MOF = WMI (Windows Management Instrumentation) Managed Object Format
line 988: au BufNewFile,BufRead *.odl,*.mof^I^Isetf msidl
line 989: 
line 990: " Icewm menu
line 991: au BufNewFile,BufRead */.icewm/menu^I^Isetf icemenu
line 992: 
line 993: " Indent profile (must come before IDL *.pro!)
line 994: au BufNewFile,BufRead .indent.pro^I^Isetf indent
line 995: au BufNewFile,BufRead indent.pro^I^Icall dist#ft#ProtoCheck('indent')
line 996: 
line 997: " IDL (Interactive Data Language)
line 998: au BufNewFile,BufRead *.pro^I^I^Icall dist#ft#ProtoCheck('idlang')
line 999: 
line 1000: " Indent RC
line 1001: au BufNewFile,BufRead indentrc^I^I^Isetf indent
line 1002: 
line 1003: " Inform
line 1004: au BufNewFile,BufRead *.inf,*.INF^I^Isetf inform
line 1005: 
line 1006: " Initng
line 1007: au BufNewFile,BufRead */etc/initng/*/*.i,*.ii^Isetf initng
line 1008: 
line 1009: " Innovation Data Processing
line 1010: au BufRead,BufNewFile upstream.dat\c,upstream.*.dat\c,*.upstream.dat\c^Isetf upstreamdat
line 1011: au BufRead,BufNewFile fdrupstream.log,upstream.log\c,upstream.*.log\c,*.upstream.log\c,UPSTREAM-*.log\c^Isetf upstreamlog
line 1012: au BufRead,BufNewFile upstreaminstall.log\c,upstreaminstall.*.log\c,*.upstreaminstall.log\c setf upstreaminstalllog
line 1013: au BufRead,BufNewFile usserver.log\c,usserver.*.log\c,*.usserver.log\c^Isetf usserverlog
line 1014: au BufRead,BufNewFile usw2kagt.log\c,usw2kagt.*.log\c,*.usw2kagt.log\c^Isetf usw2kagtlog
line 1015: 
line 1016: " Ipfilter
line 1017: au BufNewFile,BufRead ipf.conf,ipf6.conf,ipf.rules^Isetf ipfilter
line 1018: 
line 1019: " Informix 4GL (source - canonical, include file, I4GL+M4 preproc.)
line 1020: au BufNewFile,BufRead *.4gl,*.4gh,*.m4gl^Isetf fgl
line 1021: 
line 1022: " .INI file for MSDOS
line 1023: au BufNewFile,BufRead *.ini,*.INI^I^Isetf dosini
line 1024: 
line 1025: " SysV Inittab
line 1026: au BufNewFile,BufRead inittab^I^I^Isetf inittab
line 1027: 
line 1028: " Inno Setup
line 1029: au BufNewFile,BufRead *.iss^I^I^Isetf iss
line 1030: 
line 1031: " J
line 1032: au BufNewFile,BufRead *.ijs^I^I^Isetf j
line 1033: 
line 1034: " JAL
line 1035: au BufNewFile,BufRead *.jal,*.JAL^I^Isetf jal
line 1036: 
line 1037: " Jam
line 1038: au BufNewFile,BufRead *.jpl,*.jpr^I^Isetf jam
line 1039: 
line 1040: " Janet
line 1041: au BufNewFile,BufRead *.janet^I^I^Isetf janet
line 1042: 
line 1043: " Java
line 1044: au BufNewFile,BufRead *.java,*.jav^I^Isetf java
line 1045: 
line 1046: " JavaCC
line 1047: au BufNewFile,BufRead *.jj,*.jjt^I^Isetf javacc
line 1048: 
line 1049: " JavaScript, ECMAScript, ES module script, CommonJS script
line 1050: au BufNewFile,BufRead *.js,*.jsm,*.javascript,*.es,*.mjs,*.cjs   setf javascript
line 1051: 
line 1052: " JavaScript with React
line 1053: au BufNewFile,BufRead *.jsx^I^I^Isetf javascriptreact
line 1054: 
line 1055: " Java Server Pages
line 1056: au BufNewFile,BufRead *.jsp^I^I^Isetf jsp
line 1057: 
line 1058: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 1059: au BufNewFile,BufRead *.properties,*.properties_??,*.properties_??_??^Isetf jproperties
line 1060: " Eclipse preference files use Java Properties syntax
line 1061: au BufNewFile,BufRead org.eclipse.*.prefs^Isetf jproperties
line 1062: 
line 1063: " Jess
line 1064: au BufNewFile,BufRead *.clp^I^I^Isetf jess
line 1065: 
line 1066: " Jgraph
line 1067: au BufNewFile,BufRead *.jgr^I^I^Isetf jgraph
line 1068: 
line 1069: " Jovial
line 1070: au BufNewFile,BufRead *.jov,*.j73,*.jovial^Isetf jovial
line 1071: 
line 1072: " Jq
line 1073: au BufNewFile,BufRead *.jq^I^I^Isetf jq
line 1074: 
line 1075: " JSON5
line 1076: au BufNewFile,BufRead *.json5^I^I^Isetf json5
line 1077: 
line 1078: " JSON Patch (RFC 6902)
line 1079: au BufNewFile,BufRead *.json-patch^I^Isetf json
line 1080: 
line 1081: " Geojson is also json
line 1082: au BufNewFile,BufRead *.geojson^I^I^Isetf json
line 1083: 
line 1084: " Jupyter Notebook is also json
line 1085: au BufNewFile,BufRead *.ipynb^I^I^Isetf json
line 1086: 
line 1087: " Other files that look like json
line 1088: au BufNewFile,BufRead .prettierrc,.firebaserc,.stylelintrc^Isetf json
line 1089: 
line 1090: " JSONC (JSON with comments)
line 1091: au BufNewFile,BufRead *.jsonc,.babelrc,.eslintrc,.jsfmtrc^Isetf jsonc
line 1092: au BufNewFile,BufRead .jshintrc,.hintrc,.swrc,[jt]sconfig*.json^Isetf jsonc
line 1093: 
line 1094: " JSON
line 1095: au BufNewFile,BufRead *.json,*.jsonp,*.webmanifest^Isetf json
line 1096: 
line 1097: " JSON Lines
line 1098: au BufNewFile,BufRead *.jsonl^I^I^Isetf jsonl
line 1099: 
line 1100: " Jsonnet
line 1101: au BufNewFile,BufRead *.jsonnet,*.libsonnet^Isetf jsonnet
line 1102: 
line 1103: " Julia
line 1104: au BufNewFile,BufRead *.jl^I^I^Isetf julia
line 1105: 
line 1106: " Just
line 1107: au BufNewFile,BufRead [jJ]ustfile,.justfile,*.just setf just
line 1108: 
line 1109: " KDL
line 1110: au BufNewFile,BufRead *.kdl^I^I^Isetf kdl
line 1111: 
line 1112: " Kixtart
line 1113: au BufNewFile,BufRead *.kix^I^I^Isetf kix
line 1114: 
line 1115: " Kuka Robot Language
line 1116: au BufNewFile,BufRead *.src\c^I^I^Icall dist#ft#FTsrc()
line 1117: au BufNewFile,BufRead *.dat\c^I^I^Icall dist#ft#FTdat()
line 1118: au BufNewFile,BufRead *.sub\c^I^I^Isetf krl
line 1119: 
line 1120: " Kimwitu[++]
line 1121: au BufNewFile,BufRead *.k^I^I^Isetf kwt
line 1122: 
line 1123: " Kivy
line 1124: au BufNewFile,BufRead *.kv^I^I^Isetf kivy
line 1125: 
line 1126: " Kotlin
line 1127: au BufNewFile,BufRead *.kt,*.ktm,*.kts^I^Isetf kotlin
line 1128: 
line 1129: " KDE script
line 1130: au BufNewFile,BufRead *.ks^I^I^Isetf kscript
line 1131: 
line 1132: " Kconfig
line 1133: au BufNewFile,BufRead Kconfig,Kconfig.debug^Isetf kconfig
line 1134: 
line 1135: " Lace (ISE)
line 1136: au BufNewFile,BufRead *.ace,*.ACE^I^Isetf lace
line 1137: 
line 1138: " Larch Shared Language
line 1139: au BufNewFile,BufRead .lsl^I^I^Icall dist#ft#FTlsl()
line 1140: 
line 1141: " Latexmkrc
line 1142: au BufNewFile,BufRead .latexmkrc,latexmkrc^Isetf perl
line 1143: 
line 1144: " Latte
line 1145: au BufNewFile,BufRead *.latte,*.lte^I^Isetf latte
line 1146: 
line 1147: " Limits
line 1148: au BufNewFile,BufRead */etc/limits,*/etc/*limits.conf,*/etc/*limits.d/*.conf^Isetf limits
line 1149: 
line 1150: " LambdaProlog or SML (see dist#ft#FTmod for *.mod)
line 1151: au BufNewFile,BufRead *.sig^I^I^Icall dist#ft#FTsig()
line 1152: 
line 1153: " LDAP LDIF
line 1154: au BufNewFile,BufRead *.ldif^I^I^Isetf ldif
line 1155: 
line 1156: " Ld loader
line 1157: au BufNewFile,BufRead *.ld^I^I^Isetf ld
line 1158: 
line 1159: " Lean
line 1160: au BufNewFile,BufRead *.lean^I^I^Isetf lean
line 1161: 
line 1162: " Ledger
line 1163: au BufRead,BufNewFile *.ldg,*.ledger,*.journal^I^I^Isetf ledger
line 1164: 
line 1165: " Less
line 1166: au BufNewFile,BufRead *.less^I^I^Isetf less
line 1167: 
line 1168: " Lex
line 1169: au BufNewFile,BufRead *.lex,*.l,*.lxx,*.l++^Isetf lex
line 1170: 
line 1171: " Libao
line 1172: au BufNewFile,BufRead */etc/libao.conf,*/.libao^Isetf libao
line 1173: 
line 1174: " Libsensors
line 1175: au BufNewFile,BufRead */etc/sensors.conf,*/etc/sensors3.conf^Isetf sensors
line 1176: 
line 1177: " LFTP
line 1178: au BufNewFile,BufRead lftp.conf,.lftprc,*lftp/rc^Isetf lftp
line 1179: 
line 1180: " Lifelines (or Lex for C++!)
line 1181: au BufNewFile,BufRead *.ll^I^I^Isetf lifelines
line 1182: 
line 1183: " Lilo: Linux loader
line 1184: au BufNewFile,BufRead lilo.conf^I^I^Isetf lilo
line 1185: 
line 1186: " Lilypond
line 1187: au BufNewFile,BufRead *.ly,*.ily^I^Isetf lilypond
line 1188: 
line 1189: " Lisp (*.el = ELisp, *.cl = Common Lisp)
line 1190: " *.jl was removed, it's also used for Julia, better skip than guess wrong.
line 1191: if has("fname_case")
line 1192:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,*.L,.emacs,.sawfishrc setf lisp
line 1193: else
line 1194:   au BufNewFile,BufRead *.lsp,*.lisp,*.asd,*.el,*.cl,.emacs,.sawfishrc setf lisp
line 1195: endif
line 1196: 
line 1197: " SBCL implementation of Common Lisp
line 1198: au BufNewFile,BufRead sbclrc,.sbclrc^I^Isetf lisp
line 1199: 
line 1200: " Liquidsoap
line 1201: au BufNewFile,BufRead *.liq^I^I^Isetf liquidsoap
line 1202: 
line 1203: " Liquid
line 1204: au BufNewFile,BufRead *.liquid^I^I^Isetf liquid
line 1205: 
line 1206: " Lite
line 1207: au BufNewFile,BufRead *.lite,*.lt^I^Isetf lite
line 1208: 
line 1209: " LiteStep RC files
line 1210: au BufNewFile,BufRead */LiteStep/*/*.rc^I^Isetf litestep
line 1211: 
line 1212: " Livebook
line 1213: au BufNewFile,BufRead *.livemd^I^I^Isetf livebook
line 1214: 
line 1215: " Login access
line 1216: au BufNewFile,BufRead */etc/login.access^Isetf loginaccess
line 1217: 
line 1218: " Login defs
line 1219: au BufNewFile,BufRead */etc/login.defs^I^Isetf logindefs
line 1220: 
line 1221: " Logtalk
line 1222: au BufNewFile,BufRead *.lgt^I^I^Isetf logtalk
line 1223: 
line 1224: " LOTOS
line 1225: au BufNewFile,BufRead *.lot,*.lotos^I^Isetf lotos
line 1226: 
line 1227: " Lout (also: *.lt)
line 1228: au BufNewFile,BufRead *.lou,*.lout^I^Isetf lout
line 1229: 
line 1230: " Lua
line 1231: au BufNewFile,BufRead *.lua^I^I^Isetf lua
line 1232: 
line 1233: " Luau
line 1234: au BufNewFile,BufRead *.luau^I^Isetf luau
line 1235: 
line 1236: " Luacheck
line 1237: au BufNewFile,BufRead .luacheckrc^I^Isetf lua
line 1238: 
line 1239: " Luarocks
line 1240: au BufNewFile,BufRead *.rockspec^I^Isetf lua
line 1241: 
line 1242: " Linden Scripting Language (Second Life)
line 1243: au BufNewFile,BufRead *.lsl^I^I^Icall dist#ft#FTlsl()
line 1244: 
line 1245: " Lynx style file (or LotusScript!)
line 1246: au BufNewFile,BufRead *.lss^I^I^Isetf lss
line 1247: 
line 1248: " M4
line 1249: au BufNewFile,BufRead *.m4 if expand("<afile>") !~? 'html.m4$\|fvwm2rc' | setf m4 | endif
line 1251: 
line 1252: " MaGic Point
line 1253: au BufNewFile,BufRead *.mgp^I^I^Isetf mgp
line 1254: 
line 1255: " Mail (for Elm, trn, mutt, muttng, rn, slrn, neomutt)
line 1256: au BufNewFile,BufRead snd.\d\+,.letter,.letter.\d\+,.followup,.article,.article.\d\+,pico.\d\+,mutt{ng,}-*-\w\+,mutt[[:alnum:]_-]\\\{6\},neomutt-*-\w\+,neomutt[[:alnum:]_-]\\\{6\},ae\d\+.txt,/tmp/SLRN[0-9A-Z.]\+,*.eml setf mail
line 1257: 
line 1258: " Mail aliases
line 1259: au BufNewFile,BufRead */etc/mail/aliases,*/etc/aliases^Isetf mailaliases
line 1260: 
line 1261: " Mailcap configuration file
line 1262: au BufNewFile,BufRead .mailcap,mailcap^I^Isetf mailcap
line 1263: 
line 1264: " Makefile
line 1265: au BufNewFile,BufRead *[mM]akefile,*.mk,*.mak,*.dsp setf make
line 1266: 
line 1267: " MakeIndex
line 1268: au BufNewFile,BufRead *.ist,*.mst^I^Isetf ist
line 1269: 
line 1270: " Mallard
line 1271: au BufNewFile,BufRead *.page^I^I^Isetf mallard
line 1272: 
line 1273: " Manpage
line 1274: au BufNewFile,BufRead *.man^I^I^Isetf man
line 1275: 
line 1276: " Man config
line 1277: au BufNewFile,BufRead */etc/man.conf,man.config^Isetf manconf
line 1278: 
line 1279: " Maple V
line 1280: au BufNewFile,BufRead *.mv,*.mpl,*.mws^I^Isetf maple
line 1281: 
line 1282: " Map (UMN mapserver config file)
line 1283: au BufNewFile,BufRead *.map^I^I^Isetf map
line 1284: 
line 1285: " Markdown
line 1286: au BufNewFile,BufRead *.markdown,*.mdown,*.mkd,*.mkdn,*.mdwn,*.md  setf markdown
line 1287: 
line 1288: " Mason
line 1289: au BufNewFile,BufRead *.mason,*.mhtml,*.comp^Isetf mason
line 1290: 
line 1291: " Mathematica, Matlab, Murphi, Objective C or Octave
line 1292: au BufNewFile,BufRead *.m^I^I^Icall dist#ft#FTm()
line 1293: 
line 1294: " Mathematica notebook
line 1295: au BufNewFile,BufRead *.nb^I^I^Isetf mma
line 1296: 
line 1297: " Maya Extension Language
line 1298: au BufNewFile,BufRead *.mel^I^I^Isetf mel
line 1299: 
line 1300: " Mercurial (hg) commit file
line 1301: au BufNewFile,BufRead hg-editor-*.txt^I^Isetf hgcommit
line 1302: 
line 1303: " Mercurial config (looks like generic config file)
line 1304: au BufNewFile,BufRead *.hgrc,*hgrc^I^Isetf cfg
line 1305: 
line 1306: " Mermaid
line 1307: au BufNewFile,BufRead *.mmd,*.mmdc,*.mermaid^Isetf mermaid
line 1308: 
line 1309: " Meson Build system config
line 1310: au BufNewFile,BufRead meson.build,meson.options,meson_options.txt setf meson
line 1311: au BufNewFile,BufRead *.wrap^I^I^Isetf dosini
line 1312: 
line 1313: " Messages (logs mostly)
line 1314: au BufNewFile,BufRead */log/{auth,cron,daemon,debug,kern,lpr,mail,messages,news/news,syslog,user}{,.log,.err,.info,.warn,.crit,.notice}{,.[0-9]*,-[0-9]*} setf messages
line 1315: 
line 1316: " Metafont
line 1317: au BufNewFile,BufRead *.mf^I^I^Isetf mf
line 1318: 
line 1319: " MetaPost
line 1320: au BufNewFile,BufRead *.mp^I^I^Isetf mp
line 1321: au BufNewFile,BufRead *.mpxl,*.mpiv,*.mpvi^Ilet b:mp_metafun = 1 | setf mp
line 1322: 
line 1323: " MGL
line 1324: au BufNewFile,BufRead *.mgl^I^I^Isetf mgl
line 1325: 
line 1326: " MIX - Knuth assembly
line 1327: au BufNewFile,BufRead *.mix,*.mixal^I^Isetf mix
line 1328: 
line 1329: " MMIX or VMS makefile
line 1330: au BufNewFile,BufRead *.mms^I^I^Icall dist#ft#FTmms()
line 1331: 
line 1332: " Symbian meta-makefile definition (MMP)
line 1333: au BufNewFile,BufRead *.mmp^I^I^Isetf mmp
line 1334: 
line 1335: " ABB Rapid, Modula-2, Modsim III or LambdaProlog
line 1336: au BufNewFile,BufRead *.mod\c^I^I^Icall dist#ft#FTmod()
line 1337: 
line 1338: " Modula-2  (.md removed in favor of Markdown, see dist#ft#FTmod for *.MOD)
line 1339: au BufNewFile,BufRead *.m2,*.DEF,*.mi^I^Isetf modula2
line 1340: 
line 1341: " Modula-3 (.m3, .i3, .mg, .ig)
line 1342: au BufNewFile,BufRead *.[mi][3g]^I^Isetf modula3
line 1343: 
line 1344: " Larch/Modula-3
line 1345: au BufNewFile,BufRead *.lm3^I^I^Isetf modula3
line 1346: 
line 1347: " Modconf
line 1348: au BufNewFile,BufRead */etc/modules.conf,*/etc/modules,*/etc/conf.modules setf modconf
line 1349: 
line 1350: " Monk
line 1351: au BufNewFile,BufRead *.isc,*.monk,*.ssc,*.tsc^Isetf monk
line 1352: 
line 1353: " MOO
line 1354: au BufNewFile,BufRead *.moo^I^I^Isetf moo
line 1355: 
line 1356: " Moonscript
line 1357: au BufNewFile,BufRead *.moon^I^I^Isetf moonscript
line 1358: 
line 1359: " Move language
line 1360: au BufNewFile,BufRead *.move^I^I^Isetf move
line 1361: 
line 1362: " MPD is based on XML
line 1363: au BufNewFile,BufRead *.mpd^I^I^Isetf xml
line 1364: 
line 1365: " Mplayer config
line 1366: au BufNewFile,BufRead mplayer.conf,*/.mplayer/config^Isetf mplayerconf
line 1367: 
line 1368: " Motorola S record
line 1369: au BufNewFile,BufRead *.s19,*.s28,*.s37,*.mot,*.srec^Isetf srec
line 1370: 
line 1371: " Mrxvtrc
line 1372: au BufNewFile,BufRead mrxvtrc,.mrxvtrc^I^Isetf mrxvtrc
line 1373: 
line 1374: " Msql
line 1375: au BufNewFile,BufRead *.msql^I^I^Isetf msql
line 1376: 
line 1377: " Mysql
line 1378: au BufNewFile,BufRead *.mysql^I^I^Isetf mysql
line 1379: 
line 1380: " Tcl Shell RC file
line 1381: au BufNewFile,BufRead tclsh.rc^I^I^Isetf tcl
line 1382: 
line 1383: " M$ Resource files
line 1384: " /etc/Muttrc.d/file.rc is muttrc
line 1385: au BufNewFile,BufRead *.rc,*.rch if expand("<afile>") !~ "/etc/Muttrc.d/" |   setf rc | endif
line 1389: 
line 1390: " Mojo
line 1391: " Mojo files use either .mojo or . as extension
line 1392: au BufNewFile,BufRead *.mojo,*.^I^Isetf mojo
line 1393: 
line 1394: " MuPAD source
line 1395: au BufRead,BufNewFile *.mu^I^I^Isetf mupad
line 1396: 
line 1397: " Mush
line 1398: au BufNewFile,BufRead *.mush^I^I^Isetf mush
line 1399: 
line 1400: " Mutt setup file (also for Muttng)
line 1401: au BufNewFile,BufRead Mutt{ng,}rc^I^Isetf muttrc
line 1402: 
line 1403: " N1QL
line 1404: au BufRead,BufNewfile *.n1ql,*.nql^I^Isetf n1ql
line 1405: 
line 1406: " Nano
line 1407: au BufNewFile,BufRead */etc/nanorc,*.nanorc^Isetf nanorc
line 1408: 
line 1409: " Nastran input/DMAP
line 1410: "au BufNewFile,BufRead *.dat^I^I^Isetf nastran
line 1411: 
line 1412: " Natural
line 1413: au BufNewFile,BufRead *.NS[ACGLMNPS]^I^Isetf natural
line 1414: 
line 1415: " Noemutt setup file
line 1416: au BufNewFile,BufRead Neomuttrc^I^I^Isetf neomuttrc
line 1417: 
line 1418: " Netrc
line 1419: au BufNewFile,BufRead .netrc^I^I^Isetf netrc
line 1420: 
line 1421: " Nginx
line 1422: au BufNewFile,BufRead *.nginx,nginx*.conf,*nginx.conf,*/etc/nginx/*,*/usr/local/nginx/conf/*,*/nginx/*.conf^I^I^Isetf nginx
line 1423: 
line 1424: " Nim file
line 1425: au BufNewFile,BufRead *.nim,*.nims,*.nimble^Isetf nim
line 1426: 
line 1427: " Ninja file
line 1428: au BufNewFile,BufRead *.ninja^I^I^Isetf ninja
line 1429: 
line 1430: " Nix
line 1431: au BufRead,BufNewFile *.nix^I^I^Isetf nix
line 1432: 
line 1433: " Norg
line 1434: au BufNewFile,BufRead *.norg^I^Isetf norg
line 1435: 
line 1436: " NPM RC file
line 1437: au BufNewFile,BufRead npmrc,.npmrc^I^Isetf dosini
line 1438: 
line 1439: " Novell netware batch files
line 1440: au BufNewFile,BufRead *.ncf^I^I^Isetf ncf
line 1441: 
line 1442: " Nroff/Troff (*.ms and *.t are checked below)
line 1443: au BufNewFile,BufRead *.me if expand("<afile>") != "read.me" && expand("<afile>") != "click.me" |   setf nroff | endif
line 1447: au BufNewFile,BufRead *.tr,*.nr,*.roff,*.tmac,*.mom^Isetf nroff
line 1448: au BufNewFile,BufRead *.[1-9]^I^I^Icall dist#ft#FTnroff()
line 1449: 
line 1450: " Nroff or Objective C++
line 1451: au BufNewFile,BufRead *.mm^I^I^Icall dist#ft#FTmm()
line 1452: 
line 1453: " Not Quite C
line 1454: au BufNewFile,BufRead *.nqc^I^I^Isetf nqc
line 1455: 
line 1456: " NSE - Nmap Script Engine - uses Lua syntax
line 1457: au BufNewFile,BufRead *.nse^I^I^Isetf lua
line 1458: 
line 1459: " NSIS
line 1460: au BufNewFile,BufRead *.nsi,*.nsh^I^Isetf nsis
line 1461: 
line 1462: " Nu
line 1463: au BufNewFile,BufRead {env,config}.nu^I^Isetf nu
line 1464: 
line 1465: " Oblivion Language and Oblivion Script Extender
line 1466: au BufNewFile,BufRead *.obl,*.obse,*.oblivion,*.obscript  setf obse
line 1467: 
line 1468: " Objdump
line 1469: au BufNewFile,BufRead *.objdump,*.cppobjdump  setf objdump
line 1470: 
line 1471: " OCaml
line 1472: au BufNewFile,BufRead *.ml,*.mli,*.mll,*.mly,.ocamlinit,*.mlt,*.mlp,*.mlip,*.mli.cppo,*.ml.cppo setf ocaml
line 1473: 
line 1474: " Occam
line 1475: au BufNewFile,BufRead *.occ^I^I^Isetf occam
line 1476: 
line 1477: " Octave
line 1478: au BufNewFile,BufRead octave.conf,.octaverc,octaverc^Isetf octave
line 1479: 
line 1480: " Odin
line 1481: au BufNewFile,BufRead *.odin^I^I^Isetf odin
line 1482: 
line 1483: " Omnimark
line 1484: au BufNewFile,BufRead *.xom,*.xin^I^Isetf omnimark
line 1485: 
line 1486: " OPAM
line 1487: au BufNewFile,BufRead opam,*.opam,*.opam.template setf opam
line 1488: 
line 1489: " OpenFOAM
line 1490: au BufNewFile,BufRead [a-zA-Z0-9]*Dict\(.*\)\=,[a-zA-Z]*Properties\(.*\)\=,*Transport\(.*\),fvSchemes,fvSolution,fvConstrains,fvModels,*/constant/g,*/0\(\.orig\)\=/* call dist#ft#FTfoam()
line 1491: 
line 1492: " OpenROAD
line 1493: au BufNewFile,BufRead *.or^I^I^I^Isetf openroad
line 1494: 
line 1495: " OPL
line 1496: au BufNewFile,BufRead *.[Oo][Pp][Ll]^I^I^Isetf opl
line 1497: 
line 1498: " OpenSCAD
line 1499: au BufNewFile,BufRead *.scad^I^I^I^Isetf openscad
line 1500: 
line 1501: " Oracle config file
line 1502: au BufNewFile,BufRead *.ora^I^I^I^Isetf ora
line 1503: 
line 1504: " Org
line 1505: au BufNewFile,BufRead *.org,*.org_archive^I^Isetf org
line 1506: 
line 1507: " Packet filter conf
line 1508: au BufNewFile,BufRead pf.conf^I^I^I^Isetf pf
line 1509: 
line 1510: " ini style config files, using # comments
line 1511: au BufNewFile,BufRead */etc/pacman.conf,mpv.conf^Isetf confini
line 1512: au BufNewFile,BufRead */.aws/config,*/.aws/credentials^Isetf confini
line 1513: au BufNewFile,BufRead *.nmconnection^I^I^Isetf confini
line 1514: 
line 1515: " Pacman hooks
line 1516: au BufNewFile,BufRead *.hook if getline(1) == '[Trigger]' |   setf confini | endif
line 1520: 
line 1521: " Pam conf
line 1522: au BufNewFile,BufRead */etc/pam.conf^I^I^Isetf pamconf
line 1523: 
line 1524: " Pam environment
line 1525: au BufNewFile,BufRead pam_env.conf,.pam_environment^Isetf pamenv
line 1526: 
line 1527: " PApp
line 1528: au BufNewFile,BufRead *.papp,*.pxml,*.pxsl^I^Isetf papp
line 1529: 
line 1530: " Password file
line 1531: au BufNewFile,BufRead */etc/passwd,*/etc/passwd-,*/etc/passwd.edit,*/etc/shadow,*/etc/shadow-,*/etc/shadow.edit,*/var/backups/passwd.bak,*/var/backups/shadow.bak setf passwd
line 1532: 
line 1533: " Pascal (also *.p, *.pp, *.inc)
line 1534: au BufNewFile,BufRead *.pas^I^I^I^Isetf pascal
line 1535: 
line 1536: " Pascal or Puppet manifest
line 1537: au BufNewFile,BufRead *.pp^I^I^I^Icall dist#ft#FTpp()
line 1538: 
line 1539: " Delphi or Lazarus program file
line 1540: au BufNewFile,BufRead *.dpr,*.lpr^I^I^Isetf pascal
line 1541: 
line 1542: " Free Pascal makefile definition file
line 1543: au BufNewFile,BufRead *.fpc^I^I^I^Isetf fpcmake
line 1544: 
line 1545: " Path of Exile item filter
line 1546: au BufNewFile,BufRead *.filter^I^I^I^Isetf poefilter
line 1547: 
line 1548: " PDF
line 1549: au BufNewFile,BufRead *.pdf^I^I^I^Isetf pdf
line 1550: 
line 1551: " PCMK - HAE - crm configure edit
line 1552: au BufNewFile,BufRead *.pcmk^I^I^I^Isetf pcmk
line 1553: 
line 1554: " PEM (Privacy-Enhanced Mail)
line 1555: au BufNewFile,BufRead *.pem,*.cer,*.crt,*.csr^I^Isetf pem
line 1556: 
line 1557: " Perl
line 1558: if has("fname_case")
line 1559:   au BufNewFile,BufRead *.pl,*.PL^I^I^Icall dist#ft#FTpl()
line 1560: else
line 1561:   au BufNewFile,BufRead *.pl^I^I^I^Icall dist#ft#FTpl()
line 1562: endif
line 1563: au BufNewFile,BufRead *.plx,*.al,*.psgi^I^I^Isetf perl
line 1564: 
line 1565: " Perl, XPM or XPM2
line 1566: au BufNewFile,BufRead *.pm if getline(1) =~ "XPM2" |   setf xpm2 | elseif getline(1) =~ "XPM" |   setf xpm | else |   setf perl | endif
line 1574: 
line 1575: " Perl POD
line 1576: au BufNewFile,BufRead *.pod^I^I^Isetf pod
line 1577: 
line 1578: " Php, php3, php4, etc.
line 1579: " Also Phtml (was used for PHP 2 in the past).
line 1580: " Also .ctp for Cake template file.
line 1581: " Also .phpt for php tests.
line 1582: " Also .theme for Drupal theme files.
line 1583: au BufNewFile,BufRead *.php,*.php\d,*.phtml,*.ctp,*.phpt,*.theme^Isetf php
line 1584: 
line 1585: " PHP config
line 1586: au BufNewFile,BufRead php.ini-*^I^I^Isetf dosini
line 1587: 
line 1588: " Pike and Cmod
line 1589: au BufNewFile,BufRead *.pike,*.pmod^I^Isetf pike
line 1590: au BufNewFile,BufRead *.cmod^I^I^Isetf cmod
line 1591: 
line 1592: " Pinfo config
line 1593: au BufNewFile,BufRead */etc/pinforc,*/.pinforc^Isetf pinfo
line 1594: 
line 1595: " Palm Resource compiler
line 1596: au BufNewFile,BufRead *.rcp^I^I^Isetf pilrc
line 1597: 
line 1598: " Pine config
line 1599: au BufNewFile,BufRead .pinerc,pinerc,.pinercex,pinercex^I^Isetf pine
line 1600: 
line 1601: " Pip requirements
line 1602: au BufNewFile,BufRead *.pip^I^I^Isetf requirements
line 1603: au BufNewFile,BufRead requirements.txt^I^Isetf requirements
line 1604: 
line 1605: " Pipenv Pipfiles
line 1606: au BufNewFile,BufRead Pipfile^I^I^Isetf toml
line 1607: au BufNewFile,BufRead Pipfile.lock^I^Isetf json
line 1608: 
line 1609: " PL/1, PL/I
line 1610: au BufNewFile,BufRead *.pli,*.pl1^I^Isetf pli
line 1611: 
line 1612: " PL/M (also: *.inp)
line 1613: au BufNewFile,BufRead *.plm,*.p36,*.pac^I^Isetf plm
line 1614: 
line 1615: " PL/SQL
line 1616: au BufNewFile,BufRead *.pls,*.plsql^I^Isetf plsql
line 1617: 
line 1618: " PLP
line 1619: au BufNewFile,BufRead *.plp^I^I^Isetf plp
line 1620: 
line 1621: " PO and PO template (GNU gettext)
line 1622: au BufNewFile,BufRead *.po,*.pot^I^Isetf po
line 1623: 
line 1624: " Pony
line 1625: au BufNewFile,BufRead *.pony^I^I^Isetf pony
line 1626: 
line 1627: " Postfix main config
line 1628: au BufNewFile,BufRead main.cf,main.cf.proto^Isetf pfmain
line 1629: 
line 1630: " PostScript (+ font files, encapsulated PostScript, Adobe Illustrator)
line 1631: au BufNewFile,BufRead *.ps,*.pfa,*.afm,*.eps,*.epsf,*.epsi,*.ai^I  setf postscr
line 1632: 
line 1633: " PostScript Printer Description
line 1634: au BufNewFile,BufRead *.ppd^I^I^Isetf ppd
line 1635: 
line 1636: " Povray
line 1637: au BufNewFile,BufRead *.pov^I^I^Isetf pov
line 1638: 
line 1639: " Povray configuration
line 1640: au BufNewFile,BufRead .povrayrc^I^I^Isetf povini
line 1641: 
line 1642: " Povray, Pascal, PHP or assembly
line 1643: au BufNewFile,BufRead *.inc^I^I^Icall dist#ft#FTinc()
line 1644: 
line 1645: " PowerShell
line 1646: au BufNewFile,BufRead^I*.ps1,*.psd1,*.psm1,*.pssc^Isetf ps1
line 1647: au BufNewFile,BufRead^I*.ps1xml^I^I^Isetf ps1xml
line 1648: au BufNewFile,BufRead^I*.cdxml,*.psc1^I^I^Isetf xml
line 1649: 
line 1650: " Printcap and Termcap
line 1651: au BufNewFile,BufRead *printcap let b:ptcap_type = "print" | setf ptcap
line 1653: au BufNewFile,BufRead *termcap let b:ptcap_type = "term" | setf ptcap
line 1655: 
line 1656: " Prisma
line 1657: au BufRead,BufNewFile *.prisma^I^I^Isetf prisma
line 1658: 
line 1659: " PCCTS / ANTLR
line 1660: "au BufNewFile,BufRead *.g^I^I^Isetf antlr
line 1661: au BufNewFile,BufRead *.g^I^I^Isetf pccts
line 1662: 
line 1663: " PPWizard
line 1664: au BufNewFile,BufRead *.it,*.ih^I^I^Isetf ppwiz
line 1665: 
line 1666: " Pug
line 1667: au BufRead,BufNewFile *.pug^I^I^Isetf pug
line 1668: 
line 1669: " Puppet
line 1670: au BufNewFile,BufRead Puppetfile^I^Isetf ruby
line 1671: 
line 1672: " Embedded Puppet
line 1673: au BufNewFile,BufRead *.epp^I^I^Isetf epuppet
line 1674: 
line 1675: " Obj 3D file format
line 1676: " TODO: is there a way to avoid MS-Windows Object files?
line 1677: au BufNewFile,BufRead *.obj^I^I^Isetf obj
line 1678: 
line 1679: " Oracle Pro*C/C++
line 1680: au BufNewFile,BufRead *.pc^I^I^Isetf proc
line 1681: 
line 1682: " Privoxy actions file
line 1683: au BufNewFile,BufRead *.action^I^I^Isetf privoxy
line 1684: 
line 1685: " Procmail
line 1686: au BufNewFile,BufRead .procmail,.procmailrc^Isetf procmail
line 1687: 
line 1688: " Progress or CWEB
line 1689: au BufNewFile,BufRead *.w^I^I^Icall dist#ft#FTprogress_cweb()
line 1690: 
line 1691: " Progress or assembly or Swig
line 1692: au BufNewFile,BufRead *.i^I^I^Icall dist#ft#FTi()
line 1693: 
line 1694: " Progress or Pascal
line 1695: au BufNewFile,BufRead *.p^I^I^Icall dist#ft#FTprogress_pascal()
line 1696: 
line 1697: " Software Distributor Product Specification File (POSIX 1387.2-1995)
line 1698: au BufNewFile,BufRead *.psf^I^I^Isetf psf
line 1699: au BufNewFile,BufRead INDEX,INFO if getline(1) =~ '^\s*\(distribution\|installed_software\|root\|bundle\|product\)\s*$' |   setf psf | endif
line 1703: 
line 1704: " Prolog
line 1705: au BufNewFile,BufRead *.pdb^I^I^Isetf prolog
line 1706: 
line 1707: " Promela
line 1708: au BufNewFile,BufRead *.pml^I^I^Isetf promela
line 1709: 
line 1710: " Property Specification Language (PSL)
line 1711: au BufNewFile,BufRead *.psl^I^I^Isetf psl
line 1712: 
line 1713: " Google protocol buffers
line 1714: au BufNewFile,BufRead *.proto^I^I^Isetf proto
line 1715: au BufNewFile,BufRead *.pbtxt^I^I^Isetf pbtxt
line 1716: 
line 1717: " Poke
line 1718: au BufNewFile,BufRead *.pk^I^I^Isetf poke
line 1719: 
line 1720: " Protocols
line 1721: au BufNewFile,BufRead */etc/protocols^I^Isetf protocols
line 1722: 
line 1723: " PyPA manifest files
line 1724: au BufNewFile,BufRead MANIFEST.in^I^Isetf pymanifest
line 1725: 
line 1726: " Pyret
line 1727: au BufNewFile,BufRead *.arr^I^I^Isetf pyret
line 1728: 
line 1729: " Pyrex
line 1730: au BufNewFile,BufRead *.pyx,*.pxd^I^Isetf pyrex
line 1731: 
line 1732: " Python, Python Shell Startup and Python Stub Files
line 1733: " Quixote (Python-based web framework)
line 1734: au BufNewFile,BufRead *.py,*.pyw,.pythonstartup,.pythonrc  setf python
line 1735: au BufNewFile,BufRead *.ptl,*.pyi,SConstruct^I^I   setf python
line 1736: 
line 1737: " QL
line 1738: au BufRead,BufNewFile *.ql,*.qll^I^Isetf ql
line 1739: 
line 1740: " QML
line 1741: au BufRead,BufNewFile *.qml,*.qbs^I^I^Isetf qml
line 1742: 
line 1743: " QMLdir
line 1744: au BufRead,BufNewFile qmldir^I^I^Isetf qmldir
line 1745: 
line 1746: " Quarto
line 1747: au BufRead,BufNewFile *.qmd^I^I^Isetf quarto
line 1748: 
line 1749: " Racket (formerly detected as "scheme")
line 1750: au BufNewFile,BufRead *.rkt,*.rktd,*.rktl^Isetf racket
line 1751: 
line 1752: " Radiance
line 1753: au BufNewFile,BufRead *.rad,*.mat^I^Isetf radiance
line 1754: 
line 1755: " Raku (formerly Perl6)
line 1756: au BufNewFile,BufRead *.pm6,*.p6,*.t6,*.pod6,*.raku,*.rakumod,*.rakudoc,*.rakutest  setf raku
line 1757: 
line 1758: " Ratpoison config/command files
line 1759: au BufNewFile,BufRead .ratpoisonrc,ratpoisonrc^Isetf ratpoison
line 1760: 
line 1761: " RCS file
line 1762: au BufNewFile,BufRead *\,v^I^I^Isetf rcs
line 1763: 
line 1764: " Readline
line 1765: au BufNewFile,BufRead .inputrc,inputrc^I^Isetf readline
line 1766: 
line 1767: " Registry for MS-Windows
line 1768: au BufNewFile,BufRead *.reg if getline(1) =~? '^REGEDIT[0-9]*\s*$\|^Windows Registry Editor Version \d*\.\d*\s*$' | setf registry | endif
line 1770: 
line 1771: " Renderman Interface Bytestream
line 1772: au BufNewFile,BufRead *.rib^I^I^Isetf rib
line 1773: 
line 1774: " Rego Policy Language
line 1775: au BufNewFile,BufRead *.rego^I^I^Isetf rego
line 1776: 
line 1777: " Rexx
line 1778: au BufNewFile,BufRead *.rex,*.orx,*.rxo,*.rxj,*.jrexx,*.rexxj,*.rexx,*.testGroup,*.testUnit^Isetf rexx
line 1779: 
line 1780: " R Help file
line 1781: if has("fname_case")
line 1782:   au BufNewFile,BufRead *.rd,*.Rd^I^Isetf rhelp
line 1783: else
line 1784:   au BufNewFile,BufRead *.rd^I^I^Isetf rhelp
line 1785: endif
line 1786: 
line 1787: " R noweb file
line 1788: if has("fname_case")
line 1789:   au BufNewFile,BufRead *.Rnw,*.rnw,*.Snw,*.snw^I^Isetf rnoweb
line 1790: else
line 1791:   au BufNewFile,BufRead *.rnw,*.snw^I^I^Isetf rnoweb
line 1792: endif
line 1793: 
line 1794: " R Markdown file
line 1795: if has("fname_case")
line 1796:   au BufNewFile,BufRead *.Rmd,*.rmd,*.Smd,*.smd^I^Isetf rmd
line 1797: else
line 1798:   au BufNewFile,BufRead *.rmd,*.smd^I^I^Isetf rmd
line 1799: endif
line 1800: 
line 1801: " R profile file
line 1802: au BufNewFile,BufRead .Rprofile,Rprofile,Rprofile.site^Isetf r
line 1803: 
line 1804: " RSS looks like XML
line 1805: au BufNewFile,BufRead *.rss^I^I^I^Isetf xml
line 1806: 
line 1807: " R reStructuredText file
line 1808: if has("fname_case")
line 1809:   au BufNewFile,BufRead *.Rrst,*.rrst,*.Srst,*.srst^Isetf rrst
line 1810: else
line 1811:   au BufNewFile,BufRead *.rrst,*.srst^I^I^Isetf rrst
line 1812: endif
line 1813: 
line 1814: " Rexx, Rebol or R
line 1815: au BufNewFile,BufRead *.r,*.R^I^I^I^Icall dist#ft#FTr()
line 1816: 
line 1817: " Remind
line 1818: au BufNewFile,BufRead .reminders,*.remind,*.rem^I^Isetf remind
line 1819: 
line 1820: " ReScript
line 1821: au BufNewFile,BufRead *.res,*.resi^I^I^Isetf rescript
line 1822: 
line 1823: " Resolv.conf
line 1824: au BufNewFile,BufRead resolv.conf^I^Isetf resolv
line 1825: 
line 1826: " Relax NG Compact
line 1827: au BufNewFile,BufRead *.rnc^I^I^Isetf rnc
line 1828: 
line 1829: " Relax NG XML
line 1830: au BufNewFile,BufRead *.rng^I^I^Isetf rng
line 1831: 
line 1832: " ILE RPG
line 1833: au BufNewFile,BufRead *.rpgle,*.rpgleinc^Isetf rpgle
line 1834: 
line 1835: " RPL/2
line 1836: au BufNewFile,BufRead *.rpl^I^I^Isetf rpl
line 1837: 
line 1838: " Robot Framework
line 1839: au BufNewFile,BufRead *.robot,*.resource^Isetf robot
line 1840: 
line 1841: " Robots.txt
line 1842: au BufNewFile,BufRead robots.txt^I^Isetf robots
line 1843: 
line 1844: " RON (Rusty Object Notation)
line 1845: au BufNewFile,BufRead *.ron^I^I^Isetf ron
line 1846: 
line 1847: " MikroTik RouterOS script
line 1848: au BufRead,BufNewFile *.rsc^I^I^Isetf routeros
line 1849: 
line 1850: " Rpcgen
line 1851: au BufNewFile,BufRead *.x^I^I^Isetf rpcgen
line 1852: 
line 1853: " reStructuredText Documentation Format
line 1854: au BufNewFile,BufRead *.rst^I^I^Isetf rst
line 1855: 
line 1856: " RTF
line 1857: au BufNewFile,BufRead *.rtf^I^I^Isetf rtf
line 1858: 
line 1859: " Interactive Ruby shell
line 1860: au BufNewFile,BufRead .irbrc,irbrc^I^Isetf ruby
line 1861: 
line 1862: " Ruby
line 1863: au BufNewFile,BufRead *.rb,*.rbw^I^Isetf ruby
line 1864: 
line 1865: " RubyGems
line 1866: au BufNewFile,BufRead *.gemspec^I^I^Isetf ruby
line 1867: 
line 1868: " RBS (Ruby Signature)
line 1869: au BufNewFile,BufRead *.rbs^I^I^Isetf rbs
line 1870: 
line 1871: " Rackup
line 1872: au BufNewFile,BufRead *.ru^I^I^Isetf ruby
line 1873: 
line 1874: " Bundler
line 1875: au BufNewFile,BufRead Gemfile^I^I^Isetf ruby
line 1876: 
line 1877: " Ruby on Rails
line 1878: au BufNewFile,BufRead *.builder,*.rxml,*.rjs^Isetf ruby
line 1879: 
line 1880: " Rantfile and Rakefile is like Ruby
line 1881: au BufNewFile,BufRead [rR]antfile,*.rant,[rR]akefile,*.rake^Isetf ruby
line 1882: 
line 1883: " Rust
line 1884: au BufNewFile,BufRead *.rs^I^I^Isetf rust
line 1885: au BufNewFile,BufRead Cargo.lock,*/.cargo/config,*/.cargo/credentials^Isetf toml
line 1886: 
line 1887: " S-lang (or shader language, or SmallLisp)
line 1888: au BufNewFile,BufRead *.sl^I^I^Isetf slang
line 1889: 
line 1890: " Sage
line 1891: au BufNewFile,BufRead *.sage^I^I^Isetf sage
line 1892: 
line 1893: " Samba config
line 1894: au BufNewFile,BufRead smb.conf^I^I^Isetf samba
line 1895: 
line 1896: " SAS script
line 1897: au BufNewFile,BufRead *.sas^I^I^Isetf sas
line 1898: 
line 1899: " Sass
line 1900: au BufNewFile,BufRead *.sass^I^I^Isetf sass
line 1901: 
line 1902: " Sather
line 1903: au BufNewFile,BufRead *.sa^I^I^Isetf sather
line 1904: 
line 1905: " Scala
line 1906: au BufNewFile,BufRead *.scala^I^I^Isetf scala
line 1907: 
line 1908: " SBT - Scala Build Tool
line 1909: au BufNewFile,BufRead *.sbt^I^I^Isetf sbt
line 1910: 
line 1911: " SuperCollider
line 1912: au BufNewFile,BufRead *.sc^I^I^Icall dist#ft#FTsc()
line 1913: 
line 1914: au BufNewFile,BufRead *.quark^I^I^Isetf supercollider
line 1915: 
line 1916: " scdoc
line 1917: au BufNewFile,BufRead *.scd^I^I^Icall dist#ft#FTscd()
line 1918: 
line 1919: " Scilab
line 1920: au BufNewFile,BufRead *.sci,*.sce^I^Isetf scilab
line 1921: 
line 1922: 
line 1923: " SCSS
line 1924: au BufNewFile,BufRead *.scss^I^I^Isetf scss
line 1925: 
line 1926: " SD: Streaming Descriptors
line 1927: au BufNewFile,BufRead *.sd^I^I^Isetf sd
line 1928: 
line 1929: " SDL
line 1930: au BufNewFile,BufRead *.sdl,*.pr^I^Isetf sdl
line 1931: 
line 1932: " sed
line 1933: au BufNewFile,BufRead *.sed^I^I^Isetf sed
line 1934: 
line 1935: " SubRip
line 1936: au BufNewFile,BufRead *.srt^I^I^Isetf srt
line 1937: 
line 1938: " SubStation Alpha
line 1939: au BufNewFile,BufRead *.ass,*.ssa^I^Isetf ssa
line 1940: 
line 1941: " svelte
line 1942: au BufNewFile,BufRead *.svelte^I^I^Isetf svelte
line 1943: 
line 1944: " Sieve (RFC 3028, 5228)
line 1945: au BufNewFile,BufRead *.siv,*.sieve^I^Isetf sieve
line 1946: 
line 1947: " Sendmail
line 1948: au BufNewFile,BufRead sendmail.cf^I^Isetf sm
line 1949: 
line 1950: " Sendmail .mc files are actually m4.  Could also be MS Message text file or
line 1951: " Maxima.
line 1952: au BufNewFile,BufRead *.mc^I^I^Icall dist#ft#McSetf()
line 1953: 
line 1954: " Services
line 1955: au BufNewFile,BufRead */etc/services^I^Isetf services
line 1956: 
line 1957: " Service Location config
line 1958: au BufNewFile,BufRead */etc/slp.conf^I^Isetf slpconf
line 1959: 
line 1960: " Service Location registration
line 1961: au BufNewFile,BufRead */etc/slp.reg^I^Isetf slpreg
line 1962: 
line 1963: " Service Location SPI
line 1964: au BufNewFile,BufRead */etc/slp.spi^I^Isetf slpspi
line 1965: 
line 1966: " Setserial config
line 1967: au BufNewFile,BufRead */etc/serial.conf^I^Isetf setserial
line 1968: 
line 1969: " SGML
line 1970: au BufNewFile,BufRead *.sgm,*.sgml if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'linuxdoc' |   setf sgmllnx | elseif getline(1) =~ '<!DOCTYPE.*DocBook' || getline(2) =~ '<!DOCTYPE.*DocBook' |   let b:docbk_type = "sgml" |   let b:docbk_ver = 4 |   setf docbk | else |   setf sgml | endif
line 1980: 
line 1981: " SGMLDECL
line 1982: au BufNewFile,BufRead *.decl,*.dcl,*.dec if getline(1).getline(2).getline(3) =~? '^<!SGML' |    setf sgmldecl | endif
line 1986: 
line 1987: " SGML catalog file
line 1988: au BufNewFile,BufRead catalog^I^I^Isetf catalog
line 1989: 
line 1990: " Shell scripts (sh, ksh, bash, bash2, csh); Allow .profile_foo etc.
line 1991: " Gentoo ebuilds, Arch Linux PKGBUILDs and Alpine Linux APKBUILDs are actually
line 1992: " bash scripts.
line 1993: " NOTE: Patterns ending in a star are further down, these have lower priority.
line 1994: au BufNewFile,BufRead .bashrc,bashrc,bash.bashrc,.bash[_-]profile,.bash[_-]logout,.bash[_-]aliases,bash-fc[-.],*.ebuild,*.bash,*.eclass,PKGBUILD,APKBUILD call dist#ft#SetFileTypeSH("bash")
line 1995: au BufNewFile,BufRead .kshrc,*.ksh call dist#ft#SetFileTypeSH("ksh")
line 1996: au BufNewFile,BufRead */etc/profile,.profile,*.sh,*.env call dist#ft#SetFileTypeSH(getline(1))
line 1997: 
line 1998: " Shell script (Arch Linux) or PHP file (Drupal)
line 1999: au BufNewFile,BufRead *.install if getline(1) =~ '<?php' |   setf php | else |   call dist#ft#SetFileTypeSH("bash") | endif
line 2005: 
line 2006: " tcsh scripts (patterns ending in a star further below)
line 2007: au BufNewFile,BufRead .tcshrc,*.tcsh,tcsh.tcshrc,tcsh.login^Icall dist#ft#SetFileTypeShell("tcsh")
line 2008: 
line 2009: " csh scripts, but might also be tcsh scripts (on some systems csh is tcsh)
line 2010: " (patterns ending in a start further below)
line 2011: au BufNewFile,BufRead .login,.cshrc,csh.cshrc,csh.login,csh.logout,*.csh,.alias  call dist#ft#CSH()
line 2012: 
line 2013: " Zig and Zig Object Notation (ZON)
line 2014: au BufNewFile,BufRead *.zig,*.zon^I^Isetf zig
line 2015: 
line 2016: " Zserio
line 2017: au BufNewFile,BufRead *.zs^I^I^Isetf zserio
line 2018: 
line 2019: " Z-Shell script (patterns ending in a star further below)
line 2020: au BufNewFile,BufRead .zprofile,*/etc/zprofile,.zfbfmarks  setf zsh
line 2021: au BufNewFile,BufRead .zshrc,.zshenv,.zlogin,.zlogout,.zcompdump setf zsh
line 2022: au BufNewFile,BufRead *.zsh^I^I^Isetf zsh
line 2023: 
line 2024: " Scheme ("racket" patterns are now separate, see above)
line 2025: au BufNewFile,BufRead *.scm,*.ss,*.sld^I^Isetf scheme
line 2026: 
line 2027: " Screen RC
line 2028: au BufNewFile,BufRead .screenrc,screenrc^Isetf screen
line 2029: 
line 2030: " Sexplib
line 2031: au BufNewFile,BufRead *.sexp setf sexplib
line 2032: 
line 2033: " Simula
line 2034: au BufNewFile,BufRead *.sim^I^I^Isetf simula
line 2035: 
line 2036: " SINDA
line 2037: au BufNewFile,BufRead *.sin,*.s85^I^Isetf sinda
line 2038: 
line 2039: " SiSU
line 2040: au BufNewFile,BufRead *.sst,*.ssm,*.ssi,*.-sst,*._sst setf sisu
line 2041: au BufNewFile,BufRead *.sst.meta,*.-sst.meta,*._sst.meta setf sisu
line 2042: 
line 2043: " SKILL
line 2044: au BufNewFile,BufRead *.il,*.ils,*.cdf^I^Isetf skill
line 2045: 
line 2046: " Cadence
line 2047: au BufNewFile,BufRead *.cdc^I^I^Isetf cdc
line 2048: 
line 2049: " SLRN
line 2050: au BufNewFile,BufRead .slrnrc^I^I^Isetf slrnrc
line 2051: au BufNewFile,BufRead *.score^I^I^Isetf slrnsc
line 2052: 
line 2053: " Smali
line 2054: au BufNewFile,BufRead *.smali^I^I^Isetf smali
line 2055: 
line 2056: " Smalltalk
line 2057: au BufNewFile,BufRead *.st^I^I^Isetf st
line 2058: 
line 2059: " Smalltalk (and Rexx, TeX, and Visual Basic)
line 2060: au BufNewFile,BufRead *.cls^I^I^Icall dist#ft#FTcls()
line 2061: 
line 2062: " Smarty templates
line 2063: au BufNewFile,BufRead *.tpl^I^I^Isetf smarty
line 2064: 
line 2065: " SMIL or XML
line 2066: au BufNewFile,BufRead *.smil if getline(1) =~ '<?\s*xml.*?>' |   setf xml | else |   setf smil | endif
line 2072: 
line 2073: " SMIL or SNMP MIB file
line 2074: au BufNewFile,BufRead *.smi if getline(1) =~ '\<smil\>' |   setf smil | else |   setf mib | endif
line 2080: 
line 2081: " SMITH
line 2082: au BufNewFile,BufRead *.smt,*.smith^I^Isetf smith
line 2083: 
line 2084: " Smithy
line 2085: au BufNewFile,BufRead *.smithy^I^I^Isetf smithy
line 2086: 
line 2087: " Snobol4 and spitbol
line 2088: au BufNewFile,BufRead *.sno,*.spt^I^Isetf snobol4
line 2089: 
line 2090: " SNMP MIB files
line 2091: au BufNewFile,BufRead *.mib,*.my^I^Isetf mib
line 2092: 
line 2093: " Snort Configuration
line 2094: au BufNewFile,BufRead *.hog,snort.conf,vision.conf^Isetf hog
line 2095: au BufNewFile,BufRead *.rules^I^I^Icall dist#ft#FTRules()
line 2096: 
line 2097: " Solidity
line 2098: au BufRead,BufNewFile *.sol^I^I^Isetf solidity
line 2099: 
line 2100: " SPARQL queries
line 2101: au BufNewFile,BufRead *.rq,*.sparql^I^Isetf sparql
line 2102: 
line 2103: " Spec (Linux RPM)
line 2104: au BufNewFile,BufRead *.spec^I^I^Isetf spec
line 2105: 
line 2106: " Speedup (AspenTech plant simulator)
line 2107: au BufNewFile,BufRead *.speedup,*.spdata,*.spd^Isetf spup
line 2108: 
line 2109: " Slice
line 2110: au BufNewFile,BufRead *.ice^I^I^Isetf slice
line 2111: 
line 2112: " Microsoft Visual Studio Solution
line 2113: au BufNewFile,BufRead *.sln^I^I^Isetf solution
line 2114: au BufNewFile,BufRead *.slnf^I^I^Isetf json
line 2115: 
line 2116: " Spice
line 2117: au BufNewFile,BufRead *.sp,*.spice^I^Isetf spice
line 2118: 
line 2119: " Spyce
line 2120: au BufNewFile,BufRead *.spy,*.spi^I^Isetf spyce
line 2121: 
line 2122: " Squid
line 2123: au BufNewFile,BufRead squid.conf^I^Isetf squid
line 2124: 
line 2125: " SQL for Oracle Designer
line 2126: au BufNewFile,BufRead *.tyb,*.tyc,*.pkb,*.pks^Isetf sql
line 2127: 
line 2128: " *.typ can be either SQL or Typst files
line 2129: au BufNewFile,BufRead *.typ^I^I^Icall dist#ft#FTtyp()
line 2130: 
line 2131: " SQL
line 2132: au BufNewFile,BufRead *.sql^I^I^Icall dist#ft#SQL()
line 2133: 
line 2134: " SQLJ
line 2135: au BufNewFile,BufRead *.sqlj^I^I^Isetf sqlj
line 2136: 
line 2137: " PRQL
line 2138: au BufNewFile,BufRead *.prql^I^I^Isetf prql
line 2139: 
line 2140: " SQR
line 2141: au BufNewFile,BufRead *.sqr,*.sqi^I^Isetf sqr
line 2142: 
line 2143: " Squirrel
line 2144: au BufNewFile,BufRead *.nut^I^I^Isetf squirrel
line 2145: 
line 2146: " OpenSSH configuration
line 2147: au BufNewFile,BufRead ssh_config,*/.ssh/config,*/.ssh/*.conf^Isetf sshconfig
line 2148: au BufNewFile,BufRead */etc/ssh/ssh_config.d/*.conf^I^Isetf sshconfig
line 2149: 
line 2150: " OpenSSH server configuration
line 2151: au BufNewFile,BufRead sshd_config^I^I^Isetf sshdconfig
line 2152: au BufNewFile,BufRead */etc/ssh/sshd_config.d/*.conf^Isetf sshdconfig
line 2153: 
line 2154: " Starlark
line 2155: au BufNewFile,BufRead *.ipd,*.star,*.starlark^Isetf starlark
line 2156: 
line 2157: " OpenVPN configuration
line 2158: au BufNewFile,BufRead *.ovpn^I^I^Isetf openvpn
line 2159: au BufNewFile,BufRead */openvpn/*/*.conf^Isetf openvpn
line 2160: 
line 2161: " Stata
line 2162: au BufNewFile,BufRead *.ado,*.do,*.imata,*.mata^Isetf stata
line 2163: " Also *.class, but not when it's a Java bytecode file
line 2164: au BufNewFile,BufRead *.class if getline(1) !~ "^\xca\xfe\xba\xbe" | setf stata | endif
line 2166: 
line 2167: " SMCL
line 2168: au BufNewFile,BufRead *.hlp,*.ihlp,*.smcl^Isetf smcl
line 2169: 
line 2170: " Stored Procedures
line 2171: au BufNewFile,BufRead *.stp^I^I^Isetf stp
line 2172: 
line 2173: " Standard ML
line 2174: au BufNewFile,BufRead *.sml^I^I^Isetf sml
line 2175: 
line 2176: " Sratus VOS command macro
line 2177: au BufNewFile,BufRead *.cm^I^I^Isetf voscm
line 2178: 
line 2179: " Swift
line 2180: au BufNewFile,BufRead *.swift^I^I^Isetf swift
line 2181: au BufNewFile,BufRead *.swift.gyb^I^Isetf swiftgyb
line 2182: 
line 2183: " Swift Intermediate Language or SILE
line 2184: au BufNewFile,BufRead *.sil^I^I^Icall dist#ft#FTsil()
line 2185: 
line 2186: " Swig
line 2187: au BufNewFile,BufRead *.swg,*.swig setf swig
line 2188: 
line 2189: " Sysctl
line 2190: au BufNewFile,BufRead */etc/sysctl.conf,*/etc/sysctl.d/*.conf^Isetf sysctl
line 2191: 
line 2192: " Systemd unit files
line 2193: au BufNewFile,BufRead */systemd/*.{automount,dnssd,link,mount,netdev,network,nspawn,path,service,slice,socket,swap,target,timer}^Isetf systemd
line 2194: " Systemd overrides
line 2195: au BufNewFile,BufRead */etc/systemd/*.conf.d/*.conf^Isetf systemd
line 2196: au BufNewFile,BufRead */etc/systemd/system/*.d/*.conf^Isetf systemd
line 2197: au BufNewFile,BufRead */.config/systemd/user/*.d/*.conf^Isetf systemd
line 2198: " Systemd temp files
line 2199: au BufNewFile,BufRead */etc/systemd/system/*.d/.#*^Isetf systemd
line 2200: au BufNewFile,BufRead */etc/systemd/system/.#*^I^Isetf systemd
line 2201: au BufNewFile,BufRead */.config/systemd/user/*.d/.#*^Isetf systemd
line 2202: au BufNewFile,BufRead */.config/systemd/user/.#*^Isetf systemd
line 2203: 
line 2204: " Synopsys Design Constraints
line 2205: au BufNewFile,BufRead *.sdc^I^I^Isetf sdc
line 2206: 
line 2207: " Sudoers
line 2208: au BufNewFile,BufRead */etc/sudoers,sudoers.tmp^Isetf sudoers
line 2209: 
line 2210: " SVG (Scalable Vector Graphics)
line 2211: au BufNewFile,BufRead *.svg^I^I^Isetf svg
line 2212: 
line 2213: " Surface
line 2214: au BufRead,BufNewFile *.sface^I^I^Isetf surface
line 2215: 
line 2216: " LLVM TableGen
line 2217: au BufNewFile,BufRead *.td^I^I^Isetf tablegen
line 2218: 
line 2219: " Tads (or Nroff or Perl test file)
line 2220: au BufNewFile,BufRead *.t if !dist#ft#FTnroff() && !dist#ft#FTperl() | setf tads | endif
line 2222: 
line 2223: " Tags
line 2224: au BufNewFile,BufRead tags^I^I^Isetf tags
line 2225: 
line 2226: " TAK
line 2227: au BufNewFile,BufRead *.tak^I^I^Isetf tak
line 2228: 
line 2229: " Unx Tal
line 2230: au BufNewFile,BufRead *.tal^I^I^Isetf tal
line 2231: 
line 2232: " Task
line 2233: au BufRead,BufNewFile {pending,completed,undo}.data  setf taskdata
line 2234: au BufRead,BufNewFile *.task^I^I^Isetf taskedit
line 2235: 
line 2236: " Tcl (JACL too)
line 2237: au BufNewFile,BufRead *.tcl,*.tm,*.tk,*.itcl,*.itk,*.jacl,.tclshrc,.wishrc^Isetf tcl
line 2238: 
line 2239: " Teal
line 2240: au BufRead,BufNewFile *.tl^I^I^Isetf teal
line 2241: 
line 2242: " TealInfo
line 2243: au BufNewFile,BufRead *.tli^I^I^Isetf tli
line 2244: 
line 2245: " Telix Salt
line 2246: au BufNewFile,BufRead *.slt^I^I^Isetf tsalt
line 2247: 
line 2248: " Tera Term Language or Turtle
line 2249: au BufRead,BufNewFile *.ttl if getline(1) =~ '^@\?\(prefix\|base\)' |   setf turtle | else |   setf teraterm | endif
line 2255: 
line 2256: " Terminfo
line 2257: au BufNewFile,BufRead *.ti^I^I^Isetf terminfo
line 2258: 
line 2259: " Terraform variables
line 2260: au BufRead,BufNewFile *.tfvars^I^I^Isetf terraform-vars
line 2261: 
line 2262: " TeX
line 2263: au BufNewFile,BufRead *.latex,*.sty,*.dtx,*.ltx,*.bbl^Isetf tex
line 2264: au BufNewFile,BufRead *.tex^I^I^Icall dist#ft#FTtex()
line 2265: 
line 2266: " ConTeXt
line 2267: au BufNewFile,BufRead *.mkii,*.mkiv,*.mkvi,*.mkxl,*.mklx   setf context
line 2268: 
line 2269: " Texinfo
line 2270: au BufNewFile,BufRead *.texinfo,*.texi,*.txi^Isetf texinfo
line 2271: 
line 2272: " TeX configuration
line 2273: au BufNewFile,BufRead texmf.cnf^I^I^Isetf texmf
line 2274: 
line 2275: " Thrift (Apache)
line 2276: au BufNewFile,BufRead *.thrift^I^I^Isetf thrift
line 2277: 
line 2278: " Tidy config
line 2279: au BufNewFile,BufRead .tidyrc,tidyrc,tidy.conf^Isetf tidy
line 2280: 
line 2281: " TF mud client
line 2282: au BufNewFile,BufRead .tfrc,tfrc^I^Isetf tf
line 2283: 
line 2284: " TF mud client or terraform
line 2285: au BufNewFile,BufRead *.tf^I^I^Icall dist#ft#FTtf()
line 2286: 
line 2287: " TLA+
line 2288: au BufNewFile,BufRead *.tla^I^I^Isetf tla
line 2289: 
line 2290: " tmux configuration
line 2291: au BufNewFile,BufRead {.,}tmux*.conf^I^Isetf tmux
line 2292: 
line 2293: " TOML
line 2294: au BufNewFile,BufRead *.toml^I^I^Isetf toml
line 2295: 
line 2296: " TPP - Text Presentation Program
line 2297: au BufNewFile,BufRead *.tpp^I^I^Isetf tpp
line 2298: 
line 2299: " TRACE32 Script Language
line 2300: au BufNewFile,BufRead *.cmm,*.t32^I^Isetf trace32
line 2301: 
line 2302: " Treetop
line 2303: au BufRead,BufNewFile *.treetop^I^I^Isetf treetop
line 2304: 
line 2305: " Trustees
line 2306: au BufNewFile,BufRead trustees.conf^I^Isetf trustees
line 2307: 
line 2308: " TSS - Geometry
line 2309: au BufNewFile,BufReadPost *.tssgm^I^Isetf tssgm
line 2310: 
line 2311: " TSS - Optics
line 2312: au BufNewFile,BufReadPost *.tssop^I^Isetf tssop
line 2313: 
line 2314: " TSS - Command Line (temporary)
line 2315: au BufNewFile,BufReadPost *.tsscl^I^Isetf tsscl
line 2316: 
line 2317: " TSV Files
line 2318: au BufNewFile,BufRead *.tsv^I^I^Isetf tsv
line 2319: 
line 2320: " TWIG files
line 2321: au BufNewFile,BufReadPost *.twig^I^Isetf twig
line 2322: 
line 2323: " TypeScript or Qt translation file (which is XML)
line 2324: au BufNewFile,BufReadPost *.ts if getline(1) =~ '<?xml' |   setf xml | else |   setf typescript | endif
line 2330: 
line 2331: " TypeScript module and common
line 2332: au BufNewFile,BufRead *.mts,*.cts^I^Isetf typescript
line 2333: 
line 2334: " TypeScript with React
line 2335: au BufNewFile,BufRead *.tsx^I^I^Isetf typescriptreact
line 2336: 
line 2337: " Motif UIT/UIL files
line 2338: au BufNewFile,BufRead *.uit,*.uil^I^Isetf uil
line 2339: 
line 2340: " Udev conf
line 2341: au BufNewFile,BufRead */etc/udev/udev.conf^Isetf udevconf
line 2342: 
line 2343: " Udev permissions
line 2344: au BufNewFile,BufRead */etc/udev/permissions.d/*.permissions setf udevperm
line 2345: "
line 2346: " Udev symlinks config
line 2347: au BufNewFile,BufRead */etc/udev/cdsymlinks.conf^Isetf sh
line 2348: 
line 2349: " Ungrammar, AKA Un-grammar
line 2350: au BufNewFile,BufRead *.ungram^I^I^Isetf ungrammar
line 2351: 
line 2352: " UnrealScript
line 2353: au BufNewFile,BufRead *.uc^I^I^Isetf uc
line 2354: 
line 2355: " Updatedb
line 2356: au BufNewFile,BufRead */etc/updatedb.conf^Isetf updatedb
line 2357: 
line 2358: " Upstart (init(8)) config files
line 2359: au BufNewFile,BufRead */usr/share/upstart/*.conf^I       setf upstart
line 2360: au BufNewFile,BufRead */usr/share/upstart/*.override^I       setf upstart
line 2361: au BufNewFile,BufRead */etc/init/*.conf,*/etc/init/*.override  setf upstart
line 2362: au BufNewFile,BufRead */.init/*.conf,*/.init/*.override^I       setf upstart
line 2363: au BufNewFile,BufRead */.config/upstart/*.conf^I^I       setf upstart
line 2364: au BufNewFile,BufRead */.config/upstart/*.override^I       setf upstart
line 2365: 
line 2366: " URL shortcut
line 2367: au BufNewFile,BufRead *.url^I^I^Isetf urlshortcut
line 2368: 
line 2369: " V
line 2370: au BufNewFile,BufRead *.vsh,*.vv^I^I^Isetf v
line 2371: 
line 2372: " Vala
line 2373: au BufNewFile,BufRead *.vala^I^I^Isetf vala
line 2374: 
line 2375: " VDF
line 2376: au BufNewFile,BufRead *.vdf^I^I^Isetf vdf
line 2377: 
line 2378: " VDM
line 2379: au BufRead,BufNewFile *.vdmpp,*.vpp^I^Isetf vdmpp
line 2380: au BufRead,BufNewFile *.vdmrt^I^I^Isetf vdmrt
line 2381: au BufRead,BufNewFile *.vdmsl,*.vdm^I^Isetf vdmsl
line 2382: 
line 2383: " Vera
line 2384: au BufNewFile,BufRead *.vr,*.vri,*.vrh^I^Isetf vera
line 2385: 
line 2386: " Vagrant (uses Ruby syntax)
line 2387: au BufNewFile,BufRead Vagrantfile^I^Isetf ruby
line 2388: 
line 2389: " Verilog HDL, V or Coq
line 2390: au BufNewFile,BufRead *.v^I^I^Icall dist#ft#FTv()
line 2391: 
line 2392: " Verilog-AMS HDL
line 2393: au BufNewFile,BufRead *.va,*.vams^I^Isetf verilogams
line 2394: 
line 2395: " SystemVerilog
line 2396: au BufNewFile,BufRead *.sv,*.svh^I^Isetf systemverilog
line 2397: 
line 2398: " VHS tape
line 2399: " .tape is also used by TapeCalc, which we do not support ATM.  If TapeCalc
line 2400: " support is needed the contents of the file needs to be inspected.
line 2401: au BufNewFile,BufRead *.tape^I^I^Isetf vhs
line 2402: 
line 2403: " VHDL
line 2404: au BufNewFile,BufRead *.hdl,*.vhd,*.vhdl,*.vbe,*.vst,*.vho  setf vhdl
line 2405: 
line 2406: " Vim script
line 2407: au BufNewFile,BufRead *.vim,.exrc,_exrc^I^Isetf vim
line 2408: 
line 2409: " Viminfo file
line 2410: au BufNewFile,BufRead .viminfo,_viminfo^I^Isetf viminfo
line 2411: 
line 2412: " Virata Config Script File or Drupal module
line 2413: au BufRead,BufNewFile *.hw,*.module,*.pkg if getline(1) =~ '<?php' |   setf php | else |   setf virata | endif
line 2419: 
line 2420: " Visual Basic (see also *.bas *.cls)
line 2421: 
line 2422: " Visual Basic or FORM
line 2423: au BufNewFile,BufRead *.frm^I^I^Icall dist#ft#FTfrm()
line 2424: 
line 2425: " Visual Basic
line 2426: " user control, ActiveX document form, active designer, property page
line 2427: au BufNewFile,BufRead *.ctl,*.dob,*.dsr,*.pag^Isetf vb
line 2428: 
line 2429: " Visual Basic or Vimball Archiver
line 2430: au BufNewFile,BufRead *.vba^I^I^Icall dist#ft#FTvba()
line 2431: 
line 2432: " Visual Basic Project
line 2433: au BufNewFile,BufRead *.vbp^I^I^Isetf dosini
line 2434: 
line 2435: " VBScript (close to Visual Basic)
line 2436: au BufNewFile,BufRead *.vbs^I^I^Isetf vb
line 2437: 
line 2438: " Visual Basic .NET (close to Visual Basic)
line 2439: au BufNewFile,BufRead *.vb^I^I^Isetf vb
line 2440: 
line 2441: " Visual Studio Macro
line 2442: au BufNewFile,BufRead *.dsm^I^I^Isetf vb
line 2443: 
line 2444: " SaxBasic (close to Visual Basic)
line 2445: au BufNewFile,BufRead *.sba^I^I^Isetf vb
line 2446: 
line 2447: " Vgrindefs file
line 2448: au BufNewFile,BufRead vgrindefs^I^I^Isetf vgrindefs
line 2449: 
line 2450: " VRML V1.0c
line 2451: au BufNewFile,BufRead *.wrl^I^I^Isetf vrml
line 2452: 
line 2453: " Vroom (vim testing and executable documentation)
line 2454: au BufNewFile,BufRead *.vroom^I^I^Isetf vroom
line 2455: 
line 2456: " Vue.js Single File Component
line 2457: au BufNewFile,BufRead *.vue^I^I^Isetf vue
line 2458: 
line 2459: " WebAssembly
line 2460: au BufNewFile,BufRead *.wat,*.wast^I^Isetf wat
line 2461: 
line 2462: " WebAssembly Interface Type (WIT)
line 2463: au BufNewFile,BufRead *.wit^I^I^Isetf wit
line 2464: 
line 2465: " Webmacro
line 2466: au BufNewFile,BufRead *.wm^I^I^Isetf webmacro
line 2467: 
line 2468: " Wget config
line 2469: au BufNewFile,BufRead .wgetrc,wgetrc^I^Isetf wget
line 2470: 
line 2471: " Wget2 config
line 2472: au BufNewFile,BufRead .wget2rc,wget2rc^I^Isetf wget2
line 2473: 
line 2474: " WebGPU Shading Language (WGSL)
line 2475: au BufNewFile,BufRead *.wgsl^I^I^Isetf wgsl
line 2476: 
line 2477: " Website MetaLanguage
line 2478: au BufNewFile,BufRead *.wml^I^I^Isetf wml
line 2479: 
line 2480: " Winbatch
line 2481: au BufNewFile,BufRead *.wbt^I^I^Isetf winbatch
line 2482: 
line 2483: " WSML
line 2484: au BufNewFile,BufRead *.wsml^I^I^Isetf wsml
line 2485: 
line 2486: " WPL
line 2487: au BufNewFile,BufRead *.wpl^I^I^Isetf xml
line 2488: 
line 2489: " WvDial
line 2490: au BufNewFile,BufRead wvdial.conf,.wvdialrc^Isetf wvdial
line 2491: 
line 2492: " CVS RC file
line 2493: au BufNewFile,BufRead .cvsrc^I^I^Isetf cvsrc
line 2494: 
line 2495: " CVS commit file
line 2496: au BufNewFile,BufRead cvs\d\+^I^I^Isetf cvs
line 2497: 
line 2498: " WEB (*.web is also used for Winbatch: Guess, based on expecting "%" comment
line 2499: " lines in a WEB file).
line 2500: au BufNewFile,BufRead *.web if getline(1)[0].getline(2)[0].getline(3)[0].getline(4)[0].getline(5)[0] =~ "%" |   setf web | else |   setf winbatch | endif
line 2506: 
line 2507: " Windows Scripting Host and Windows Script Component
line 2508: au BufNewFile,BufRead *.ws[fc]^I^I^Isetf wsh
line 2509: 
line 2510: " XHTML
line 2511: au BufNewFile,BufRead *.xhtml,*.xht^I^Isetf xhtml
line 2512: 
line 2513: " X Pixmap (dynamically sets colors, this used to trigger on BufEnter to make
line 2514: " it work better, but that breaks setting 'filetype' manually)
line 2515: au BufNewFile,BufRead *.xpm if getline(1) =~ "XPM2" |   setf xpm2 | else |   setf xpm | endif
line 2521: au BufNewFile,BufRead *.xpm2^I^I^Isetf xpm2
line 2522: 
line 2523: " XFree86 config
line 2524: au BufNewFile,BufRead XF86Config if getline(1) =~ '\<XConfigurator\>' |   let b:xf86conf_xfree86_version = 3 | endif | setf xf86conf
line 2529: au BufNewFile,BufRead */xorg.conf.d/*.conf let b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2532: 
line 2533: " Xorg config
line 2534: au BufNewFile,BufRead xorg.conf,xorg.conf-4^Ilet b:xf86conf_xfree86_version = 4 | setf xf86conf
line 2535: 
line 2536: " Xinetd conf
line 2537: au BufNewFile,BufRead */etc/xinetd.conf^I^Isetf xinetd
line 2538: 
line 2539: " XS Perl extension interface language
line 2540: au BufNewFile,BufRead *.xs^I^I^Isetf xs
line 2541: 
line 2542: " X compose file
line 2543: au BufNewFile,BufRead .XCompose,Compose^Isetf xcompose
line 2544: 
line 2545: " X resources file
line 2546: au BufNewFile,BufRead .Xdefaults,.Xpdefaults,.Xresources,xdm-config,*.ad setf xdefaults
line 2547: 
line 2548: " Xmath
line 2549: au BufNewFile,BufRead *.msc,*.msf^I^Isetf xmath
line 2550: au BufNewFile,BufRead *.ms if !dist#ft#FTnroff() | setf xmath | endif
line 2552: 
line 2553: " XML  specific variants: docbk and xbl
line 2554: au BufNewFile,BufRead *.xml^I^I^Icall dist#ft#FTxml()
line 2555: 
line 2556: " XMI (holding UML models) is also XML
line 2557: au BufNewFile,BufRead *.xmi^I^I^Isetf xml
line 2558: 
line 2559: " CSPROJ files are Visual Studio.NET's XML-based C# project config files
line 2560: au BufNewFile,BufRead *.csproj,*.csproj.user^Isetf xml
line 2561: 
line 2562: " FSPROJ files are Visual Studio.NET's XML-based F# project config files
line 2563: au BufNewFile,BufRead *.fsproj,*.fsproj.user^Isetf xml
line 2564: 
line 2565: " VBPROJ files are Visual Studio.NET's XML-based Visual Basic project config files
line 2566: au BufNewFile,BufRead *.vbproj,*.vbproj.user^Isetf xml
line 2567: 
line 2568: " Unison Language
line 2569: au BufNewFile,BufRead *.u,*.uu^I^I^I^Isetf unison
line 2570: 
line 2571: " Qt Linguist translation source and Qt User Interface Files are XML
line 2572: " However, for .ts TypeScript is more common.
line 2573: au BufNewFile,BufRead *.ui^I^I^Isetf xml
line 2574: 
line 2575: " TPM's are RDF-based descriptions of TeX packages (Nikolai Weibull)
line 2576: au BufNewFile,BufRead *.tpm^I^I^Isetf xml
line 2577: 
line 2578: " Xdg menus
line 2579: au BufNewFile,BufRead */etc/xdg/menus/*.menu^Isetf xml
line 2580: 
line 2581: " ATI graphics driver configuration
line 2582: au BufNewFile,BufRead fglrxrc^I^I^Isetf xml
line 2583: 
line 2584: " Web Services Description Language (WSDL)
line 2585: au BufNewFile,BufRead *.wsdl^I^I^Isetf xml
line 2586: 
line 2587: " Workflow Description Language (WDL)
line 2588: au BufNewFile,BufRead *.wdl^I^I^Isetf wdl
line 2589: 
line 2590: " XLIFF (XML Localisation Interchange File Format) is also XML
line 2591: au BufNewFile,BufRead *.xlf^I^I^Isetf xml
line 2592: au BufNewFile,BufRead *.xliff^I^I^Isetf xml
line 2593: 
line 2594: " XML User Interface Language
line 2595: au BufNewFile,BufRead *.xul^I^I^Isetf xml
line 2596: 
line 2597: " X11 xmodmap (also see below)
line 2598: au BufNewFile,BufRead *Xmodmap^I^I^Isetf xmodmap
line 2599: 
line 2600: " Xquery
line 2601: au BufNewFile,BufRead *.xq,*.xql,*.xqm,*.xquery,*.xqy^Isetf xquery
line 2602: 
line 2603: " XSD
line 2604: au BufNewFile,BufRead *.xsd^I^I^Isetf xsd
line 2605: 
line 2606: " Xslt
line 2607: au BufNewFile,BufRead *.xsl,*.xslt^I^Isetf xslt
line 2608: 
line 2609: " Yacc
line 2610: au BufNewFile,BufRead *.yy,*.yxx,*.y++^I^Isetf yacc
line 2611: 
line 2612: " Yacc or racc
line 2613: au BufNewFile,BufRead *.y^I^I^Icall dist#ft#FTy()
line 2614: 
line 2615: " Yaml
line 2616: au BufNewFile,BufRead *.yaml,*.yml,*.eyaml^I^Isetf yaml
line 2617: 
line 2618: " Raml
line 2619: au BufNewFile,BufRead *.raml^I^I^Isetf raml
line 2620: 
line 2621: " yum conf (close enough to dosini)
line 2622: au BufNewFile,BufRead */etc/yum.conf^I^Isetf dosini
line 2623: 
line 2624: " YANG
line 2625: au BufRead,BufNewFile *.yang^I^I^Isetf yang
line 2626: 
line 2627: " Yuck
line 2628: au BufNewFile,BufRead *.yuck^I^I^Isetf yuck
line 2629: 
line 2630: " Zimbu
line 2631: au BufNewFile,BufRead *.zu^I^I^Isetf zimbu
line 2632: " Zimbu Templates
line 2633: au BufNewFile,BufRead *.zut^I^I^Isetf zimbutempl
line 2634: 
line 2635: " Zope
line 2636: "   dtml (zope dynamic template markup language), pt (zope page template),
line 2637: "   cpt (zope form controller page template)
line 2638: au BufNewFile,BufRead *.dtml,*.pt,*.cpt^I^Icall dist#ft#FThtml()
line 2639: "   zsql (zope sql method)
line 2640: au BufNewFile,BufRead *.zsql^I^I^Icall dist#ft#SQL()
line 2641: 
line 2642: " Z80 assembler asz80
line 2643: au BufNewFile,BufRead *.z8a^I^I^Isetf z8a
line 2644: 
line 2645: augroup END
line 2646: 
line 2647: 
line 2648: " Source the user-specified filetype file, for backwards compatibility with
line 2649: " Vim 5.x.
line 2650: if exists("myfiletypefile") && filereadable(expand(myfiletypefile))
line 2651:   execute "source " . myfiletypefile
line 2652: endif
line 2653: 
line 2654: 
line 2655: " Check for "*" after loading myfiletypefile, so that scripts.vim is only used
line 2656: " when there are no matching file name extensions.
line 2657: " Don't do this for compressed files.
line 2658: augroup filetypedetect
line 2659: au BufNewFile,BufRead * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
line 2662: au StdinReadPost * if !did_filetype() | runtime! scripts.vim | endif
line 2663: 
line 2664: 
line 2665: " Plain text files, needs to be far down to not override others.  This avoids
line 2666: " the "conf" type being used if there is a line starting with '#'.
line 2667: " But before patterns matching everything in a directory.
line 2668: au BufNewFile,BufRead *.text,README,LICENSE,COPYING,AUTHORS^Isetf text
line 2669: 
line 2670: 
line 2671: " Extra checks for when no filetype has been detected now.  Mostly used for
line 2672: " patterns that end in "*".  E.g., "zsh*" matches "zsh.vim", but that's a Vim
line 2673: " script file.
line 2674: " Most of these should call s:StarSetf() to avoid names ending in .gz and the
line 2675: " like are used.
line 2676: 
line 2677: " More Apache style config files
line 2678: au BufNewFile,BufRead */etc/proftpd/*.conf*,*/etc/proftpd/conf.*/*^Icall s:StarSetf('apachestyle')
line 2679: au BufNewFile,BufRead proftpd.conf*^I^I^I^I^Icall s:StarSetf('apachestyle')
line 2680: 
line 2681: " More Apache config files
line 2682: au BufNewFile,BufRead access.conf*,apache.conf*,apache2.conf*,httpd.conf*,srm.conf*^Icall s:StarSetf('apache')
line 2683: au BufNewFile,BufRead */etc/apache2/*.conf*,*/etc/apache2/conf.*/*,*/etc/apache2/mods-*/*,*/etc/apache2/sites-*/*,*/etc/httpd/conf.*/*,*/etc/httpd/mods-*/*,*/etc/httpd/sites-*/*,*/etc/httpd/conf.d/*.conf*^I^Icall s:StarSetf('apache')
line 2684: 
line 2685: " APT config file
line 2686: au BufNewFile,BufRead */etc/apt/apt.conf.d/{[-_[:alnum:]]\+,[-_.[:alnum:]]\+.conf} call s:StarSetf('aptconf')
line 2687: 
line 2688: " Asterisk config file
line 2689: au BufNewFile,BufRead *asterisk/*.conf*^I^Icall s:StarSetf('asterisk')
line 2690: au BufNewFile,BufRead *asterisk*/*voicemail.conf* call s:StarSetf('asteriskvm')
line 2691: 
line 2692: " Bazaar version control
line 2693: au BufNewFile,BufRead bzr_log.*^I^I^Isetf bzr
line 2694: 
line 2695: " Bazel and Buck2 build file
line 2696: if !has("fname_case")
line 2697:   au BufNewFile,BufRead *.BUILD,BUILD,BUCK^Isetf bzl
line 2698: endif
line 2699: 
line 2700: " BIND zone
line 2701: au BufNewFile,BufRead */named/db.*,*/bind/db.*^Icall s:StarSetf('bindzone')
line 2702: 
line 2703: au BufNewFile,BufRead cabal.project.*^I^Icall s:StarSetf('cabalproject')
line 2704: 
line 2705: " Calendar
line 2706: au BufNewFile,BufRead */.calendar/*,*/share/calendar/*/calendar.*,*/share/calendar/calendar.*^I^I^I^I^Icall s:StarSetf('calendar')
line 2709: 
line 2710: " Changelog
line 2711: au BufNewFile,BufRead [cC]hange[lL]og* if getline(1) =~ '; urgency='|  call s:StarSetf('debchangelog')|else|  call s:StarSetf('changelog')|endif
line 2717: 
line 2718: " Crontab
line 2719: au BufNewFile,BufRead crontab,crontab.*,*/etc/cron.d/*^I^Icall s:StarSetf('crontab')
line 2720: 
line 2721: " dnsmasq(8) configuration
line 2722: au BufNewFile,BufRead */etc/dnsmasq.d/*^I^Icall s:StarSetf('dnsmasq')
line 2723: 
line 2724: " Dockerfile
line 2725: au BufNewFile,BufRead Dockerfile.*,Containerfile.*^Icall s:StarSetf('dockerfile')
line 2726: 
line 2727: " Dracula
line 2728: au BufNewFile,BufRead drac.*^I^I^Icall s:StarSetf('dracula')
line 2729: 
line 2730: " Fvwm
line 2731: au BufNewFile,BufRead */.fvwm/*^I^I^Icall s:StarSetf('fvwm')
line 2732: au BufNewFile,BufRead *fvwmrc*,*fvwm95*.hook let b:fvwm_version = 1 | call s:StarSetf('fvwm')
line 2734: au BufNewFile,BufRead *fvwm2rc* if expand("<afile>:e") == "m4"|  call s:StarSetf('fvwm2m4')|else|  let b:fvwm_version = 2 | call s:StarSetf('fvwm')|endif
line 2740: 
line 2741: " Gedcom
line 2742: au BufNewFile,BufRead */tmp/lltmp*^I^Icall s:StarSetf('gedcom')
line 2743: 
line 2744: " Git
line 2745: au BufNewFile,BufRead */.gitconfig.d/*,*/etc/gitconfig.d/*^Icall s:StarSetf('gitconfig')
line 2746: 
line 2747: " Gitolite
line 2748: au BufNewFile,BufRead */gitolite-admin/conf/*^Icall s:StarSetf('gitolite')
line 2749: 
line 2750: " GTK RC
line 2751: au BufNewFile,BufRead .gtkrc*,gtkrc*^I^Icall s:StarSetf('gtkrc')
line 2752: 
line 2753: " Jam
line 2754: au BufNewFile,BufRead Prl*.*,JAM*.*^I^Icall s:StarSetf('jam')
line 2755: 
line 2756: " Jargon
line 2757: au! BufNewFile,BufRead *jarg* if getline(1).getline(2).getline(3).getline(4).getline(5) =~? 'THIS IS THE JARGON FILE'|  call s:StarSetf('jargon')|endif
line 2761: 
line 2762: " Java Properties resource file (note: doesn't catch font.properties.pl)
line 2763: au BufNewFile,BufRead *.properties_??_??_*^Icall s:StarSetf('jproperties')
line 2764: 
line 2765: " Kconfig
line 2766: au BufNewFile,BufRead Kconfig.*^I^I^Icall s:StarSetf('kconfig')
line 2767: 
line 2768: " Lilo: Linux loader
line 2769: au BufNewFile,BufRead lilo.conf*^I^Icall s:StarSetf('lilo')
line 2770: 
line 2771: " Libsensors
line 2772: au BufNewFile,BufRead */etc/sensors.d/[^.]*^Icall s:StarSetf('sensors')
line 2773: 
line 2774: " Logcheck
line 2775: au BufNewFile,BufRead */etc/logcheck/*.d*/*^Icall s:StarSetf('logcheck')
line 2776: 
line 2777: " Makefile
line 2778: au BufNewFile,BufRead [mM]akefile*^I^Icall s:StarSetf('make')
line 2779: 
line 2780: " Ruby Makefile
line 2781: au BufNewFile,BufRead [rR]akefile*^I^Icall s:StarSetf('ruby')
line 2782: 
line 2783: " Mail (also matches muttrc.vim, so this is below the other checks)
line 2784: au BufNewFile,BufRead {neo,}mutt[[:alnum:]._-]\\\{6\}^Isetf mail
line 2785: 
line 2786: au BufNewFile,BufRead reportbug-*^I^Icall s:StarSetf('mail')
line 2787: 
line 2788: " Modconf
line 2789: au BufNewFile,BufRead */etc/modutils/* if executable(expand("<afile>")) != 1|  call s:StarSetf('modconf')|endif
line 2793: au BufNewFile,BufRead */etc/modprobe.*^I^Icall s:StarSetf('modconf')
line 2794: 
line 2795: " Mutt setup files (must be before catch *.rc)
line 2796: au BufNewFile,BufRead */etc/Muttrc.d/*^I^Icall s:StarSetf('muttrc')
line 2797: 
line 2798: " Mutt setup file
line 2799: au BufNewFile,BufRead .mutt{ng,}rc*,*/.mutt{ng,}/mutt{ng,}rc*^Icall s:StarSetf('muttrc')
line 2800: au BufNewFile,BufRead mutt{ng,}rc*,Mutt{ng,}rc*^I^Icall s:StarSetf('muttrc')
line 2801: 
line 2802: " Neomutt setup file
line 2803: au BufNewFile,BufRead .neomuttrc*,*/.neomutt/neomuttrc*^Icall s:StarSetf('neomuttrc')
line 2804: au BufNewFile,BufRead neomuttrc*,Neomuttrc*^I^Icall s:StarSetf('neomuttrc')
line 2805: 
line 2806: " Nroff macros
line 2807: au BufNewFile,BufRead tmac.*^I^I^Icall s:StarSetf('nroff')
line 2808: 
line 2809: " OpenBSD hostname.if
line 2810: au BufNewFile,BufRead */etc/hostname.*^I^Icall s:StarSetf('config')
line 2811: 
line 2812: " Pam conf
line 2813: au BufNewFile,BufRead */etc/pam.d/*^I^Icall s:StarSetf('pamconf')
line 2814: 
line 2815: " Printcap and Termcap
line 2816: au BufNewFile,BufRead *printcap* if !did_filetype()|  let b:ptcap_type = "print" | call s:StarSetf('ptcap')|endif
line 2820: au BufNewFile,BufRead *termcap* if !did_filetype()|  let b:ptcap_type = "term" | call s:StarSetf('ptcap')|endif
line 2824: 
line 2825: " ReDIF
line 2826: " Only used when the .rdf file was not detected to be XML.
line 2827: au BufRead,BufNewFile *.rdf^I^I^Icall dist#ft#Redif()
line 2828: 
line 2829: " Remind
line 2830: au BufNewFile,BufRead .reminders*^I^Icall s:StarSetf('remind')
line 2831: 
line 2832: " SGML catalog file
line 2833: au BufNewFile,BufRead sgml.catalog*^I^Icall s:StarSetf('catalog')
line 2834: 
line 2835: " avoid doc files being recognized a shell files
line 2836: au BufNewFile,BufRead */doc/{,.}bash[_-]completion{,.d,.sh}{,/*} setf text
line 2837: 
line 2838: " Shell scripts ending in a star
line 2839: au BufNewFile,BufRead .bashrc*,.bash[_-]profile*,.bash[_-]logout*,.bash[_-]aliases*,bash-fc[-.]*,PKGBUILD*,APKBUILD*,*/{,.}bash[_-]completion{,.d,.sh}{,/*} call dist#ft#SetFileTypeSH("bash")
line 2840: au BufNewFile,BufRead .kshrc* call dist#ft#SetFileTypeSH("ksh")
line 2841: au BufNewFile,BufRead .profile* call dist#ft#SetFileTypeSH(getline(1))
line 2842: 
line 2843: " Sudoers
line 2844: au BufNewFile,BufRead */etc/sudoers.d/*^I^Icall s:StarSetf('sudoers')
line 2845: 
line 2846: " tcsh scripts ending in a star
line 2847: au BufNewFile,BufRead .tcshrc*^Icall dist#ft#SetFileTypeShell("tcsh")
line 2848: 
line 2849: " csh scripts ending in a star
line 2850: au BufNewFile,BufRead .login*,.cshrc*  call dist#ft#CSH()
line 2851: 
line 2852: " tmux configuration with arbitrary extension
line 2853: au BufNewFile,BufRead {.,}tmux*.conf*^I^Isetf tmux
line 2854: 
line 2855: " Universal Scene Description
line 2856: au BufNewFile,BufRead *.usda,*.usd^I^Isetf usd
line 2857: 
line 2858: " VHDL
line 2859: au BufNewFile,BufRead *.vhdl_[0-9]*^I^Icall s:StarSetf('vhdl')
line 2860: 
line 2861: " Vim script
line 2862: au BufNewFile,BufRead *vimrc*^I^I^Icall s:StarSetf('vim')
line 2863: 
line 2864: " Subversion commit file
line 2865: au BufNewFile,BufRead svn-commit*.tmp^I^Isetf svn
line 2866: 
line 2867: " X resources file
line 2868: au BufNewFile,BufRead Xresources*,*/app-defaults/*,*/Xresources/* call s:StarSetf('xdefaults')
line 2869: 
line 2870: " XFree86 config
line 2871: au BufNewFile,BufRead XF86Config-4* let b:xf86conf_xfree86_version = 4 | call s:StarSetf('xf86conf')
line 2873: au BufNewFile,BufRead XF86Config* if getline(1) =~ '\<XConfigurator\>'|  let b:xf86conf_xfree86_version = 3|endif|call s:StarSetf('xf86conf')
line 2878: 
line 2879: " XKB
line 2880: au BufNewFile,BufRead */usr/share/X11/xkb/{compat,geometry,keycodes,symbols,types}/*^Icall s:StarSetf('xkb')
line 2881: 
line 2882: " X11 xmodmap
line 2883: au BufNewFile,BufRead *xmodmap*^I^I^Icall s:StarSetf('xmodmap')
line 2884: 
line 2885: " Xinetd conf
line 2886: au BufNewFile,BufRead */etc/xinetd.d/*^I^Icall s:StarSetf('xinetd')
line 2887: 
line 2888: " yum conf (close enough to dosini)
line 2889: au BufNewFile,BufRead */etc/yum.repos.d/*^Icall s:StarSetf('dosini')
line 2890: 
line 2891: " Z-Shell script ending in a star
line 2892: au BufNewFile,BufRead .zsh*,.zlog*,.zcompdump*  call s:StarSetf('zsh')
line 2893: au BufNewFile,BufRead zsh*,zlog*^I^Icall s:StarSetf('zsh')
line 2894: 
line 2895: 
line 2896: " Help files match *.txt but should have a last line that is a modeline.
line 2897: au BufNewFile,BufRead *.txt  if getline('$') !~ 'vim:.*ft=help'|   setf text| endif
line 2901: 
line 2902: " Blueprint markup files
line 2903: au BufNewFile,BufRead *.blp^I^I^Isetf blueprint
line 2904: 
line 2905: " Use the filetype detect plugins.  They may overrule any of the previously
line 2906: " detected filetypes.
line 2907: runtime! ftdetect/*.vim
Searching for "ftdetect/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\ftdetect/*.vim"
Searching for "C:\Program Files\Vim/vimfiles\ftdetect/*.vim"
Searching for "C:\Program Files\Vim\vim90\ftdetect/*.vim"
Searching for "C:\Users\chris/vimfiles/after\ftdetect/*.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\ftdetect/*.vim"
not found in 'runtimepath': "ftdetect/*.vim"
line 2908: 
line 2909: " NOTE: The above command could have ended the filetypedetect autocmd group
line 2910: " and started another one. Let's make sure it has ended to get to a consistent
line 2911: " state.
line 2912: augroup END
line 2913: 
line 2914: " Generic configuration file. Use FALLBACK, it's just guessing!
line 2915: au filetypedetect BufNewFile,BufRead,StdinReadPost * if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif
line 2923: 
line 2924: 
line 2925: " If the GUI is already running, may still need to install the Syntax menu.
line 2926: " Don't do it when the 'M' flag is included in 'guioptions'.
line 2927: if has("menu") && has("gui_running") && !exists("did_install_syntax_menu") && &guioptions !~# "M"
line 2929:   source <sfile>:p:h/menu.vim
line 2930: endif
line 2931: 
line 2932: " Function called for testing all functions defined here.  These are
line 2933: " script-local, thus need to be executed here.
line 2934: " Returns a string with error messages (hopefully empty).
line 2935: func TestFiletypeFuncs(testlist)
line 2946: 
line 2947: " Restore 'cpoptions'
line 2948: let &cpo = s:cpo_save
line 2949: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\filetype.vim
continuing in C:\Program Files\Vim\vim90\syntax\syntax.vim
Searching for "C:\Users\chris/vimfiles/after\filetype.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\filetype.vim"
line 27:   let s:did_ft = 0
line 28: endif
line 29: 
line 30: " Set up the connection between FileType and Syntax autocommands.
line 31: " This makes the syntax automatically set when the file type is detected.
line 32: " Avoid an error when 'verbose' is set and <amatch> expansion fails.
line 33: augroup syntaxset
line 34:   au! FileType *^I0verbose exe "set syntax=" . expand("<amatch>")
line 35: augroup END
line 36: 
line 37: 
line 38: " Execute the syntax autocommands for the each buffer.
line 39: " If the filetype wasn't detected yet, do that now.
line 40: " Always do the syntaxset autocommands, for buffers where the 'filetype'
line 41: " already was set manually (e.g., help buffers).
line 42: doautoall syntaxset FileType
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 43: if !s:did_ft
line 44:   doautoall filetypedetect BufRead
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif

Executing: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat | runtime! scripts.vim | endif
Executing:  runtime! scripts.vim | endif
Searching for "scripts.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\scripts.vim"
Searching for "C:\Program Files\Vim/vimfiles\scripts.vim"
Searching for "C:\Program Files\Vim\vim90\scripts.vim"
line 0: sourcing "C:\Program Files\Vim\vim90\scripts.vim"
line 1: " Vim support file to detect file types in scripts
line 2: "
line 3: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 4: " Last Change:^I2023 Aug 27
line 5: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 6: 
line 7: " This file is called by an autocommand for every file that has just been
line 8: " loaded into a buffer.  It checks if the type of file can be recognized by
line 9: " the file contents.  The autocommand is in $VIMRUNTIME/filetype.vim.
line 10: 
line 11: 
line 12: " Bail out when a FileType autocommand has already set the filetype.
line 13: if did_filetype()
line 14:   finish
line 15: endif
line 16: 
line 17: " Load the user defined scripts file first
line 18: " Only do this when the FileType autocommand has not been triggered yet
line 19: if exists("myscriptsfile") && filereadable(expand(myscriptsfile))
line 20:   execute "source " . myscriptsfile
line 21:   if did_filetype()
line 22:     finish
line 23:   endif
line 24: endif
line 25: 
line 26: " The main code is in a compiled function for speed.
line 27: call dist#script#DetectFiletype()
Searching for "autoload/dist/script.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\autoload/dist/script.vim"
Searching for "C:\Program Files\Vim/vimfiles\autoload/dist/script.vim"
Searching for "C:\Program Files\Vim\vim90\autoload/dist/script.vim"
line 27: sourcing "C:\Program Files\Vim\vim90\autoload\dist\script.vim"
line 1: vim9script
line 2: 
line 3: # Vim function for detecting a filetype from the file contents.
line 4: # Invoked from "scripts.vim" in 'runtimepath'
line 5: #
line 6: # Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 7: # Last Change:^I2023 Aug 10
line 8: # Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 9: 
line 10: export def DetectFiletype()
line 20: 
line 21: # Called for a script that has "#!" in the first line.
line 22: def DetectFromHashBang(firstline: string)
line 62: 
line 63: # Returns the filetype name associated with program "name".
line 64: # "line1" is the #! line at the top of the file.  Use the same as "name" if
line 65: # not available.
line 66: # Returns an empty string when not recognized.
line 67: export def Exe2filetype(name: string, line1: string): string
line 232: 
line 233: 
line 234: # Called for a script that does not have "#!" in the first line.
line 235: def DetectFromText(line1: string)
finished sourcing C:\Program Files\Vim\vim90\autoload\dist\script.vim
continuing in C:\Program Files\Vim\vim90\scripts.vim
finished sourcing C:\Program Files\Vim\vim90\scripts.vim
continuing in BufRead Autocommands for "*"
Searching for "C:\Users\chris/vimfiles/after\scripts.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\scripts.vim"
Executing:  endif
Executing BufRead Autocommands for "*"
autocommand if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif

Executing: if !did_filetype() && expand("<amatch>") !~ g:ft_ignore_pat    && (expand("<amatch>") =~# '\.conf$'^I|| getline(1) =~ '^#' || getline(2) =~ '^#'^I|| getline(3) =~ '^#' || getline(4) =~ '^#'^I|| getline(5) =~ '^#') |   setf FALLBACK conf | endif
Executing:    setf FALLBACK conf | endif
Executing:  endif
line 45: endif
finished sourcing C:\Program Files\Vim\vim90\syntax\syntax.vim
continuing in C:\Users\chris\_vimrc
line 12: set termguicolors on
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 12: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\_vimrc
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
                                                                       Error detected while processing C:\Users\chris\_vimrc:
line   12:
E518: Unknown option: on
line 13: colorscheme abbott
Searching for "colors/lists/default.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles\colors/lists/default.vim"
Searching for "C:\Program Files\Vim\vim90\colors/lists/default.vim"
line 13: sourcing "C:\Program Files\Vim\vim90\colors\lists\default.vim"
line 1: " Maintainer:  Drew Vogel <dvogel@sidejump.org>
line 2: " Last Change: 2023 Apr 19
line 3: "
line 4: " Replaced rgb.txt as the source of de facto standard color names. This is
line 5: " sourced each time the colorscheme command is run. It is also sourced each
line 6: " time the highlight command fails to recognize a gui color. You can override
line 7: " these colors by introducing a new colors/lists/default.vim file earlier in
line 8: " the runtimepath.
line 9: 
line 10: " make sure line continuation works
line 11: let s:keepcpo = &cpo
line 12: set cpo&vim
line 13: 
line 14: call extend(v:colornames, { 'snow': '#fffafa', 'ghost white': '#f8f8ff', 'ghostwhite': '#f8f8ff', 'white smoke': '#f5f5f5', 'whitesmoke': '#f5f5f5', 'gainsboro': '#dcdcdc', 'floral white': '#fffaf0', 'floralwhite': '#fffaf0', 'old lace': '#fdf5e6', 'oldlace': '#fdf5e6', 'linen': '#faf0e6', 'antique white': '#faebd7', 'antiquewhite': '#faebd7', 'papaya whip': '#ffefd5', 'papayawhip': '#ffefd5', 'blanched almond': '#ffebcd', 'blanchedalmond': '#ffebcd', 'bisque': '#ffe4c4', 'peach puff': '#ffdab9', 'peachpuff': '#ffdab9', 'navajo white': '#ffdead', 'navajowhite': '#ffdead', 'moccasin': '#ffe4b5', 'cornsilk': '#fff8dc', 'ivory': '#fffff0', 'lemon chiffon': '#fffacd', 'lemonchiffon': '#fffacd', 'seashell': '#fff5ee', 'honeydew': '#f0fff0', 'mint cream': '#f5fffa', 'mintcream': '#f5fffa', 'azure': '#f0ffff', 'alice blue': '#f0f8ff', 'aliceblue': '#f0f8ff', 'lavender': '#e6e6fa', 'lavender blush': '#fff0f5', 'lavenderblush': '#fff0f5', 'misty rose': '#ffe4e1', 'mistyrose': '#ffe4e1', 'white': '#ffffff', 'b
line 804: 
line 805: let &cpo = s:keepcpo
line 806: unlet s:keepcpo
line 807: 
line 808: "vim: sw=4
finished sourcing C:\Program Files\Vim\vim90\colors\lists\default.vim
continuing in C:\Users\chris\_vimrc
Searching for "C:\Users\chris/vimfiles/after\colors/lists/default.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\colors/lists/default.vim"
Searching for "colors/abbott.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\colors/abbott.vim"
line 13: sourcing "C:\Users\chris\vimfiles\colors\abbott.vim"
line 1: " abbott.vim <https://github.com/bcat/abbott.vim>
line 2: " A warm, dark color scheme for prose and code, with pastels and pretty greens.
line 3: "
line 4: " Copyright 2011-2013, 2015, 2017, 2020-2021 Jonathan Rascher
line 5: "
line 6: " Permission to use, copy, modify, and/or distribute this software for any
line 7: " purpose with or without fee is hereby granted, provided that the above
line 8: " copyright notice and this permission notice appear in all copies.
line 9: "
line 10: " THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
line 11: " REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
line 12: " AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
line 13: " INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
line 14: " LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
line 15: " OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
line 16: " PERFORMANCE OF THIS SOFTWARE.
line 17: 
line 18: " Define 16 colors that map reasonably well onto the standard ANSI color
line 19: " palette. Indeed, the terminal emulator can be configured to use these colors
line 20: " instead of its standard palette without issues.
line 21: "
line 22: " Approximations for 256-color terminals were chosen with the colors.sh script.
line 23: " Unfortunately, the XTerm 256-color palette doesn't contain many shades of
line 24: " brown, so we approximate bistre (ANSI 0) and cocoa (ANSI 8) using gray
line 25: " instead. Additionally, we use a slightly brighter approximation for cinnabar
line 26: " and French pink because the closest approximations look too reddish and too
line 27: " dull, respectively.
line 28: 
line 29: " ANSI black (0), bright black (8):
line 30: let s:bistre = {'rgb': '#231c14', 'term256': '234', 'term16': '0'}
line 31: let s:cocoa = {'rgb': '#745d42', 'term256': '241', 'term16': '8'}
line 32: 
line 33: " ANSI red (1), bright red (9):
line 34: let s:crimson = {'rgb': '#d80450', 'term256': '161', 'term16': '1'}
line 35: let s:cinnabar = {'rgb': '#f63f05', 'term256': '202', 'term16': '9'}
line 36: 
line 37: " ANSI green (2), bright green (10):
line 38: let s:forest_green = {'rgb': '#24a507', 'term256': '34', 'term16': '2'}
line 39: let s:chartreuse = {'rgb': '#a0ea00', 'term256': '154', 'term16': '10'}
line 40: 
line 41: " ANSI yellow (3), bright yellow (11):
line 42: let s:marigold = {'rgb': '#fbb32f', 'term256': '214', 'term16': '3'}
line 43: let s:lemon_meringue = {'rgb': '#fbec5d', 'term256': '227', 'term16': '11'}
line 44: 
line 45: " ANSI blue (4), bright blue (12):
line 46: let s:cornflower_blue = {'rgb': '#3f91f1', 'term256': '33', 'term16': '4'}
line 47: let s:periwinkle_blue = {'rgb': '#8ccdf0', 'term256': '117', 'term16': '12'}
line 48: 
line 49: " ANSI magenta (5), bright magenta (13):
line 50: let s:french_pink = {'rgb': '#ec6c99', 'term256': '204', 'term16': '5'}
line 51: let s:lavender = {'rgb': '#e6a2f3', 'term256': '219', 'term16': '13'}
line 52: 
line 53: " ANSI cyan (6), bright cyan (14):
line 54: let s:zomp = {'rgb': '#39a78d', 'term256': '36', 'term16': '6'}
line 55: let s:seafoam_green = {'rgb': '#00ff7f', 'term256': '48', 'term16': '14'}
line 56: 
line 57: " ANSI white (7), bright white (15):
line 58: let s:pastel_chartreuse = {'rgb': '#d8ff84', 'term256': '192', 'term16': '7'}
line 59: let s:vanilla_cream = {'rgb': '#fef3b4', 'term256': '229', 'term16': '15'}
line 60: 
line 61: " Additionally, define an extra shade of brown for use in highlighted lines and
line 62: " columns, as well as a dark green for visual selection background. For
line 63: " 256-color terminals, we map these colors to shades of gray like bistre and
line 64: " cocoa. For 16-color terminals, since we don't have any extra colors, we map
line 65: " these both to the same color as cocoa. That doesn't give a ton of contrast,
line 66: " but it's the best we can do.
line 67: 
line 68: let s:chocolate = {'rgb': '#3c3022', 'term256': '236', 'term16': '8'}
line 69: let s:dark_olive = {'rgb': '#273900', 'term256': '238', 'term16': '8'}
line 70: 
line 71: " This color scheme offers some additional features that are disabled by default
line 72: " because they may not interact well with all terminals or with other Vim color
line 73: " schemes. These features can be enabled if the user likes to live dangerously.
line 74: 
line 75: " If requested by the user, restrain ourselves to only the 16 standard ANSI
line 76: " terminal colors even if Vim thinks the terminal supports 256 colors. This
line 77: " allows the user to configure their terminal emulator to use the 16 colors
line 78: " defined above for its ANSI palette, allowing exact color matches rather than
line 79: " 256-color approximations even in terminals that don't support true color.
line 80: if !exists('g:abbott_force_16_colors')
line 81:   let g:abbott_force_16_colors = 0
line 82: endif
line 83: 
line 84: " If requested by the user, use our standard 16-color palette for the embedded
line 85: " terminal. We don't do this by default because unlike the highlight groups
line 86: " above, this isn't automatically cleared when another color scheme is selected.
line 87: if !exists('g:abbott_set_term_ansi_colors')
line 88:   let g:abbott_set_term_ansi_colors = 0
line 89: endif
line 90: 
line 91: " By default, the foreground text color will be replaced by the underline color
line 92: " in the terminal since if the terminal does not support setting the underline
line 93: " color separately, that color will be completely invisible.
line 94: if !exists('g:abbott_term_set_underline_color')
line 95:   let g:abbott_term_set_underline_color = 0
line 96: endif
line 97: 
line 98: " By default, Italics in the terminal are disabled since the default terminfo
line 99: " for GNU Screen renders italics as reverse video, and since other terminals
line 100: " like hterm may show artifacts when rendering italics.
line 101: if !exists('g:abbott_term_use_italics')
line 102:   let g:abbott_term_use_italics = 0
line 103: endif
line 104: 
line 105: " By default, underlined text will be used in the terminal in place of
line 106: " undercurl, because some terminfo entries cause Vim to think the terminal
line 107: " supports undercurl when it really does not
line 108: " (https://github.com/vim/vim/issues/3471).
line 109: if !exists('g:abbott_term_use_undercurl')
line 110:   let g:abbott_term_use_undercurl = 0
line 111: endif
line 112: 
line 113: " Returns the appropriate color index for the current terminal. We currently
line 114: " only have special support for the 256-color XTerm palette. All other terminals
line 115: " get the standard 16-color ANSI palette.
line 116: "
line 117: " We could add support for the 88-color XTerm palette or legacy
line 118: " XTerm-incompatible 256-color palettes, but it doesn't seem worth the effort.
line 119: "
line 120: " Direct color (a.k.a. true color or 24-bit color) is handled differently: if
line 121: " the termguicolors option is set, Vim uses guifg/guibg/guisp, and
line 122: " ctermfg/ctermbg/ctermul are ignored.
line 123: function! s:TermColor(color)
line 127: 
line 128: " Returns whether Vim supports the ctermul highlight parameter.
line 129: function! s:HasTermUnderlineColor()
line 132: 
line 133: " Highlights {group} according to the configuration given in {style}. The style
line 134: " dictionary may have color constant values with keys 'fg', 'bg', and 'sp' to
line 135: " set the highlight group's foreground, background, and underline colors,
line 136: " respectively. Additionally, the 'attrs' key, if present, should map to a list
line 137: " of terminal attributes.
line 138: function! s:H(group, style)
line 183: 
line 184: " Mark abbott.vim as a dark theme.
line 185: set background=dark
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 185: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 186: 
line 187: " Reset existing syntax highlights to their default settings.
line 188: highlight clear
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 188: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 189: if exists('g:syntax_on')
line 190:   syntax reset
line 190: runtime! syntax/syncolor.vim
Searching for "syntax/syncolor.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim\vim90\syntax/syncolor.vim"
line 190: sourcing "C:\Program Files\Vim\vim90\syntax\syncolor.vim"
line 1: " Vim syntax support file
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " This file sets up the default methods for highlighting.
line 7: " It is loaded from "synload.vim" and from Vim for ":syntax reset".
line 8: " Also used from init_highlight().
line 9: 
line 10: if !exists("syntax_cmd") || syntax_cmd == "on"
line 11:   " ":syntax on" works like in Vim 5.7: set colors but keep links
line 12:   command -nargs=* SynColor hi <args>
line 13:   command -nargs=* SynLink hi link <args>
line 14: else
line 15:   if syntax_cmd == "enable"
line 16:     " ":syntax enable" keeps any existing colors
line 17:     command -nargs=* SynColor hi def <args>
line 18:     command -nargs=* SynLink hi def link <args>
line 19:   elseif syntax_cmd == "reset"
line 20:     " ":syntax reset" resets all colors to the default
line 21:     command -nargs=* SynColor hi <args>
line 22:     command -nargs=* SynLink hi! link <args>
line 23:   else
line 24:     " User defined syncolor file has already set the colors.
line 25:     finish
line 26:   endif
line 27: endif
line 28: 
line 29: " Many terminals can only use six different colors (plus black and white).
line 30: " Therefore the number of colors used is kept low. It doesn't look nice with
line 31: " too many colors anyway.
line 32: " Careful with "cterm=bold", it changes the color to bright for some terminals.
line 33: " There are two sets of defaults: for a dark and a light background.
line 34: if &background == "dark"
line 35:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 35: hi Comment^Iterm=bold cterm=NONE ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#80a0ff guibg=NONE
line 36:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 36: hi Constant^Iterm=underline cterm=NONE ctermfg=Magenta ctermbg=NONE gui=NONE guifg=#ffa0a0 guibg=NONE
line 37:   SynColor Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 37: hi Special^Iterm=bold cterm=NONE ctermfg=LightRed ctermbg=NONE gui=NONE guifg=Orange guibg=NONE
line 38:   SynColor Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 38: hi Identifier^Iterm=underline cterm=bold ctermfg=Cyan ctermbg=NONE gui=NONE guifg=#40ffff guibg=NONE
line 39:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 39: hi Statement^Iterm=bold cterm=NONE ctermfg=Yellow ctermbg=NONE gui=bold guifg=#ffff60 guibg=NONE
line 40:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 40: hi PreProc^Iterm=underline cterm=NONE ctermfg=LightBlue ctermbg=NONE gui=NONE guifg=#ff80ff guibg=NONE
line 41:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 41: hi Type^I^Iterm=underline cterm=NONE ctermfg=LightGreen ctermbg=NONE gui=bold guifg=#60ff60 guibg=NONE
line 42:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 42: hi Underlined^Iterm=underline cterm=underline ctermfg=LightBlue gui=underline guifg=#80a0ff
line 43:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 43: hi Ignore^Iterm=NONE cterm=NONE ctermfg=black ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 44: else
line 45:   SynColor Comment^Iterm=bold cterm=NONE ctermfg=DarkBlue ctermbg=NONE gui=NONE guifg=Blue guibg=NONE
line 46:   SynColor Constant^Iterm=underline cterm=NONE ctermfg=DarkRed ctermbg=NONE gui=NONE guifg=Magenta guibg=NONE
line 47:   " #6a5acd is SlateBlue
line 48:   SynColor Special^Iterm=bold cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a5acd guibg=NONE
line 49:   SynColor Identifier^Iterm=underline cterm=NONE ctermfg=DarkCyan ctermbg=NONE gui=NONE guifg=DarkCyan guibg=NONE
line 50:   SynColor Statement^Iterm=bold cterm=NONE ctermfg=Brown ctermbg=NONE gui=bold guifg=Brown guibg=NONE
line 51:   " #6a0dad is Purple
line 52:   SynColor PreProc^Iterm=underline cterm=NONE ctermfg=DarkMagenta ctermbg=NONE gui=NONE guifg=#6a0dad guibg=NONE
line 53:   SynColor Type^I^Iterm=underline cterm=NONE ctermfg=DarkGreen ctermbg=NONE gui=bold guifg=SeaGreen guibg=NONE
line 54:   SynColor Underlined^Iterm=underline cterm=underline ctermfg=DarkMagenta gui=underline guifg=SlateBlue
line 55:   SynColor Ignore^Iterm=NONE cterm=NONE ctermfg=white ctermbg=NONE gui=NONE guifg=bg guibg=NONE
line 56: endif
line 57: SynColor Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 57: hi Error^I^Iterm=reverse cterm=NONE ctermfg=White ctermbg=Red gui=NONE guifg=White guibg=Red
line 58: SynColor Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 58: hi Todo^I^Iterm=standout cterm=NONE ctermfg=Black ctermbg=Yellow gui=NONE guifg=Blue guibg=Yellow
line 59: 
line 60: " Common groups that link to default highlighting.
line 61: " You can specify other highlighting easily.
line 62: SynLink String^I^IConstant
line 62: hi! link String^I^IConstant
line 63: SynLink Character^IConstant
line 63: hi! link Character^IConstant
line 64: SynLink Number^I^IConstant
line 64: hi! link Number^I^IConstant
line 65: SynLink Boolean^I^IConstant
line 65: hi! link Boolean^I^IConstant
line 66: SynLink Float^I^INumber
line 66: hi! link Float^I^INumber
line 67: SynLink Function^IIdentifier
line 67: hi! link Function^IIdentifier
line 68: SynLink Conditional^IStatement
line 68: hi! link Conditional^IStatement
line 69: SynLink Repeat^I^IStatement
line 69: hi! link Repeat^I^IStatement
line 70: SynLink Label^I^IStatement
line 70: hi! link Label^I^IStatement
line 71: SynLink Operator^IStatement
line 71: hi! link Operator^IStatement
line 72: SynLink Keyword^I^IStatement
line 72: hi! link Keyword^I^IStatement
line 73: SynLink Exception^IStatement
line 73: hi! link Exception^IStatement
line 74: SynLink Include^I^IPreProc
line 74: hi! link Include^I^IPreProc
line 75: SynLink Define^I^IPreProc
line 75: hi! link Define^I^IPreProc
line 76: SynLink Macro^I^IPreProc
line 76: hi! link Macro^I^IPreProc
line 77: SynLink PreCondit^IPreProc
line 77: hi! link PreCondit^IPreProc
line 78: SynLink StorageClass^IType
line 78: hi! link StorageClass^IType
line 79: SynLink Structure^IType
line 79: hi! link Structure^IType
line 80: SynLink Typedef^I^IType
line 80: hi! link Typedef^I^IType
line 81: SynLink Tag^I^ISpecial
line 81: hi! link Tag^I^ISpecial
line 82: SynLink SpecialChar^ISpecial
line 82: hi! link SpecialChar^ISpecial
line 83: SynLink Delimiter^ISpecial
line 83: hi! link Delimiter^ISpecial
line 84: SynLink SpecialComment^ISpecial
line 84: hi! link SpecialComment^ISpecial
line 85: SynLink Debug^I^ISpecial
line 85: hi! link Debug^I^ISpecial
line 86: 
line 87: delcommand SynColor
line 88: delcommand SynLink
finished sourcing C:\Program Files\Vim\vim90\syntax\syncolor.vim
continuing in C:\Users\chris\vimfiles\colors\abbott.vim
Searching for "C:\Users\chris/vimfiles/after\syntax/syncolor.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\syntax/syncolor.vim"
line 191: endif
line 192: 
line 193: " Declare the name of this color scheme.
line 194: let g:colors_name = 'abbott'
line 195: 
line 196: " Set default foreground and background colors.
line 197: call s:H('Normal', {'fg': s:pastel_chartreuse, 'bg': s:bistre})
calling <SNR>9_H('Normal', {'bg': {'term16': '0', 'rgb': '#231c14...', 'rgb': '#d8ff84', 'term256': '192'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '7', 'rgb': '#d8ff84', 'term256': '192'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '192'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Normal term=NONE ctermfg= 192 ctermbg=234 ctermul=NONE cterm=NONE guifg=#d8ff84 guibg=#231c14 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 198: 
line 199: " Set up highlights for basic syntax groups.
line 200: call s:H('Comment', {'fg': s:marigold, 'attrs': ['italic']})
calling <SNR>9_H('Comment', {'fg': {'term16': '3', 'rgb': '#fbb32f', 'term256': '214'}, 'attrs': ['italic']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Comment term=NONE ctermfg= 214 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbb32f guibg=NONE guisp=NONE gui=italic
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 201: call s:H('Constant', {'fg': s:cinnabar})
calling <SNR>9_H('Constant', {'fg': {'term16': '9', 'rgb': '#f63f05', 'term256': '202'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '9', 'rgb': '#f63f05', 'term256': '202'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '202'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Constant term=NONE ctermfg= 202 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#f63f05 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 202: call s:H('String', {'fg': s:lavender})
calling <SNR>9_H('String', {'fg': {'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight String term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#e6a2f3 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 203: call s:H('Character', {'fg': s:lavender})
calling <SNR>9_H('Character', {'fg': {'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Character term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#e6a2f3 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 204: call s:H('Identifier', {'fg': s:periwinkle_blue})
calling <SNR>9_H('Identifier', {'fg': {'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Identifier term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#8ccdf0 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 205: call s:H('Function', {'fg': s:cornflower_blue})
calling <SNR>9_H('Function', {'fg': {'term16': '4', 'rgb': '#3f91f1', 'term256': '33'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Function term=NONE ctermfg= 33 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#3f91f1 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 206: call s:H('Statement', {'fg': s:crimson, 'attrs': ['bold']})
calling <SNR>9_H('Statement', {'fg': {'term16': '1', 'rgb': '#d80450', 'term256': '161'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Statement term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=bold guifg=#d80450 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 207: call s:H('Operator', {'attrs': ['bold']})
calling <SNR>9_H('Operator', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Operator term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 208: call s:H('PreProc', {'fg': s:french_pink})
calling <SNR>9_H('PreProc', {'fg': {'term16': '5', 'rgb': '#ec6c99', 'term256': '204'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PreProc term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#ec6c99 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 209: call s:H('Type', {'fg': s:forest_green})
calling <SNR>9_H('Type', {'fg': {'term16': '2', 'rgb': '#24a507', 'term256': '34'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '2', 'rgb': '#24a507', 'term256': '34'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '34'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Type term=NONE ctermfg= 34 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#24a507 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 210: call s:H('Special', {'fg': s:vanilla_cream})
calling <SNR>9_H('Special', {'fg': {'term16': '15', 'rgb': '#fef3b4', 'term256': '229'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Special term=NONE ctermfg= 229 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fef3b4 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 211: call s:H('Tag', {'fg': s:lavender, 'attrs': ['underline']})
calling <SNR>9_H('Tag', {'fg': {'term16': '13', 'rgb': '#e6a2f...rm256': '219'}, 'attrs': ['underline']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Tag term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=underline guifg=#e6a2f3 guibg=NONE guisp=NONE gui=underline
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 212: call s:H('Underlined', {'fg': s:lavender, 'attrs': ['underline']})
calling <SNR>9_H('Underlined', {'fg': {'term16': '13', 'rgb': '#e6a2f...rm256': '219'}, 'attrs': ['underline']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '13', 'rgb': '#e6a2f3', 'term256': '219'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '219'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Underlined term=NONE ctermfg= 219 ctermbg=NONE ctermul=NONE cterm=underline guifg=#e6a2f3 guibg=NONE guisp=NONE gui=underline
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 213: call s:H('Ignore', {'fg': s:cocoa})
calling <SNR>9_H('Ignore', {'fg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Ignore term=NONE ctermfg= 241 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#745d42 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 214: call s:H('Error', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('Error', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Error term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 215: call s:H('Todo', {'fg': s:bistre, 'bg': s:marigold})
calling <SNR>9_H('Todo', {'bg': {'term16': '3', 'rgb': '#fbb32f...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Todo term=NONE ctermfg= 234 ctermbg=214 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#fbb32f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 216: 
line 217: " Set up highlights for various UI elements.
line 218: call s:H('ErrorMsg', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('ErrorMsg', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ErrorMsg term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 219: call s:H('FoldColumn', {'fg': s:marigold})
calling <SNR>9_H('FoldColumn', {'fg': {'term16': '3', 'rgb': '#fbb32f', 'term256': '214'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '3', 'rgb': '#fbb32f', 'term256': '214'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '214'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight FoldColumn term=NONE ctermfg= 214 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbb32f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 220: call s:H('Folded', {'fg': s:cinnabar})
calling <SNR>9_H('Folded', {'fg': {'term16': '9', 'rgb': '#f63f05', 'term256': '202'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '9', 'rgb': '#f63f05', 'term256': '202'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '202'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Folded term=NONE ctermfg= 202 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#f63f05 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 221: call s:H('LineNr', {'fg': s:lemon_meringue})
calling <SNR>9_H('LineNr', {'fg': {'term16': '11', 'rgb': '#fbec5d', 'term256': '227'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '11', 'rgb': '#fbec5d', 'term256': '227'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '227'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight LineNr term=NONE ctermfg= 227 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#fbec5d guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 222: call s:H('ModeMsg', {'attrs': ['bold']})
calling <SNR>9_H('ModeMsg', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ModeMsg term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 223: call s:H('MoreMsg', {'fg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('MoreMsg', {'fg': {'term16': '4', 'rgb': '#3f91f1', 'term256': '33'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight MoreMsg term=NONE ctermfg= 33 ctermbg=NONE ctermul=NONE cterm=bold guifg=#3f91f1 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 224: call s:H('Pmenu', {'fg': s:vanilla_cream, 'bg': s:cocoa})
calling <SNR>9_H('Pmenu', {'bg': {'term16': '8', 'rgb': '#745d42...', 'rgb': '#fef3b4', 'term256': '229'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Pmenu term=NONE ctermfg= 229 ctermbg=241 ctermul=NONE cterm=NONE guifg=#fef3b4 guibg=#745d42 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 225: call s:H('PmenuSel', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('PmenuSel', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuSel term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 226: call s:H('PmenuSbar', {'bg': s:cocoa})
calling <SNR>9_H('PmenuSbar', {'bg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuSbar term=NONE ctermfg= NONE ctermbg=241 ctermul=NONE cterm=NONE guifg=NONE guibg=#745d42 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 227: call s:H('PmenuThumb', {'bg': s:bistre})
calling <SNR>9_H('PmenuThumb', {'bg': {'term16': '0', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight PmenuThumb term=NONE ctermfg= NONE ctermbg=234 ctermul=NONE cterm=NONE guifg=NONE guibg=#231c14 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 228: call s:H('Question', {'fg': s:french_pink, 'attrs': ['bold']})
calling <SNR>9_H('Question', {'fg': {'term16': '5', 'rgb': '#ec6c99', 'term256': '204'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Question term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=bold guifg=#ec6c99 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 229: call s:H('QuickFixLine', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('QuickFixLine', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight QuickFixLine term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 231: call s:H('SignColumn', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('SignColumn', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SignColumn term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 232: call s:H('StatusLine', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('StatusLine', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLine term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 234: call s:H('StatusLineNC', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('StatusLineNC', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineNC term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 235: call s:H('StatusLineTerm', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('StatusLineTerm', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineTerm term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 237: call s:H('StatusLineTermNC', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('StatusLineTermNC', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight StatusLineTermNC term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 238: call s:H('TabLine', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('TabLine', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLine term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 239: call s:H('TabLineFill', {'bg': s:zomp})
calling <SNR>9_H('TabLineFill', {'bg': {'term16': '6', 'rgb': '#39a78d', 'term256': '36'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLineFill term=NONE ctermfg= NONE ctermbg=36 ctermul=NONE cterm=NONE guifg=NONE guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 240: call s:H('TabLineSel', {'fg': s:bistre, 'bg': s:cornflower_blue, 'attrs': ['bold']})
calling <SNR>9_H('TabLineSel', {'bg': {'term16': '4', 'rgb': '#3f91f1..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '4', 'rgb': '#3f91f1', 'term256': '33'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '33'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight TabLineSel term=NONE ctermfg= 234 ctermbg=33 ctermul=NONE cterm=bold guifg=#231c14 guibg=#3f91f1 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 242: call s:H('Title', {'fg': s:crimson, 'attrs': ['bold']})
calling <SNR>9_H('Title', {'fg': {'term16': '1', 'rgb': '#d80450', 'term256': '161'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Title term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=bold guifg=#d80450 guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 243: call s:H('WarningMsg', {'fg': s:bistre, 'bg': s:french_pink})
calling <SNR>9_H('WarningMsg', {'bg': {'term16': '5', 'rgb': '#ec6c99...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight WarningMsg term=NONE ctermfg= 234 ctermbg=204 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#ec6c99 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 244: call s:H('WildMenu', {'fg': s:bistre, 'bg': s:vanilla_cream, 'attrs': ['bold']})
calling <SNR>9_H('WildMenu', {'bg': {'term16': '15', 'rgb': '#fef3b..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight WildMenu term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=bold guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 245: call s:H('VertSplit', {'fg': s:bistre, 'bg': s:zomp})
calling <SNR>9_H('VertSplit', {'bg': {'term16': '6', 'rgb': '#39a78d...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '6', 'rgb': '#39a78d', 'term256': '36'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '36'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight VertSplit term=NONE ctermfg= 234 ctermbg=36 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#39a78d guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 246: 
line 247: " Use an eye-catching shade of green for the blinking cursor.
line 248: call s:H('Cursor', {'fg': s:bistre, 'bg': s:chartreuse})
calling <SNR>9_H('Cursor', {'bg': {'term16': '10', 'rgb': '#a0ea0...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '10', 'rgb': '#a0ea00', 'term256': '154'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '154'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Cursor term=NONE ctermfg= 234 ctermbg=154 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#a0ea00 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 249: call s:H('CursorIM', {'fg': s:bistre, 'bg': s:seafoam_green})
calling <SNR>9_H('CursorIM', {'bg': {'term16': '14', 'rgb': '#00ff7...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorIM term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#00ff7f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 250: 
line 251: " Bold the current line and column; highlight the current line number.
line 252: call s:H('CursorLine', {'bg': s:chocolate})
calling <SNR>9_H('CursorLine', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorLine term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 253: call s:H('CursorLineNr', {'bg': s:chocolate, 'attrs': ['bold']})
calling <SNR>9_H('CursorLineNr', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorLineNr term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=bold guifg=NONE guibg=#3c3022 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 254: call s:H('CursorColumn', {'bg': s:chocolate})
calling <SNR>9_H('CursorColumn', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight CursorColumn term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 255: 
line 256: " Lighten the background of the right margin.
line 257: call s:H('ColorColumn', {'bg': s:chocolate})
calling <SNR>9_H('ColorColumn', {'bg': {'term16': '8', 'rgb': '#3c3022', 'term256': '236'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#3c3022', 'term256': '236'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '236'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ColorColumn term=NONE ctermfg= NONE ctermbg=236 ctermul=NONE cterm=NONE guifg=NONE guibg=#3c3022 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 258: 
line 259: " Highlight matched delimiters in a way that's clearly distinguishable from
line 260: " unmatched delimiter/statement/preprocessor highlighting.
line 261: call s:H('MatchParen', {'fg': s:bistre, 'bg': s:cocoa, 'attrs': ['bold']})
calling <SNR>9_H('MatchParen', {'bg': {'term16': '8', 'rgb': '#745d42..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight MatchParen term=NONE ctermfg= 234 ctermbg=241 ctermul=NONE cterm=bold guifg=#231c14 guibg=#745d42 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 262: 
line 263: " Set up highlights for imaginary '~' and '@' characters, and for special keys.
line 264: call s:H('EndOfBuffer', {'fg': s:cocoa})
calling <SNR>9_H('EndOfBuffer', {'fg': {'term16': '8', 'rgb': '#745d42', 'term256': '241'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#745d42', 'term256': '241'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '241'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight EndOfBuffer term=NONE ctermfg= 241 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#745d42 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 265: call s:H('NonText', {'fg': s:seafoam_green})
calling <SNR>9_H('NonText', {'fg': {'term16': '14', 'rgb': '#00ff7f', 'term256': '48'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight NonText term=NONE ctermfg= 48 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#00ff7f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 266: call s:H('SpecialKey', {'fg': s:seafoam_green})
calling <SNR>9_H('SpecialKey', {'fg': {'term16': '14', 'rgb': '#00ff7f', 'term256': '48'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpecialKey term=NONE ctermfg= 48 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#00ff7f guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 267: 
line 268: " Set a dark green background for visual mode.
line 269: call s:H('Visual', {'bg': s:dark_olive})
calling <SNR>9_H('Visual', {'bg': {'term16': '8', 'rgb': '#273900', 'term256': '238'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#273900', 'term256': '238'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '238'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Visual term=NONE ctermfg= NONE ctermbg=238 ctermul=NONE cterm=NONE guifg=NONE guibg=#273900 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 270: call s:H('VisualNOS', {'bg': s:dark_olive})
calling <SNR>9_H('VisualNOS', {'bg': {'term16': '8', 'rgb': '#273900', 'term256': '238'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '8', 'rgb': '#273900', 'term256': '238'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '238'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight VisualNOS term=NONE ctermfg= NONE ctermbg=238 ctermul=NONE cterm=NONE guifg=NONE guibg=#273900 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 271: 
line 272: " Use cold highlights for incremental searching and warm highlights for final
line 273: " search results.
line 274: call s:H('IncSearch', {'fg': s:bistre, 'bg': s:seafoam_green})
calling <SNR>9_H('IncSearch', {'bg': {'term16': '14', 'rgb': '#00ff7...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight IncSearch term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#00ff7f guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 275: call s:H('Search', {'fg': s:bistre, 'bg': s:vanilla_cream})
calling <SNR>9_H('Search', {'bg': {'term16': '15', 'rgb': '#fef3b...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '15', 'rgb': '#fef3b4', 'term256': '229'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '229'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Search term=NONE ctermfg= 234 ctermbg=229 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#fef3b4 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 276: 
line 277: " Set up spell-checking in an unobtrusive way.
line 278: call s:H('SpellBad', {'sp': s:crimson, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellBad', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#d80450', 'term256': '161'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellBad term=NONE ctermfg= 161 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#d80450 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 279: call s:H('SpellCap', {'sp': s:periwinkle_blue, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellCap', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellCap term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#8ccdf0 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 280: call s:H('SpellLocal', {'sp': s:lemon_meringue, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellLocal', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#fbec5d', 'term256': '227'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '11', 'rgb': '#fbec5d', 'term256': '227'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '227'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellLocal term=NONE ctermfg= 227 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#fbec5d gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 281: call s:H('SpellRare', {'sp': s:french_pink, 'attrs': ['undercurl']})
calling <SNR>9_H('SpellRare', {'attrs': ['undercurl'], 'sp': {'term1...', 'rgb': '#ec6c99', 'term256': '204'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight SpellRare term=NONE ctermfg= 204 ctermbg=NONE ctermul=NONE cterm=underline guifg=NONE guibg=NONE guisp=#ec6c99 gui=undercurl
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 282: 
line 283: " Don't do anything special for concealed tokens.
line 284: call s:H('Conceal', {})
calling <SNR>9_H('Conceal', {})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Conceal term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=NONE guifg=NONE guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 285: 
line 286: " Set highlights for directory listings.
line 287: call s:H('Directory', {'fg': s:periwinkle_blue})
calling <SNR>9_H('Directory', {'fg': {'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '12', 'rgb': '#8ccdf0', 'term256': '117'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '117'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight Directory term=NONE ctermfg= 117 ctermbg=NONE ctermul=NONE cterm=NONE guifg=#8ccdf0 guibg=NONE guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 288: 
line 289: " Use readable diff highlights. :)
line 290: call s:H('DiffAdd', {'fg': s:bistre, 'bg': s:chartreuse, 'attrs': ['bold']})
calling <SNR>9_H('DiffAdd', {'bg': {'term16': '10', 'rgb': '#a0ea0..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '10', 'rgb': '#a0ea00', 'term256': '154'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '154'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffAdd term=NONE ctermfg= 234 ctermbg=154 ctermul=NONE cterm=bold guifg=#231c14 guibg=#a0ea00 guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 291: call s:H('DiffChange', {'fg': s:bistre, 'bg': s:french_pink})
calling <SNR>9_H('DiffChange', {'bg': {'term16': '5', 'rgb': '#ec6c99...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '5', 'rgb': '#ec6c99', 'term256': '204'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '204'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffChange term=NONE ctermfg= 234 ctermbg=204 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#ec6c99 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 292: call s:H('DiffDelete', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('DiffDelete', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffDelete term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 293: call s:H('DiffText', {'fg': s:bistre, 'bg': s:seafoam_green, 'attrs': ['bold']})
calling <SNR>9_H('DiffText', {'bg': {'term16': '14', 'rgb': '#00ff7..., 'term256': '234'}, 'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '14', 'rgb': '#00ff7f', 'term256': '48'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '48'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight DiffText term=NONE ctermfg= 234 ctermbg=48 ctermul=NONE cterm=bold guifg=#231c14 guibg=#00ff7f guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 294: 
line 295: " Set up custom highlights for better-whitespace.vim.
line 296: call s:H('ExtraWhitespace', {'fg': s:bistre, 'bg': s:crimson})
calling <SNR>9_H('ExtraWhitespace', {'bg': {'term16': '1', 'rgb': '#d80450...', 'rgb': '#231c14', 'term256': '234'}})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_TermColor({'term16': '0', 'rgb': '#231c14', 'term256': '234'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '234'

continuing in <SNR>9_H

calling <SNR>9_TermColor({'term16': '1', 'rgb': '#d80450', 'term256': '161'})

line 1:   return &t_Co >= 256 && !g:abbott_force_16_colors ? a:color.term256 : a:color.term16
<SNR>9_TermColor returning '161'

continuing in <SNR>9_H

calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight ExtraWhitespace term=NONE ctermfg= 234 ctermbg=161 ctermul=NONE cterm=NONE guifg=#231c14 guibg=#d80450 guisp=NONE gui=NONE
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 297: 
line 298: " Set up custom highlights for diff.vim
line 299: highlight link diffAdded DiffAdd
line 300: highlight link diffRemoved DiffDelete
line 301: 
line 302: " Set up custom highlights for gitcommit.vim.
line 303: call s:H('gitcommitSummary', {'attrs': ['bold']})
calling <SNR>9_H('gitcommitSummary', {'attrs': ['bold']})

line 1:   " Evaluate terminal/GUI attributes for the highlight, possibly filtering or
line 2:   " replacing attributes the user may not wish to use in their terminal.
line 3:   let l:attrs = has_key(a:style, 'attrs') ? a:style.attrs : []
line 4:   let l:term_attrs = copy(l:attrs)
line 5: 
line 6:   if !g:abbott_term_use_italics
line 7:     call filter(l:term_attrs, 'v:val !=# "italic"')
line 8:   endif
line 9: 
line 10:   if !g:abbott_term_use_undercurl
line 11:     call map(l:term_attrs, 'v:val ==# "undercurl" ? "underline" : v:val')
line 12:   endif
line 13: 
line 14:   " Set up terminal foreground and underline colors. If the current version of
line 15:   " Vim can't set underline color in the terminal or if the user does not wish
line 16:   " us to use that option (e.g., because their terminal doesn't support it),
line 17:   " then we *replace* the foreground color with the underline ("special") color.
line 18:   if has_key(a:style, 'sp')
line 19:     if s:HasTermUnderlineColor() && g:abbott_term_set_underline_color
line 20:       let l:term_sp = a:style.sp
line 21:     else
line 22:       let l:term_fg = a:style.sp
line 23:     endif
line 24:   endif
line 25: 
line 26:   if has_key(a:style, 'fg') && !exists('l:term_fg')
line 27:     let l:term_fg = a:style.fg
line 28:   endif
line 29: 
line 30:   " Set the highlight. We explicitly set missing parameters to 'NONE' because
line 31:   " otherwise defaults can conflict with things we explicitly set (such as the
line 32:   " default background on SpellBad vs. our custom foreground for that group).
line 33:   execute 'highlight' a:group 'term=NONE' 'ctermfg=' (exists('l:term_fg') ? s:TermColor(l:term_fg) : 'NONE') 'ctermbg=' . (has_key(a:style, 'bg') ? s:TermColor(a:style.bg) : 'NONE') (s:HasTermUnderlineColor() ? 'ctermul=' . (exists('l:term_sp') ? s:TermColor(l:term_sp) : 'NONE') : '') 'cterm=' . (!empty(l:term_attrs) ? join(l:term_attrs, ',') : 'NONE') 'guifg=' . (has_key(a:style, 'fg') ? a:style.fg.rgb : 'NONE') 'guibg=' . (has_key(a:style, 'bg') ? a:style.bg.rgb : 'NONE') 'guisp=' . (has_key(a:style, 'sp') ? a:style.sp.rgb : 'NONE') 'gui=' . (!empty(l:attrs) ? join(l:attrs, ',') : 'NONE')
calling <SNR>9_HasTermUnderlineColor()

line 1:   return has('patch-8.2.863')
<SNR>9_HasTermUnderlineColor returning #1

continuing in <SNR>9_H

line 33: highlight gitcommitSummary term=NONE ctermfg= NONE ctermbg=NONE ctermul=NONE cterm=bold guifg=NONE guibg=NONE guisp=NONE gui=bold
<SNR>9_H returning #0

continuing in C:\Users\chris\vimfiles\colors\abbott.vim

line 304: highlight link gitcommitOverflow Error
line 305: 
line 306: " Set up custom highlights for tex.vim.
line 307: highlight link texStatement PreProc
line 308: 
line 309: " Set up the embedded terminal.
line 310: if g:abbott_set_term_ansi_colors
line 311:   let g:terminal_ansi_colors = [ s:bistre.rgb, s:crimson.rgb, s:forest_green.rgb, s:marigold.rgb, s:cornflower_blue.rgb, s:french_pink.rgb, s:zomp.rgb, s:pastel_chartreuse.rgb, s:cocoa.rgb, s:cinnabar.rgb, s:chartreuse.rgb, s:lemon_meringue.rgb, s:periwinkle_blue.rgb, s:lavender.rgb, s:seafoam_green.rgb, s:vanilla_cream.rgb, ]
line 329: endif
finished sourcing C:\Users\chris\vimfiles\colors\abbott.vim
continuing in C:\Users\chris\_vimrc
line 14: set showmatch
line 15: set ft=nasm
Executing FileType Autocommands for "*"
autocommand 0verbose exe "set syntax=" . expand("<amatch>")

Executing: 0verbose exe "set syntax=" . expand("<amatch>")
line 16: set shortmess=at
line 17: set cmdheight=2
line 18: 
finished sourcing $HOME\_vimrc
Searching for "pack/*/start/*" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim\vim90\pack/*/start/*"
Searching for "C:\Users\chris/vimfiles/after\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles/after\pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\plugin/**/*.vim"
Searching for "C:\Program Files\Vim/vimfiles\plugin/**/*.vim"
Searching for "C:\Program Files\Vim\vim90\plugin/**/*.vim"
sourcing "C:\Program Files\Vim\vim90\plugin\getscriptPlugin.vim"
line 1: " ---------------------------------------------------------------------
line 2: " getscriptPlugin.vim
line 3: "  Author:^ICharles E. Campbell
line 4: "  Date:^INov 29, 2013
line 5: "  Installing:^I:help glvs-install
line 6: "  Usage:^I:help glvs
line 7: "
line 8: " GetLatestVimScripts: 642 1 :AutoInstall: getscript.vim
line 9: "
line 10: " (Rom 15:11 WEB) Again, "Praise the Lord, all you Gentiles!  Let
line 11: " all the peoples praise Him."
line 12: " ---------------------------------------------------------------------
line 13: " Initialization:^I{{{1
line 14: " if you're sourcing this file, surely you can't be
line 15: " expecting vim to be in its vi-compatible mode
line 16: if exists("g:loaded_getscriptPlugin")
line 17:  finish
line 18: endif
line 19: if &cp
line 20:  if &verbose
line 21:   echo "GetLatestVimScripts is not vi-compatible; not loaded (you need to set nocp)"
line 22:  endif
line 23:  finish
line 24: endif
line 25: let g:loaded_getscriptPlugin = "v36"
line 26: let s:keepcpo                = &cpo
line 27: set cpo&vim
line 28: 
line 29: " ---------------------------------------------------------------------
line 30: "  Public Interface: {{{1
line 31: com!        -nargs=0 GetLatestVimScripts call getscript#GetLatestVimScripts()
line 32: com!        -nargs=0 GetScripts          call getscript#GetLatestVimScripts()
line 33: sil! com    -nargs=0 GLVS                call getscript#GetLatestVimScripts()
line 34: 
line 35: " ---------------------------------------------------------------------
line 36: " Restore Options: {{{1
line 37: let &cpo= s:keepcpo
line 38: unlet s:keepcpo
line 39: 
line 40: " ---------------------------------------------------------------------
line 41: " vim: ts=8 sts=2 fdm=marker nowrap
finished sourcing C:\Program Files\Vim\vim90\plugin\getscriptPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\gzip.vim"
line 1: " Vim plugin for editing compressed files.
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of compressed files
line 10: if exists("loaded_gzip") || &cp || exists("#BufReadPre#*.gz")
line 11:   finish
line 12: endif
line 13: let loaded_gzip = 1
line 14: 
line 15: augroup gzip
line 16:   " Remove all gzip autocommands
line 17:   au!
line 18: 
line 19:   " Enable editing of gzipped files.
line 20:   " The functions are defined in autoload/gzip.vim.
line 21:   "
line 22:   " Set binary mode before reading the file.
line 23:   " Use "gzip -d", gunzip isn't always available.
line 24:   autocmd BufReadPre,FileReadPre^I*.gz,*.bz2,*.Z,*.lzma,*.xz,*.lz,*.zst,*.br,*.lzo setlocal bin
line 25:   autocmd BufReadPost,FileReadPost^I*.gz  call gzip#read("gzip -dn")
line 26:   autocmd BufReadPost,FileReadPost^I*.bz2 call gzip#read("bzip2 -d")
line 27:   autocmd BufReadPost,FileReadPost^I*.Z   call gzip#read("uncompress")
line 28:   autocmd BufReadPost,FileReadPost^I*.lzma call gzip#read("lzma -d")
line 29:   autocmd BufReadPost,FileReadPost^I*.xz  call gzip#read("xz -d")
line 30:   autocmd BufReadPost,FileReadPost^I*.lz  call gzip#read("lzip -d")
line 31:   autocmd BufReadPost,FileReadPost^I*.zst call gzip#read("zstd -d --rm")
line 32:   autocmd BufReadPost,FileReadPost^I*.br call gzip#read("brotli -d --rm")
line 33:   autocmd BufReadPost,FileReadPost^I*.lzo call gzip#read("lzop -d -U")
line 34:   autocmd BufWritePost,FileWritePost^I*.gz  call gzip#write("gzip")
line 35:   autocmd BufWritePost,FileWritePost^I*.bz2 call gzip#write("bzip2")
line 36:   autocmd BufWritePost,FileWritePost^I*.Z   call gzip#write("compress -f")
line 37:   autocmd BufWritePost,FileWritePost^I*.lzma call gzip#write("lzma -z")
line 38:   autocmd BufWritePost,FileWritePost^I*.xz  call gzip#write("xz -z")
line 39:   autocmd BufWritePost,FileWritePost^I*.lz  call gzip#write("lzip")
line 40:   autocmd BufWritePost,FileWritePost^I*.zst  call gzip#write("zstd --rm")
line 41:   autocmd BufWritePost,FileWritePost^I*.br  call gzip#write("brotli --rm")
line 42:   autocmd BufWritePost,FileWritePost^I*.lzo  call gzip#write("lzop -U")
line 43:   autocmd FileAppendPre^I^I^I*.gz  call gzip#appre("gzip -dn")
line 44:   autocmd FileAppendPre^I^I^I*.bz2 call gzip#appre("bzip2 -d")
line 45:   autocmd FileAppendPre^I^I^I*.Z   call gzip#appre("uncompress")
line 46:   autocmd FileAppendPre^I^I^I*.lzma call gzip#appre("lzma -d")
line 47:   autocmd FileAppendPre^I^I^I*.xz   call gzip#appre("xz -d")
line 48:   autocmd FileAppendPre^I^I^I*.lz   call gzip#appre("lzip -d")
line 49:   autocmd FileAppendPre^I^I^I*.zst call gzip#appre("zstd -d --rm")
line 50:   autocmd FileAppendPre^I^I^I*.br call gzip#appre("brotli -d --rm")
line 51:   autocmd FileAppendPre^I^I^I*.lzo call gzip#appre("lzop -d -U")
line 52:   autocmd FileAppendPost^I^I*.gz  call gzip#write("gzip")
line 53:   autocmd FileAppendPost^I^I*.bz2 call gzip#write("bzip2")
line 54:   autocmd FileAppendPost^I^I*.Z   call gzip#write("compress -f")
line 55:   autocmd FileAppendPost^I^I*.lzma call gzip#write("lzma -z")
line 56:   autocmd FileAppendPost^I^I*.xz call gzip#write("xz -z")
line 57:   autocmd FileAppendPost^I^I*.lz call gzip#write("lzip")
line 58:   autocmd FileAppendPost^I^I*.zst call gzip#write("zstd --rm")
line 59:   autocmd FileAppendPost^I^I*.br call gzip#write("brotli --rm")
line 60:   autocmd FileAppendPost^I^I*.lzo call gzip#write("lzop -U")
line 61: augroup END
finished sourcing C:\Program Files\Vim\vim90\plugin\gzip.vim
sourcing "C:\Program Files\Vim\vim90\plugin\logiPat.vim"
line 1: " LogiPat: Boolean logical pattern matcher
line 2: "   Author:  Charles E. Campbell
line 3: "   Date:    Apr 04, 2016
line 4: "   Version: 4
line 5: "   Purpose: to do Boolean-logic based regular expression pattern matching
line 6: " Copyright:    Copyright (C) 1999-2011 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like most anything else that's free,
line 10: "               LogiPat.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: "   Usage: {{{1
line 17: "       :LogiPat ...
line 18: "
line 19: "         Boolean logic supported:
line 20: "            () grouping operators
line 21: "            !  not the following pattern
line 22: "            |  logical or
line 23: "            &  logical and
line 24: "            "..pattern.."
line 25: "^IExample: {{{1
line 26: "^I^I:LogiPat !("january"|"february")
line 27: "^I^I  would match all strings not containing the strings january
line 28: "^I^I  or february
line 29: "^IGetLatestVimScripts: 1290 1 :AutoInstall: LogiPat.vim
line 30: "
line 31: "  Behold, you will conceive in your womb, and bring forth a son, {{{1
line 32: "  and will call his name Jesus. He will be great, and will be
line 33: "  called the Son of the Most High. The Lord God will give him the
line 34: "  throne of his father, David, and he will reign over the house of
line 35: "  Jacob forever. There will be no end to his kingdom. (Luke 1:31-33 WEB)
line 36: 
line 37: " ---------------------------------------------------------------------
line 38: " Load Once: {{{1
line 39: if &cp || exists("loaded_logiPat")
line 40:  finish
line 41: endif
line 42: let g:loaded_logiPat = "v4"
line 43: let s:keepcpo        = &cpo
line 44: set cpo&vim
line 45: "DechoRemOn
line 46: 
line 47: " ---------------------------------------------------------------------
line 48: " Public Interface: {{{1
line 49: com!     -nargs=* LogiPat^I^Icall   LogiPat(<q-args>,1)
line 50: sil! com -nargs=* LP^I^I^Icall   LogiPat(<q-args>,1)
line 51: sil! com -nargs=* LPR^I^I^Icall   LogiPat(<q-args>,1,"r")
line 52: com!     -nargs=+ LPE^I^I^Iechomsg LogiPat(<q-args>)
line 53: com!     -nargs=+ LogiPatFlags^Ilet  s:LogiPatFlags="<args>"
line 54: sil! com -nargs=+ LPF^I^I^Ilet  s:LogiPatFlags="<args>"
line 55: 
line 56: " =====================================================================
line 57: " Functions: {{{1
line 58: 
line 59: " ---------------------------------------------------------------------
line 60: " LogiPat: this function interprets the boolean-logic pattern {{{2
line 61: fun! LogiPat(pat,...)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:String: Vim6.4 doesn't have string() {{{2
line 149: func! s:String(str)
line 152: 
line 153: " ---------------------------------------------------------------------
line 154: " LP_PatPush: {{{2
line 155: fun! s:LP_PatPush(pat)
line 162: 
line 163: " ---------------------------------------------------------------------
line 164: " LP_PatPop: pop a number/variable from LogiPat's pattern stack {{{2
line 165: fun! s:LP_PatPop(lookup)
line 178: 
line 179: " ---------------------------------------------------------------------
line 180: " LP_OpPush: {{{2
line 181: fun! s:LP_OpPush(op)
line 232: 
line 233: " ---------------------------------------------------------------------
line 234: " LP_Execute: execute operators from opstack using pattern stack {{{2
line 235: fun! s:LP_Execute(preclvl)
line 265: 
line 266: " ---------------------------------------------------------------------
line 267: " LP_Not: writes a logical-not for a pattern {{{2
line 268: fun! s:LP_Not(pat)
line 279: 
line 280: " ---------------------------------------------------------------------
line 281: " LP_Or: writes a logical-or branch using two patterns {{{2
line 282: fun! s:LP_Or(pat1,pat2)
line 288: 
line 289: " ---------------------------------------------------------------------
line 290: " LP_And: writes a logical-and concat using two patterns {{{2
line 291: fun! s:LP_And(pat1,pat2)
line 297: 
line 298: " ---------------------------------------------------------------------
line 299: " StackLook: {{{2
line 300: fun! s:StackLook(description)
line 334: 
line 335: " ---------------------------------------------------------------------
line 336: "  Cleanup And Modeline: {{{1
line 337: let &cpo= s:keepcpo
line 338: unlet s:keepcpo
line 339: " vim: ts=4 fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\logiPat.vim
sourcing "C:\Program Files\Vim\vim90\plugin\manpager.vim"
line 1: " Vim plugin for using Vim as manpager.
line 2: " Maintainer: Enno Nagel <ennonagel+vim@gmail.com>
line 3: " Last Change: 2022 Oct 17
line 4: 
line 5: if exists('g:loaded_manpager_plugin')
line 6:   finish
line 7: endif
line 8: let g:loaded_manpager_plugin = 1
line 9: 
line 10: " Set up the current buffer (likely read from stdin) as a manpage
line 11: command MANPAGER call s:ManPager()
line 12: 
line 13: function s:ManPager()
finished sourcing C:\Program Files\Vim\vim90\plugin\manpager.vim
sourcing "C:\Program Files\Vim\vim90\plugin\matchparen.vim"
line 1: " Vim plugin for showing matching parens
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Oct 20
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded (or disabled)
line 8: " - when 'compatible' is set
line 9: if exists("g:loaded_matchparen") || &cp
line 10:   finish
line 11: endif
line 12: let g:loaded_matchparen = 1
line 13: 
line 14: if !exists("g:matchparen_timeout")
line 15:   let g:matchparen_timeout = 300
line 16: endif
line 17: if !exists("g:matchparen_insert_timeout")
line 18:   let g:matchparen_insert_timeout = 60
line 19: endif
line 20: 
line 21: let s:has_matchaddpos = exists('*matchaddpos')
line 22: 
line 23: augroup matchparen
line 24:   " Replace all matchparen autocommands
line 25:   autocmd! CursorMoved,CursorMovedI,WinEnter,BufWinEnter,WinScrolled * call s:Highlight_Matching_Pair()
line 26:   autocmd! WinLeave,BufLeave * call s:Remove_Matches()
line 27:   if exists('##TextChanged')
line 28:     autocmd! TextChanged,TextChangedI * call s:Highlight_Matching_Pair()
line 29:     autocmd! TextChangedP * call s:Remove_Matches()
line 30:   endif
line 31: augroup END
line 32: 
line 33: " Skip the rest if it was already done.
line 34: if exists("*s:Highlight_Matching_Pair")
line 35:   finish
line 36: endif
line 37: 
line 38: let s:cpo_save = &cpo
line 39: set cpo-=C
line 40: 
line 41: " The function that is invoked (very often) to define a ":match" highlighting
line 42: " for any matching paren.
line 43: func s:Highlight_Matching_Pair()
line 204: 
line 205: func s:Remove_Matches()
line 213: 
line 214: " Define commands that will disable and enable the plugin.
line 215: command DoMatchParen call s:DoMatchParen()
line 216: command NoMatchParen call s:NoMatchParen()
line 217: 
line 218: func s:NoMatchParen()
line 225: 
line 226: func s:DoMatchParen()
line 232: 
line 233: let &cpo = s:cpo_save
line 234: unlet s:cpo_save
finished sourcing C:\Program Files\Vim\vim90\plugin\matchparen.vim
sourcing "C:\Program Files\Vim\vim90\plugin\netrwPlugin.vim"
line 1: " netrwPlugin.vim: Handles file transfer and remote directory listing across a network
line 2: "            PLUGIN SECTION
line 3: " Date:^I^IFeb 09, 2021
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " GetLatestVimScripts: 1075 1 :AutoInstall: netrw.vim
line 6: " Copyright:    Copyright (C) 1999-2021 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               netrw.vim, netrwPlugin.vim, and netrwSettings.vim are provided
line 11: "               *as is* and comes with no warranty of any kind, either
line 12: "               expressed or implied. By using this plugin, you agree that
line 13: "               in no event will the copyright holder be liable for any damages
line 14: "               resulting from the use of this software.
line 15: "
line 16: "  But be doers of the Word, and not only hearers, deluding your own selves {{{1
line 17: "  (James 1:22 RSV)
line 18: " =-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-=-
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_netrwPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_netrwPlugin = "v173"
line 24: let s:keepcpo = &cpo
line 25: set cpo&vim
line 26: "DechoRemOn
line 27: 
line 28: " ---------------------------------------------------------------------
line 29: " Public Interface: {{{1
line 30: 
line 31: " Local Browsing Autocmds: {{{2
line 32: augroup FileExplorer
line 33:  au!
line 34:  au BufLeave *  if &ft != "netrw"|let w:netrw_prvfile= expand("%:p")|endif
line 35:  au BufEnter *^Isil call s:LocalBrowse(expand("<amatch>"))
line 36:  au VimEnter *^Isil call s:VimEnter(expand("<amatch>"))
line 37:  if has("win32") || has("win95") || has("win64") || has("win16")
line 38:   au BufEnter .* sil call s:LocalBrowse(expand("<amatch>"))
line 39:  endif
line 40: augroup END
line 41: 
line 42: " Network Browsing Reading Writing: {{{2
line 43: augroup Network
line 44:  au!
line 45:  au BufReadCmd   file://*^I^I^I^I^I^I^I^I^I^I^Icall netrw#FileUrlEdit(expand("<amatch>"))
line 46:  au BufReadCmd   ftp://*,rcp://*,scp://*,http://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau BufReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(2,expand("<amatch>"))|exe "sil doau BufReadPost ".fnameescape(expand("<amatch>"))
line 47:  au FileReadCmd  ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe "sil doau FileReadPre ".fnameescape(expand("<amatch>"))|call netrw#Nread(1,expand("<amatch>"))|exe "sil doau FileReadPost ".fnameescape(expand("<amatch>"))
line 48:  au BufWriteCmd  ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau BufWritePre ".fnameescape(expand("<amatch>"))|exe 'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau BufWritePost ".fnameescape(expand("<amatch>"))
line 49:  au FileWriteCmd ftp://*,rcp://*,scp://*,http://*,file://*,dav://*,davs://*,rsync://*,sftp://*^I^I^Iexe "sil doau FileWritePre ".fnameescape(expand("<amatch>"))|exe "'[,']".'Nwrite '.fnameescape(expand("<amatch>"))|exe "sil doau FileWritePost ".fnameescape(expand("<amatch>"))
line 50:  try
line 51:   au SourceCmd   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 52:  catch /^Vim\%((\a\+)\)\=:E216/
line 53:   au SourcePre   ftp://*,rcp://*,scp://*,http://*,file://*,https://*,dav://*,davs://*,rsync://*,sftp://*^Iexe 'Nsource '.fnameescape(expand("<amatch>"))
line 54:  endtry
line 55: augroup END
line 56: 
line 57: " Commands: :Nread, :Nwrite, :NetUserPass {{{2
line 58: com! -count=1 -nargs=*^INread^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetRead(<count>,<f-args>)<bar>call winrestview(s:svpos)
line 59: com! -range=% -nargs=*^INwrite^I^Ilet s:svpos= winsaveview()<bar><line1>,<line2>call netrw#NetWrite(<f-args>)<bar>call winrestview(s:svpos)
line 60: com! -nargs=*^I^INetUserPass^Icall NetUserPass(<f-args>)
line 61: com! -nargs=*^I        Nsource^I^Ilet s:svpos= winsaveview()<bar>call netrw#NetSource(<f-args>)<bar>call winrestview(s:svpos)
line 62: com! -nargs=?^I^INtree^I^Icall netrw#SetTreetop(1,<q-args>)
line 63: 
line 64: " Commands: :Explore, :Sexplore, Hexplore, Vexplore, Lexplore {{{2
line 65: com! -nargs=* -bar -bang -count=0 -complete=dir^IExplore^I^Icall netrw#Explore(<count>,0,0+<bang>0,<q-args>)
line 66: com! -nargs=* -bar -bang -count=0 -complete=dir^ISexplore^Icall netrw#Explore(<count>,1,0+<bang>0,<q-args>)
line 67: com! -nargs=* -bar -bang -count=0 -complete=dir^IHexplore^Icall netrw#Explore(<count>,1,2+<bang>0,<q-args>)
line 68: com! -nargs=* -bar -bang -count=0 -complete=dir^IVexplore^Icall netrw#Explore(<count>,1,4+<bang>0,<q-args>)
line 69: com! -nargs=* -bar       -count=0 -complete=dir^ITexplore^Icall netrw#Explore(<count>,0,6        ,<q-args>)
line 70: com! -nargs=* -bar -bang^I^I^INexplore^Icall netrw#Explore(-1,0,0,<q-args>)
line 71: com! -nargs=* -bar -bang^I^I^IPexplore^Icall netrw#Explore(-2,0,0,<q-args>)
line 72: com! -nargs=* -bar -bang -count=0 -complete=dir Lexplore^Icall netrw#Lexplore(<count>,<bang>0,<q-args>)
line 73: 
line 74: " Commands: NetrwSettings {{{2
line 75: com! -nargs=0^INetrwSettings^Icall netrwSettings#NetrwSettings()
line 76: com! -bang^INetrwClean^Icall netrw#Clean(<bang>0)
line 77: 
line 78: " Maps:
line 79: if !exists("g:netrw_nogx")
line 80:  if maparg('gx','n') == ""
line 81:   if !hasmapto('<Plug>NetrwBrowseX')
line 82:    nmap <unique> gx <Plug>NetrwBrowseX
line 83:   endif
line 84:   nno <silent> <Plug>NetrwBrowseX :call netrw#BrowseX(netrw#GX(),netrw#CheckIfRemote(netrw#GX()))<cr>
line 85:  endif
line 86:  if maparg('gx','x') == ""
line 87:   if !hasmapto('<Plug>NetrwBrowseXVis')
line 88:    xmap <unique> gx <Plug>NetrwBrowseXVis
line 89:   endif
line 90:   xno <silent> <Plug>NetrwBrowseXVis :<c-u>call netrw#BrowseXVis()<cr>
line 91:  endif
line 92: endif
line 93: if exists("g:netrw_usetab") && g:netrw_usetab
line 94:  if maparg('<c-tab>','n') == ""
line 95:   nmap <unique> <c-tab> <Plug>NetrwShrink
line 96:  endif
line 97:  nno <silent> <Plug>NetrwShrink :call netrw#Shrink()<cr>
line 98: endif
line 99: 
line 100: " ---------------------------------------------------------------------
line 101: " LocalBrowse: invokes netrw#LocalBrowseCheck() on directory buffers {{{2
line 102: fun! s:LocalBrowse(dirname)
line 146: 
line 147: " ---------------------------------------------------------------------
line 148: " s:VimEnter: after all vim startup stuff is done, this function is called. {{{2
line 149: "             Its purpose: to look over all windows and run s:LocalBrowse() on
line 150: "             them, which checks if they're directories and will create a directory
line 151: "             listing when appropriate.
line 152: "             It also sets s:vimentered, letting s:LocalBrowse() know that s:VimEnter()
line 153: "             has already been called.
line 154: fun! s:VimEnter(dirname)
line 174: 
line 175: " ---------------------------------------------------------------------
line 176: " NetrwStatusLine: {{{1
line 177: fun! NetrwStatusLine()
line 188: 
line 189: " ------------------------------------------------------------------------
line 190: " NetUserPass: set username and password for subsequent ftp transfer {{{1
line 191: "   Usage:  :call NetUserPass()^I^I^I-- will prompt for userid and password
line 192: "^I    :call NetUserPass("uid")^I^I-- will prompt for password
line 193: "^I    :call NetUserPass("uid","password") -- sets global userid and password
line 194: fun! NetUserPass(...)
line 218: 
line 219: " ------------------------------------------------------------------------
line 220: " Modelines And Restoration: {{{1
line 221: let &cpo= s:keepcpo
line 222: unlet s:keepcpo
line 223: " vim:ts=8 fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\netrwPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\rrhelper.vim"
line 1: " Vim plugin with helper function(s) for --remote-wait
line 2: " Maintainer: Flemming Madsen <fma@cci.dk>
line 3: " Last Change: 2008 May 29
line 4: 
line 5: " Has this already been loaded?
line 6: if exists("loaded_rrhelper") || !has("clientserver")
line 7:   finish
line 8: endif
line 9: let loaded_rrhelper = 1
line 10: 
line 11: " Setup answers for a --remote-wait client who will assume
line 12: " a SetupRemoteReplies() function in the command server
line 13: 
line 14: function SetupRemoteReplies()
line 41: 
line 42: function DoRemoteReply(id, cnt, group, file)
line 47: 
line 48: " vim: set sw=2 sts=2 :
finished sourcing C:\Program Files\Vim\vim90\plugin\rrhelper.vim
sourcing "C:\Program Files\Vim\vim90\plugin\spellfile.vim"
line 1: " Vim plugin for downloading spell files
line 2: " Maintainer:^IThe Vim Project <https://github.com/vim/vim>
line 3: " Last Change:^I2023 Aug 10
line 4: " Former Maintainer:^IBram Moolenaar <Bram@vim.org>
line 5: 
line 6: " Exit quickly when:
line 7: " - this plugin was already loaded
line 8: " - when 'compatible' is set
line 9: " - some autocommands are already taking care of spell files
line 10: if exists("loaded_spellfile_plugin") || &cp || exists("#SpellFileMissing")
line 11:   finish
line 12: endif
line 13: let loaded_spellfile_plugin = 1
line 14: 
line 15: " The function is in the autoload directory.
line 16: autocmd SpellFileMissing * call spellfile#LoadFile(expand('<amatch>'))
finished sourcing C:\Program Files\Vim\vim90\plugin\spellfile.vim
sourcing "C:\Program Files\Vim\vim90\plugin\tarPlugin.vim"
line 1: " tarPlugin.vim -- a Vim plugin for browsing tarfiles
line 2: " Original was copyright (c) 2002, Michael C. Toren <mct@toren.net>
line 3: " Modified by Charles E. Campbell
line 4: " Distributed under the GNU General Public License.
line 5: "
line 6: " Updates are available from <http://michael.toren.net/code/>.  If you
line 7: " find this script useful, or have suggestions for improvements, please
line 8: " let me know.
line 9: " Also look there for further comments and documentation.
line 10: "
line 11: " This part only sets the autocommands.  The functions are in autoload/tar.vim.
line 12: " ---------------------------------------------------------------------
line 13: "  Load Once: {{{1
line 14: if &cp || exists("g:loaded_tarPlugin")
line 15:  finish
line 16: endif
line 17: let g:loaded_tarPlugin = "v32"
line 18: let s:keepcpo          = &cpo
line 19: set cpo&vim
line 20: 
line 21: " ---------------------------------------------------------------------
line 22: "  Public Interface: {{{1
line 23: augroup tar
line 24:   au!
line 25:   au BufReadCmd   tarfile::*^Icall tar#Read(expand("<amatch>"), 1)
line 26:   au FileReadCmd  tarfile::*^Icall tar#Read(expand("<amatch>"), 0)
line 27:   au BufWriteCmd  tarfile::*^Icall tar#Write(expand("<amatch>"))
line 28:   au FileWriteCmd tarfile::*^Icall tar#Write(expand("<amatch>"))
line 29: 
line 30:   if has("unix")
line 31:    au BufReadCmd   tarfile::*/*^Icall tar#Read(expand("<amatch>"), 1)
line 32:    au FileReadCmd  tarfile::*/*^Icall tar#Read(expand("<amatch>"), 0)
line 33:    au BufWriteCmd  tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 34:    au FileWriteCmd tarfile::*/*^Icall tar#Write(expand("<amatch>"))
line 35:   endif
line 36: 
line 37:   au BufReadCmd   *.tar.gz^I^Icall tar#Browse(expand("<amatch>"))
line 38:   au BufReadCmd   *.tar^I^I^Icall tar#Browse(expand("<amatch>"))
line 39:   au BufReadCmd   *.lrp^I^I^Icall tar#Browse(expand("<amatch>"))
line 40:   au BufReadCmd   *.tar.bz2^I^Icall tar#Browse(expand("<amatch>"))
line 41:   au BufReadCmd   *.tar.Z^I^Icall tar#Browse(expand("<amatch>"))
line 42:   au BufReadCmd   *.tbz^I^I^Icall tar#Browse(expand("<amatch>"))
line 43:   au BufReadCmd   *.tgz^I^I^Icall tar#Browse(expand("<amatch>"))
line 44:   au BufReadCmd   *.tar.lzma^Icall tar#Browse(expand("<amatch>"))
line 45:   au BufReadCmd   *.tar.xz^I^Icall tar#Browse(expand("<amatch>"))
line 46:   au BufReadCmd   *.txz^I^I^Icall tar#Browse(expand("<amatch>"))
line 47:   au BufReadCmd   *.tar.zst^I^Icall tar#Browse(expand("<amatch>"))
line 48:   au BufReadCmd   *.tzs^I^I^Icall tar#Browse(expand("<amatch>"))
line 49: augroup END
line 50: com! -nargs=? -complete=file Vimuntar call tar#Vimuntar(<q-args>)
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: " Restoration And Modelines: {{{1
line 54: " vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing C:\Program Files\Vim\vim90\plugin\tarPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\tohtml.vim"
line 1: " Vim plugin for converting a syntax highlighted file to HTML.
line 2: " Maintainer: Ben Fritz <fritzophrenic@gmail.com>
line 3: " Last Change: 2023 Sep 07
line 4: "
line 5: " The core of the code is in $VIMRUNTIME/autoload/tohtml.vim and
line 6: " $VIMRUNTIME/syntax/2html.vim
line 7: "
line 8: if exists('g:loaded_2html_plugin')
line 9:   finish
line 10: endif
line 11: let g:loaded_2html_plugin = 'vim9.0_v2'
line 12: 
line 13: "
line 14: " Changelog: {{{
line 15: "   9.0_v2  (this version): - Warn if using deprecated g:use_xhtml option
line 16: "                           - Change default g:html_use_input_for_pc to "none"
line 17: "                             instead of "fallback". All modern browsers support
line 18: "                             the "user-select: none" and "content:" CSS
line 19: "                             properties so the older method relying on extra
line 20: "                             markup and unspecified browser/app clipboard
line 21: "                             handling is only needed in rare special cases.
line 22: "                           - Fix SourceForge issue #33: generate diff filler
line 23: "                             correctly when new lines have been added to or
line 24: "                             removed from end of buffer.
line 25: "                           - Fix SourceForge issue #32/Vim Github issue #8547:
line 26: "                             use translated highlight ID for styling the
line 27: "                             special-use group names (e.g. LineNr) used
line 28: "                             directly by name in the 2html processing.
line 29: "                           - Fix SourceForge issue #26, refactoring to use
line 30: "                             :let-heredoc style string assignment and
line 31: "                             additional fixes for ".." vs. "." style string
line 32: "                             concatenation. Requires Vim v8.1.1354 or higher.
line 33: "   9.0_v1  (Vim 9.0.1275): - Implement g:html_no_doc and g:html_no_modeline
line 34: "                             for diff mode. Add tests.
line 35: "           (Vim 9.0.1122): NOTE: no version string update for this version!
line 36: "                           - Bugfix for variable name in g:html_no_doc
line 37: "           (Vim 9.0.0819): NOTE: no version string update for this version!
line 38: "                           - Add options g:html_no_doc, g:html_no_lines,
line 39: "                             and g:html_no_modeline (partially included in Vim
line 40: "                             runtime prior to version string update).
line 41: "                           - Updates for new Vim9 string append style (i.e. use
line 42: "                             ".." instead of "."). Requires Vim version
line 43: "                             8.1.1114 or higher.
line 44: "
line 45: "   8.1 updates: {{{
line 46: "   8.1_v2  (Vim 8.1.2312): - Fix SourceForge issue #19: fix calculation of tab
line 47: "                             stop position to use in expanding a tab, when that
line 48: "                             tab occurs after a syntax match which in turn
line 49: "                             comes after previously expanded tabs.
line 50: "                           - Set eventignore while splitting a window for the
line 51: "                             destination file to ignore FileType events;
line 52: "                             speeds up processing when the destination file
line 53: "                             already exists and HTML highlight takes too long.
line 54: "                           - Fix SourceForge issue #20: progress bar could not be
line 55: "                             seen when DiffDelete background color matched
line 56: "                             StatusLine background color. Added TOhtmlProgress
line 57: "                             highlight group for manual user override, but
line 58: "                             calculate it to be visible compared to StatusLine
line 59: "                             by default.
line 60: "                           - Fix SourceForge issue #1: Remove workaround for old
line 61: "                             browsers which don't support 'ch' CSS unit, since
line 62: "                             all modern browsers, including IE>=9, support it.
line 63: "                           - Fix SourceForge issue #10: support termguicolors
line 64: "                           - Fix SourceForge issue #21: default to using
line 65: "                             generated content instead of <input> tags for
line 66: "                             uncopyable text, so that text is correctly
line 67: "                             prevented from being copied in chrome. Use
line 68: "                             g:html_use_input_for_pc option to control the
line 69: "                             method used.
line 70: "                           - Switch to HTML5 to allow using vnu as a validator
line 71: "                             in unit test.
line 72: "                           - Fix fallback sizing of <input> tags for browsers
line 73: "                             without "ch" support.
line 74: "                           - Fix cursor on unselectable diff filler text.
line 75: "   8.1_v1  (Vim 8.1.0528): - Fix SourceForge issue #6: Don't generate empty
line 76: "                             script tag.
line 77: "                           - Fix SourceForge issue #5: javascript should
line 78: "                             declare variables with "var".
line 79: "                           - Fix SourceForge issue #13: errors thrown sourcing
line 80: "                             2html.vim directly when plugins not loaded.
line 81: "                           - Fix SourceForge issue #16: support 'vartabstop'.
line 82: "}}}
line 83: "
line 84: "   7.4 updates: {{{
line 85: "   7.4_v2  (Vim 7.4.0899): Fix error raised when converting a diff containing
line 86: "                           an empty buffer. Jan Stocker: allow g:html_font to
line 87: "                           take a list so it is easier to specfiy fallback
line 88: "                           fonts in the generated CSS.
line 89: "   7.4_v1  (Vim 7.4.0000): Fix modeline mangling for new "Vim:" format, and
line 90: "^I^I^I    also for version-specific modelines like "vim>703:".
line 91: "}}}
line 92: "
line 93: "   7.3 updates: {{{
line 94: "   7.3_v14 (Vim 7.3.1246): Allow suppressing line number anchors using
line 95: "^I^I^I    g:html_line_ids=0. Allow customizing
line 96: "^I^I^I    important IDs (like line IDs and fold IDs) using
line 97: "^I^I^I    g:html_id_expr evaluated when the buffer conversion
line 98: "^I^I^I    is started.
line 99: "   7.3_v13 (Vim 7.3.1088): Keep foldmethod at manual in the generated file and
line 100: "^I^I^I    insert modeline to set it to manual.
line 101: "^I^I^I    Fix bug: diff mode with 2 unsaved buffers creates a
line 102: "^I^I^I    duplicate of one buffer instead of including both.
line 103: "^I^I^I    Add anchors to each line so you can put '#L123'
line 104: "^I^I^I    or '#123' at the end of the URL to jump to line 123
line 105: "^I^I^I    (idea by Andy Spencer). Add javascript to open folds
line 106: "^I^I^I    to show the anchor being jumped to if it is hidden.
line 107: "^I^I^I    Fix XML validation error: &nsbp; not part of XML.
line 108: "^I^I^I    Allow TOhtml to chain together with other commands
line 109: "^I^I^I    using |.
line 110: "   7.3_v12 (Vim 7.3.0616): Fix modeline mangling to also work for when multiple
line 111: "^I^I^I    highlight groups make up the start-of-modeline text.
line 112: "^I^I^I    Improve render time of page with uncopyable regions
line 113: "^I^I^I    by not using one-input-per-char. Change name of
line 114: "^I^I^I    uncopyable option from html_unselectable to
line 115: "^I^I^I    html_prevent_copy. Added html_no_invalid option and
line 116: "^I^I^I    default to inserting invalid markup for uncopyable
line 117: "^I^I^I    regions to prevent MS Word from pasting undeletable
line 118: "^I^I^I    <input> elements. Fix 'cpo' handling (Thilo Six).
line 119: "^I^I 7.3_v12b1: Add html_unselectable option. Rework logic to
line 120: "^I^I^I    eliminate post-processing substitute commands in
line 121: "^I^I^I    favor of doing the work up front. Remove unnecessary
line 122: "^I^I^I    special treatment of 'LineNr' highlight group. Minor
line 123: "^I^I^I    speed improvements. Fix modeline mangling in
line 124: "^I^I^I    generated output so it works for text in the first
line 125: "^I^I^I    column. Fix missing line number and fold column in
line 126: "^I^I^I    diff filler lines. Fix that some fonts have a 1px
line 127: "^I^I^I    gap (using a dirty hack, improvements welcome). Add
line 128: "^I^I^I    "colorscheme" meta tag. Does NOT include support for
line 129: "^I^I^I    the new default foldtext added in v11, as the patch
line 130: "^I^I^I    adding it has not yet been included in Vim.
line 131: "   7.3_v11 ( unreleased ): Support new default foldtext from patch by Christian
line 132: "^I^I^I    Brabandt in
line 133: "^I^I^I    http://groups.google.com/d/topic/vim_dev/B6FSGfq9VoI/discussion.
line 134: "^I^I^I    This patch has not yet been included in Vim, thus
line 135: "^I^I^I    these changes are removed in the next version.
line 136: "   7.3_v10 (Vim 7.3.0227): Fix error E684 when converting a range wholly inside
line 137: "^I^I^I    multiple nested folds with dynamic folding on.
line 138: "^I^I^I    Also fix problem with foldtext in this situation.
line 139: "   7.3_v9  (Vim 7.3.0170): Add html_pre_wrap option active with html_use_css
line 140: "^I^I^I    and without html_no_pre, default value same as
line 141: "^I^I^I    'wrap' option, (Andy Spencer). Don't use
line 142: "^I^I^I    'fileencoding' for converted document encoding if
line 143: "^I^I^I    'buftype' indicates a special buffer which isn't
line 144: "^I^I^I    written.
line 145: "   7.3_v8  (Vim 7.3.0100): Add html_expand_tabs option to allow leaving tab
line 146: "^I^I^I    characters in generated output (Andy Spencer).
line 147: "^I^I^I    Escape text that looks like a modeline so Vim
line 148: "^I^I^I    doesn't use anything in the converted HTML as a
line 149: "^I^I^I    modeline. Bugfixes: Fix folding when a fold starts
line 150: "^I^I^I    before the conversion range. Remove fold column when
line 151: "^I^I^I    there are no folds.
line 152: "   7.3_v7  (Vim 7-3-0063): see betas released on vim_dev below:
line 153: "^I^I  7.3_v7b3: Fixed bug, convert Unicode to UTF-8 all the way.
line 154: "^I^I  7.3_v7b2: Remove automatic detection of encodings that are not
line 155: "^I^I^I    supported by all major browsers according to
line 156: "^I^I^I    http://wiki.whatwg.org/wiki/Web_Encodings and
line 157: "^I^I^I    convert to UTF-8 for all Unicode encodings. Make
line 158: "^I^I^I    HTML encoding to Vim encoding detection be
line 159: "^I^I^I    case-insensitive for built-in pairs.
line 160: "^I^I  7.3_v7b1: Remove use of setwinvar() function which cannot be
line 161: "^I^I^I    called in restricted mode (Andy Spencer). Use
line 162: "^I^I^I    'fencoding' instead of 'encoding' to determine by
line 163: "^I^I^I    charset, and make sure the 'fenc' of the generated
line 164: "^I^I^I    file matches its indicated charset. Add charsets for
line 165: "^I^I^I    all of Vim's natively supported encodings.
line 166: "   7.3_v6  (Vim 7.3.0000): Really fix bug with 'nowrapscan', 'magic' and other
line 167: "^I^I^I    user settings interfering with diff mode generation,
line 168: "^I^I^I    trailing whitespace (e.g. line number column) when
line 169: "^I^I^I    using html_no_pre, and bugs when using
line 170: "^I^I^I    html_hover_unfold.
line 171: "   7.3_v5  ( unreleased ): Fix bug with 'nowrapscan' and also with out-of-sync
line 172: "^I^I^I    folds in diff mode when first line was folded.
line 173: "   7.3_v4  (Vim 7.3.0000): Bugfixes, especially for xhtml markup, and diff mode
line 174: "   7.3_v3  (Vim 7.3.0000): Refactor option handling and make html_use_css
line 175: "^I^I^I    default to true when not set to anything. Use strict
line 176: "^I^I^I    doctypes where possible. Rename use_xhtml option to
line 177: "^I^I^I    html_use_xhtml for consistency. Use .xhtml extension
line 178: "^I^I^I    when using this option. Add meta tag for settings.
line 179: "   7.3_v2  (Vim 7.3.0000): Fix syntax highlighting in diff mode to use both the
line 180: "^I^I^I    diff colors and the normal syntax colors
line 181: "   7.3_v1  (Vim 7.3.0000): Add conceal support and meta tags in output
line 182: "}}}
line 183: "}}}
line 184: 
line 185: " TODO: {{{
line 186: "   * Check the issue tracker:
line 187: "     https://sourceforge.net/p/vim-tohtml/issues/search/?q=%21status%3Aclosed
line 188: "   * Options for generating the CSS in external style sheets. New :TOcss
line 189: "     command to convert the current color scheme into a (mostly) generic CSS
line 190: "     stylesheet which can be re-used. Alternate stylesheet support? Good start
line 191: "     by Erik Falor
line 192: "     ( https://groups.google.com/d/topic/vim_use/7XTmC4D22dU/discussion ).
line 193: "   * Add optional argument to :TOhtml command to specify mode (gui, cterm,
line 194: "     term) to use for the styling. Suggestion by "nacitar".
line 195: "   * Add way to override or specify which RGB colors map to the color numbers
line 196: "     in cterm. Get better defaults than just guessing? Suggestion by "nacitar".
line 197: "   * Disable filetype detection until after all processing is done.
line 198: "   * Add option for not generating the hyperlink on stuff that looks like a
line 199: "     URL? Or just color the link to fit with the colorscheme (and only special
line 200: "     when hovering)?
line 201: "   * Bug: Opera does not allow printing more than one page if uncopyable
line 202: "     regions is turned on. Possible solution: Add normal text line numbers with
line 203: "     display:none, set to display:inline for print style sheets, and hide
line 204: "     <input> elements for print, to allow Opera printing multiple pages (and
line 205: "     other uncopyable areas?). May need to make the new text invisible to IE
line 206: "     with conditional comments to prevent copying it, IE for some reason likes
line 207: "     to copy hidden text. Other browsers too?
line 208: "   * Bug: still a 1px gap throughout the fold column when html_prevent_copy is
line 209: "     "fn" in some browsers. Specifically, in Chromium on Ubuntu (but not Chrome
line 210: "     on Windows). Perhaps it is font related?
line 211: "   * Bug: still some gaps in the fold column when html_prevent_copy contains
line 212: "     'd' and showing the whole diff (observed in multiple browsers). Only gaps
line 213: "     on diff lines though.
line 214: "   * Undercurl support via CSS3, with fallback to dotted or something:
line 215: "^Ihttps://groups.google.com/d/topic/vim_use/BzXA6He1pHg/discussion
line 216: "   * Redo updates for modified default foldtext (v11) when/if the patch is
line 217: "     accepted to modify it.
line 218: "   * Test case +diff_one_file-dynamic_folds+expand_tabs-hover_unfold
line 219: "^I^I+ignore_conceal-ignore_folding+no_foldcolumn+no_pre+no_progress
line 220: "^I^I+number_lines-pre_wrap-use_css+use_xhtml+whole_filler.xhtml
line 221: "     does not show the whole diff filler as it is supposed to?
line 222: "   * Bug: when 'isprint' is wrong for the current encoding, will generate
line 223: "     invalid content. Can/should anything be done about this? Maybe a separate
line 224: "     plugin to correct 'isprint' based on encoding?
line 225: "   * Check to see if the windows-125\d encodings actually work in Unix without
line 226: "     the 8bit- prefix. Add prefix to autoload dictionaries for Unix if not.
line 227: "   * Font auto-detection similar to
line 228: "     http://www.vim.org/scripts/script.php?script_id=2384 but for a variety of
line 229: "     platforms.
line 230: "   * Pull in code from http://www.vim.org/scripts/script.php?script_id=3113 :
line 231: "^I- listchars support
line 232: "^I- full-line background highlight
line 233: "^I- other?
line 234: "   * Make it so deleted lines in a diff don't create side-scrolling (get it
line 235: "     free with full-line background highlight above).
line 236: "   * Restore open/closed folds and cursor position after processing each file
line 237: "     with option not to restore for speed increase.
line 238: "   * Add extra meta info (generation time, etc.)?
line 239: "   * Tidy up so we can use strict doctype in even more situations
line 240: "   * Implementation detail: add threshold for writing the lines to the html
line 241: "     buffer before we're done (5000 or so lines should do it)
line 242: "   * TODO comments for code cleanup scattered throughout
line 243: "}}}
line 244: 
line 245: " Define the :TOhtml command when:
line 246: " - 'compatible' is not set
line 247: " - this plugin or user override was not already loaded
line 248: " - user commands are available. {{{
line 249: if !&cp && !exists(":TOhtml") && has("user_commands")
line 250:   command -range=% -bar TOhtml :call tohtml#Convert2HTML(<line1>, <line2>)
line 251: endif "}}}
line 252: 
line 253: " Make sure any patches will probably use consistent indent
line 254: "   vim: ts=8 sw=2 sts=2 noet fdm=marker
finished sourcing C:\Program Files\Vim\vim90\plugin\tohtml.vim
sourcing "C:\Program Files\Vim\vim90\plugin\vimballPlugin.vim"
line 1: " vimballPlugin : construct a file containing both paths and files
line 2: " Author: Charles E. Campbell
line 3: " Copyright: (c) 2004-2014 by Charles E. Campbell
line 4: "            The VIM LICENSE applies to Vimball.vim, and Vimball.txt
line 5: "            (see |copyright|) except use "Vimball" instead of "Vim".
line 6: "            No warranty, express or implied.
line 7: "  *** ***   Use At-Your-Own-Risk!   *** ***
line 8: "
line 9: " (Rom 2:1 WEB) Therefore you are without excuse, O man, whoever you are who
line 10: "      judge. For in that which you judge another, you condemn yourself. For
line 11: "      you who judge practice the same things.
line 12: " GetLatestVimScripts: 1502 1 :AutoInstall: vimball.vim
line 13: 
line 14: " ---------------------------------------------------------------------
line 15: "  Load Once: {{{1
line 16: if &cp || exists("g:loaded_vimballPlugin")
line 17:  finish
line 18: endif
line 19: let g:loaded_vimballPlugin = "v37"
line 20: let s:keepcpo              = &cpo
line 21: set cpo&vim
line 22: 
line 23: " ------------------------------------------------------------------------------
line 24: " Public Interface: {{{1
line 25: com! -range   -complete=file -nargs=+ -bang MkVimball^I^Icall vimball#MkVimball(<line1>,<line2>,<bang>0,<f-args>)
line 26: com! -nargs=? -complete=dir  UseVimball^I^I^I^I^I^Icall vimball#Vimball(1,<f-args>)
line 27: com! -nargs=0                VimballList^I^I^I^I^Icall vimball#Vimball(0)
line 28: com! -nargs=* -complete=dir  RmVimball^I^I^I^I^I^Icall vimball#SaveSettings()|call vimball#RmVimball(<f-args>)|call vimball#RestoreSettings()
line 29: augroup Vimball
line 30:  au!
line 31:  au BufEnter  *.vba,*.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0, "Source this file to extract it! (:so %)")|endif | endif
line 35:  au SourceCmd *.vba.gz,*.vba.bz2,*.vba.zip,*.vba.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 36:  au SourceCmd *.vba^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 37:  au BufEnter  *.vmb,*.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz if getline(1) =~ '^" Vimball Archiver' |  setlocal bt=nofile fmr=[[[,]]] fdm=marker|if &ff != 'unix'|setlocal ma ff=unix noma|endif|if line('$') > 1|call vimball#ShowMesg(0,"Source this file to extract it! (:so %)")|endif | endif
line 41:  au SourceCmd *.vmb.gz,*.vmb.bz2,*.vmb.zip,*.vmb.xz^I^I^Ilet s:origfile=expand("%")|if expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|endif|call vimball#Decompress(expand("<amatch>"))|so %|if s:origfile!=expand("<afile>")|close|endif
line 42:  au SourceCmd *.vmb^I^I^I^I^I^I^I^I^I^I^Iif expand("%")!=expand("<afile>") | exe "1sp" fnameescape(expand("<afile>"))|call vimball#Vimball(1)|close|else|call vimball#Vimball(1)|endif
line 43: augroup END
line 44: 
line 45: " =====================================================================
line 46: " Restoration And Modelines: {{{1
line 47: " vim: fdm=marker
line 48: let &cpo= s:keepcpo
line 49: unlet s:keepcpo
line 50: 
line 51: " vim: ts=4:
finished sourcing C:\Program Files\Vim\vim90\plugin\vimballPlugin.vim
sourcing "C:\Program Files\Vim\vim90\plugin\zipPlugin.vim"
line 1: " zipPlugin.vim: Handles browsing zipfiles
line 2: "            PLUGIN PORTION
line 3: " Date:^I^I^IDec 07, 2021
line 4: " Maintainer:^ICharles E Campbell <NcampObell@SdrPchip.AorgM-NOSPAM>
line 5: " License:^I^IVim License  (see vim's :help license)
line 6: " Copyright:    Copyright (C) 2005-2016 Charles E. Campbell {{{1
line 7: "               Permission is hereby granted to use and distribute this code,
line 8: "               with or without modifications, provided that this copyright
line 9: "               notice is copied with it. Like anything else that's free,
line 10: "               zipPlugin.vim is provided *as is* and comes with no warranty
line 11: "               of any kind, either expressed or implied. By using this
line 12: "               plugin, you agree that in no event will the copyright
line 13: "               holder be liable for any damages resulting from the use
line 14: "               of this software.
line 15: "
line 16: " (James 4:8 WEB) Draw near to God, and he will draw near to you.
line 17: " Cleanse your hands, you sinners; and purify your hearts, you double-minded.
line 18: " ---------------------------------------------------------------------
line 19: " Load Once: {{{1
line 20: if &cp || exists("g:loaded_zipPlugin")
line 21:  finish
line 22: endif
line 23: let g:loaded_zipPlugin = "v33"
line 24: let s:keepcpo          = &cpo
line 25: set cpo&vim
line 26: 
line 27: " ---------------------------------------------------------------------
line 28: " Options: {{{1
line 29: if !exists("g:zipPlugin_ext")
line 30:  let g:zipPlugin_ext='*.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip'
line 31: endif
line 32: 
line 33: " ---------------------------------------------------------------------
line 34: " Public Interface: {{{1
line 35: augroup zip
line 36:  au!
line 37:  au BufReadCmd   zipfile:*^Icall zip#Read(expand("<amatch>"), 1)
line 38:  au FileReadCmd  zipfile:*^Icall zip#Read(expand("<amatch>"), 0)
line 39:  au BufWriteCmd  zipfile:*^Icall zip#Write(expand("<amatch>"))
line 40:  au FileWriteCmd zipfile:*^Icall zip#Write(expand("<amatch>"))
line 41: 
line 42:  if has("unix")
line 43:   au BufReadCmd   zipfile:*/*^Icall zip#Read(expand("<amatch>"), 1)
line 44:   au FileReadCmd  zipfile:*/*^Icall zip#Read(expand("<amatch>"), 0)
line 45:   au BufWriteCmd  zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 46:   au FileWriteCmd zipfile:*/*^Icall zip#Write(expand("<amatch>"))
line 47:  endif
line 48: 
line 49:  exe "au BufReadCmd ".g:zipPlugin_ext.' call zip#Browse(expand("<amatch>"))'
line 49: au BufReadCmd *.aar,*.apk,*.celzip,*.crtx,*.docm,*.docx,*.dotm,*.dotx,*.ear,*.epub,*.gcsx,*.glox,*.gqsx,*.ja,*.jar,*.kmz,*.odb,*.odc,*.odf,*.odg,*.odi,*.odm,*.odp,*.ods,*.odt,*.otc,*.otf,*.otg,*.oth,*.oti,*.otp,*.ots,*.ott,*.oxt,*.potm,*.potx,*.ppam,*.ppsm,*.ppsx,*.pptm,*.pptx,*.sldx,*.thmx,*.vdw,*.war,*.wsz,*.xap,*.xlam,*.xlsb,*.xlsm,*.xlsx,*.xltm,*.xltx,*.xpi,*.zip call zip#Browse(expand("<amatch>"))
line 50: augroup END
line 51: 
line 52: " ---------------------------------------------------------------------
line 53: "  Restoration And Modelines: {{{1
line 54: "  vim: fdm=marker
line 55: let &cpo= s:keepcpo
line 56: unlet s:keepcpo
finished sourcing C:\Program Files\Vim\vim90\plugin\zipPlugin.vim
Searching for "pack/*/start/*" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles\pack/*/start/*"
Searching for "C:\Program Files\Vim\vim90\pack/*/start/*"
Searching for "C:\Users\chris/vimfiles/after\pack/*/start/*"
Searching for "C:\Program Files\Vim/vimfiles/after\pack/*/start/*"
not found in 'packpath': "pack/*/start/*"
Searching for "plugin/**/*.vim" in "C:\Users\chris/vimfiles,C:\Program Files\Vim/vimfiles,C:\Program Files\Vim\vim90,C:\Users\chris/vimfiles/after,C:\Program Files\Vim/vimfiles/after"
Searching for "C:\Users\chris/vimfiles/after\plugin/**/*.vim"
Searching for "C:\Program Files\Vim/vimfiles/after\plugin/**/*.vim"
not found in 'runtimepath': "plugin/**/*.vim"
Reading viminfo file "C:\Users\chris\_viminfo" info oldfiles
Executing BufWinEnter Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>15_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>15_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>15_Remove_Matches returning #0

continuing in <SNR>15_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
<SNR>15_Highlight_Matching_Pair returning #0

continuing in BufWinEnter Autocommands for "*"

Executing BufEnter Autocommands for "*"
autocommand sil call s:LocalBrowse(expand("<amatch>"))

Executing: sil call s:LocalBrowse(expand("<amatch>"))
calling <SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
<SNR>16_LocalBrowse returning #0

continuing in BufEnter Autocommands for "*"

Executing VimEnter Autocommands for "*"
autocommand sil call s:VimEnter(expand("<amatch>"))

Executing: sil call s:VimEnter(expand("<amatch>"))
calling <SNR>16_VimEnter('')

line 1: "  call Dfunc("s:VimEnter(dirname<".a:dirname.">) expand(%)<".expand("%").">")
line 2:   if has('nvim') || v:version < 802
line 3:   " Johann Hchtl: reported that the call range... line causes an E488: Trailing characters
line 4:   "                error with neovim. I suspect its because neovim hasn't updated with recent
line 5:   "                vim patches. As is, this code will have problems with popup terminals
line 6:   "                instantiated before the VimEnter event runs.
line 7:   " Ingo Karkat  : E488 also in Vim 8.1.1602
line 8:   let curwin       = winnr()
line 9:   let s:vimentered = 1
line 10:   windo call s:LocalBrowse(expand("%:p"))
line 11:   exe curwin."wincmd w"
line 12:  else
line 13:   " the following complicated expression comes courtesy of lacygoill; largely does the same thing as the windo and 
line 14:   " wincmd which are commented out, but avoids some side effects. Allows popup terminal before VimEnter.
line 15:   let s:vimentered = 1
line 16:   call range(1, winnr('$'))->map({_, v -> win_execute(win_getid(v), 'call expand("%:p")->s:LocalBrowse()')})
calling <lambda>1(0, 1)

line 1: call expand("%:p")->s:LocalBrowse()
calling <SNR>16_LocalBrowse('')

line 1:   " Unfortunate interaction -- only DechoMsg debugging calls can be safely used here.
line 2:   " Otherwise, the BufEnter event gets triggered when attempts to write to
line 3:   " the DBG buffer are made.
line 4: 
line 5:   if !exists("s:vimentered")
line 6:    " If s:vimentered doesn't exist, then the VimEnter event hasn't fired.  It will,
line 7:    " and so s:VimEnter() will then be calling this routine, but this time with s:vimentered defined.
line 8: "   call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered doesn't exist)")
line 9: "   call Dret("s:LocalBrowse")
line 10:    return
line 11:   endif
line 12: 
line 13: "  call Dfunc("s:LocalBrowse(dirname<".a:dirname.">)  (s:vimentered=".s:vimentered.")")
line 14: 
line 15:   if has("amiga")
line 16:    " The check against '' is made for the Amiga, where the empty
line 17:    " string is the current directory and not checking would break
line 18:    " things such as the help command.
line 19: "   call Decho("(LocalBrowse) dirname<".a:dirname.">  (isdirectory, amiga)")
line 20:    if a:dirname != '' && isdirectory(a:dirname)
line 21:     sil! call netrw#LocalBrowseCheck(a:dirname)
line 22:     if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 23:      exe w:netrw_bannercnt
line 24:     endif
line 25:    endif
line 26: 
line 27:   elseif isdirectory(a:dirname)
line 28: "   call Decho("(LocalBrowse) dirname<".a:dirname."> ft=".&ft."  (isdirectory, not amiga)")
line 29: "   call Dredir("LocalBrowse ft last set: ","verbose set ft")
line 30:    " Jul 13, 2021: for whatever reason, preceding the following call with
line 31:    " a   sil!  causes an unbalanced if-endif vim error
line 32:    call netrw#LocalBrowseCheck(a:dirname)
line 33:    if exists("w:netrw_bannercnt") && line('.') < w:netrw_bannercnt
line 34:     exe w:netrw_bannercnt
line 35:    endif
line 36: 
line 37:   else
line 38:    " not a directory, ignore it
line 39: "   call Decho("(LocalBrowse) dirname<".a:dirname."> not a directory, ignoring...")
line 40:   endif
line 41: 
line 42: "  call Dret("s:LocalBrowse")
<SNR>16_LocalBrowse returning #0

continuing in <lambda>1

<lambda>1 returning '^@line 1: call expand("%:p")->s:Local...urning #0^@^@continuing in <lambda>1^@'

continuing in <SNR>16_VimEnter

line 17:  endif
line 18: "  call Dret("s:VimEnter")
<SNR>16_VimEnter returning #0

continuing in VimEnter Autocommands for "*"

Executing CursorMoved Autocommands for "*"
autocommand call s:Highlight_Matching_Pair()

Executing: call s:Highlight_Matching_Pair()
calling <SNR>15_Highlight_Matching_Pair()

line 1:   if !exists("w:matchparen_ids")
line 2:     let w:matchparen_ids = []
line 3:   endif
line 4:   " Remove any previous match.
line 5:   call s:Remove_Matches()
calling <SNR>15_Remove_Matches()

line 1:   if exists('w:paren_hl_on') && w:paren_hl_on
line 2:     while !empty(w:matchparen_ids)
line 3:       silent! call remove(w:matchparen_ids, 0)->matchdelete()
line 4:     endwhile
line 5:     let w:paren_hl_on = 0
line 6:   endif
<SNR>15_Remove_Matches returning #0

continuing in <SNR>15_Highlight_Matching_Pair

line 6: 
line 7:   " Avoid that we remove the popup menu.
line 8:   " Return when there are no colors (looks like the cursor jumps).
line 9:   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
line 10:     return
line 11:   endif
line 12: 
line 13:   " Get the character under the cursor and check if it's in 'matchpairs'.
line 14:   let c_lnum = line('.')
line 15:   let c_col = col('.')
line 16:   let before = 0
line 17: 
line 18:   let text = getline(c_lnum)
line 19:   let matches = matchlist(text, '\(.\)\=\%'.c_col.'c\(.\=\)')
line 20:   if empty(matches)
line 21:     let [c_before, c] = ['', '']
line 22:   else
line 23:     let [c_before, c] = matches[1:2]
line 24:   endif
line 25:   let plist = split(&matchpairs, '.\zs[:,]')
line 26:   let i = index(plist, c)
line 27:   if i < 0
line 28:     " not found, in Insert mode try character before the cursor
line 29:     if c_col > 1 && (mode() == 'i' || mode() == 'R')
line 30:       let before = strlen(c_before)
line 31:       let c = c_before
line 32:       let i = index(plist, c)
line 33:     endif
line 34:     if i < 0
line 35:       " not found, nothing to do
line 36:       return
<SNR>15_Highlight_Matching_Pair returning #0

continuing in CursorMoved Autocommands for "*"


Executing: q!
Writing viminfo file "C:\Users\chris\_viminfo"